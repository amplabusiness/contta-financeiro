-- ============================================================================
-- CONTTA FINANCEIRO - SCHEMA COMPLETO DO BANCO DE DADOS
-- ============================================================================
--
-- Sistema de Gestao Financeira e Contabil para Escritorios de Contabilidade
--
-- Versao: 1.0.0
-- Data de Exportacao: 2026-01-20
-- Banco de Dados: PostgreSQL 15+ com Supabase
--
-- ============================================================================
-- INDICE DO ARQUIVO
-- ============================================================================
--
-- SECAO 1: CONFIGURACOES INICIAIS (~Linha 130)
--    - Configuracoes de sessao PostgreSQL
--    - Extensoes do banco de dados (pg_cron, pg_net, pgcrypto, uuid-ossp)
--
-- SECAO 2: TIPOS PERSONALIZADOS (ENUMS) (~Linha 180)
--    - app_role: Papeis de usuario (admin, accountant, viewer)
--
-- SECAO 3: FUNCOES E PROCEDURES (~Linha 190 - ~Linha 12500)
--    - 261 funcoes para logica de negocio
--    - Automacoes contabeis
--    - Calculos financeiros
--    - Triggers e validacoes
--
-- SECAO 4: TABELAS (~Linha 12550 - ~Linha 23500)
--    - 230 tabelas do sistema
--    - Estrutura multi-tenant com tenant_id
--    - Relacionamentos e constraints
--
-- SECAO 5: VIEWS E MATERIALIZED VIEWS (~Linha 12670 - ~Linha 21100)
--    - 93 views para relatorios
--    - Views materializadas para performance
--    - DRE, Balancete, Fluxo de Caixa
--
-- SECAO 6: INDICES (~Linha 23600 - ~Linha 29500)
--    - 686 indices para otimizacao
--    - Indices compostos e parciais
--    - Indices unicos para integridade
--
-- SECAO 7: ROW LEVEL SECURITY (RLS) (~Linha 29540 - ~Linha 29900)
--    - Isolamento multi-tenant
--    - Politicas de seguranca por tenant_id
--
-- SECAO 8: POLITICAS DE ACESSO (~Linha 29510 - ~Linha 31100)
--    - 230 politicas RLS
--    - Controle de acesso granular
--
-- SECAO 9: PERMISSOES (GRANTS) (~Linha 31140 - ~Linha 34900)
--    - Permissoes para roles: anon, authenticated, service_role
--    - Grants em tabelas, funcoes e sequences
--
-- ============================================================================
-- MODULOS PRINCIPAIS DO SISTEMA
-- ============================================================================
--
-- 1. GESTAO FINANCEIRA
--    - Contas a Pagar (expenses)
--    - Contas a Receber (invoices)
--    - Fluxo de Caixa (cash_flow)
--    - Projecoes Financeiras (cash_flow_projections)
--
-- 2. CONTABILIDADE
--    - Plano de Contas (chart_of_accounts)
--    - Lancamentos Contabeis (accounting_entries, journal_entries)
--    - DRE e Balanco Patrimonial
--    - Fechamento Mensal (monthly_closings)
--
-- 3. GESTAO DE CLIENTES
--    - Cadastro de Clientes (clients)
--    - Contratos (contracts, accounting_contracts)
--    - Honorarios e Comissoes
--    - Grupos Economicos (economic_groups)
--
-- 4. DEPARTAMENTO PESSOAL
--    - Funcionarios (employees)
--    - Folha de Pagamento (payrolls)
--    - eSocial (esocial_rubricas)
--    - Rescisoes (employee_terminations)
--
-- 5. FISCAL
--    - NFS-e (nfse, nfse_tomadas)
--    - Retencoes Tributarias
--    - Obrigacoes Fiscais (tax_obligations)
--
-- 6. BANCOS
--    - Contas Bancarias (bank_accounts)
--    - Transacoes (bank_transactions)
--    - Conciliacao Bancaria (bank_reconciliation)
--    - Importacao OFX
--
-- 7. INTELIGENCIA ARTIFICIAL
--    - Classificacao Automatica
--    - Agentes de IA (ai_agents)
--    - Padroes Aprendidos (ai_learned_patterns)
--
-- ============================================================================
-- ARQUITETURA MULTI-TENANT
-- ============================================================================
--
-- O sistema utiliza isolamento por tenant_id em todas as tabelas principais.
-- A funcao get_my_tenant_id() retorna o tenant do usuario autenticado.
-- Politicas RLS garantem que cada usuario acesse apenas dados do seu tenant.
--
-- ============================================================================




SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;



-- ============================================================================
-- SECAO 1: EXTENSOES DO POSTGRESQL
-- ============================================================================
-- Extensoes necessarias para o funcionamento do sistema:
-- - pg_cron: Agendamento de tarefas no banco de dados
-- - pg_net: Requisicoes HTTP a partir do banco
-- - moddatetime: Atualizacao automatica de campos updated_at
-- - pg_graphql: API GraphQL automatica do Supabase
-- - pgcrypto: Funcoes criptograficas
-- - uuid-ossp: Geracao de UUIDs
-- ============================================================================

CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";







-- ============================================================================
-- SECAO 2: TIPOS PERSONALIZADOS (ENUMS)
-- ============================================================================
-- Tipos customizados utilizados no sistema:
-- - app_role: Define os papeis de usuario (admin, accountant, viewer)
-- ============================================================================

CREATE TYPE "public"."app_role" AS ENUM (
    'admin',
    'accountant',
    'viewer'
);


ALTER TYPE "public"."app_role" OWNER TO "postgres";



-- ============================================================================
-- SECAO 3: FUNCOES E STORED PROCEDURES
-- ============================================================================
-- Esta secao contem 261 funcoes organizadas por modulo:
--
-- FINANCEIRO:
--   - activate_negotiation: Ativa negociacao de divida
--   - apply_fee_adjustment: Aplica reajuste de honorarios
--   - calculate_adjusted_fee: Calcula honorario ajustado por SM
--   - register_invoice_payment: Registra pagamento de fatura
--
-- CONTABIL:
--   - fn_auto_accounting_*: Triggers de contabilizacao automatica
--   - fn_create_client_account: Cria conta contabil para cliente
--   - close_month: Fecha o periodo contabil
--   - refresh_all_materialized_views: Atualiza views materializadas
--
-- DEPARTAMENTO PESSOAL:
--   - gerar_folha_funcionario: Gera folha de pagamento
--   - aprovar_rescisao: Aprova e contabiliza rescisao
--   - calcular_inss/irrf: Calculos de encargos
--
-- BANCO:
--   - auto_reconcile_*: Conciliacao automatica
--   - recalculate_bank_balance: Recalcula saldo bancario
--
-- MULTI-TENANT:
--   - get_my_tenant_id: Retorna tenant do usuario logado
--   - fn_auto_set_tenant_id: Define tenant automaticamente
-- ============================================================================

CREATE OR REPLACE FUNCTION "public"."activate_negotiation"("p_negotiation_id" "uuid", "p_contract_url" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "message" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE debt_negotiations
  SET
    status = 'active',
    contract_signed = true,
    contract_signed_at = NOW(),
    contract_url = COALESCE(p_contract_url, contract_url),
    updated_at = NOW()
  WHERE id = p_negotiation_id
    AND status IN ('approved', 'draft');

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Negocia├º├úo n├úo encontrada ou n├úo aprovada'::TEXT;
    RETURN;
  END IF;

  -- Marcar faturas originais como "em negocia├º├úo"
  UPDATE invoices
  SET status = 'cancelled', -- Ou criar um status 'negotiated'
      notes = COALESCE(notes, '') || ' | Inclu├¡da na negocia├º├úo ' || (SELECT negotiation_number FROM debt_negotiations WHERE id = p_negotiation_id)
  WHERE id = ANY(SELECT UNNEST(invoice_ids) FROM debt_negotiations WHERE id = p_negotiation_id);

  -- Marcar saldos de abertura como "em negocia├º├úo"
  UPDATE client_opening_balance
  SET status = 'paid',
      notes = COALESCE(notes, '') || ' | Inclu├¡do na negocia├º├úo ' || (SELECT negotiation_number FROM debt_negotiations WHERE id = p_negotiation_id)
  WHERE id = ANY(SELECT UNNEST(opening_balance_ids) FROM debt_negotiations WHERE id = p_negotiation_id);

  RETURN QUERY SELECT true, 'Negocia├º├úo ativada com sucesso'::TEXT;
END;
$$;


ALTER FUNCTION "public"."activate_negotiation"("p_negotiation_id" "uuid", "p_contract_url" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_id UUID;
  v_balance_before DECIMAL(10,2);
  v_balance_after DECIMAL(10,2);
BEGIN
  v_balance_before := get_barter_balance(p_client_id);
  
  IF p_type = 'credit' THEN
    v_balance_after := v_balance_before + p_amount;
  ELSE
    v_balance_after := v_balance_before - p_amount;
  END IF;
  
  INSERT INTO barter_credits (
    client_id, type, amount, description, reference_date,
    competence, balance_before, balance_after, created_by
  ) VALUES (
    p_client_id, p_type, p_amount, p_description, p_reference_date,
    p_competence, v_balance_before, v_balance_after, auth.uid()
  )
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;


ALTER FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text") IS 'Adiciona uma movimenta├º├úo de cr├®dito de permuta e calcula saldos';



CREATE OR REPLACE FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text" DEFAULT 'forward'::"text", "p_state_code" "text" DEFAULT NULL::"text", "p_municipality_code" "text" DEFAULT NULL::"text") RETURNS "date"
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_result DATE := p_date;
  v_max_iterations INTEGER := 10; -- Evitar loop infinito
  v_iterations INTEGER := 0;
BEGIN
  WHILE NOT is_business_day(v_result, p_state_code, p_municipality_code) AND v_iterations < v_max_iterations LOOP
    IF p_direction = 'forward' THEN
      v_result := v_result + INTERVAL '1 day';
    ELSE
      v_result := v_result - INTERVAL '1 day';
    END IF;
    v_iterations := v_iterations + 1;
  END LOOP;

  RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text", "p_state_code" "text", "p_municipality_code" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text", "p_state_code" "text", "p_municipality_code" "text") IS 'Ajusta uma data para o pr├│ximo dia ├║til (forward) ou dia ├║til anterior (backward)';



CREATE OR REPLACE FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_feature RECORD;
    v_template RECORD;
    v_priority INTEGER;
    v_complexity TEXT;
    v_agent TEXT;
    v_analysis JSONB;
BEGIN
    -- Buscar solicita├º├úo
    SELECT * INTO v_feature FROM feature_requests WHERE id = p_feature_id;

    IF v_feature IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Solicita├º├úo n├úo encontrada');
    END IF;

    -- Tentar encontrar template similar
    SELECT * INTO v_template
    FROM feature_templates
    WHERE is_active
      AND (
          v_feature.title ILIKE '%' || template_name || '%'
          OR v_feature.description ILIKE '%' || ANY(use_cases) || '%'
      )
    LIMIT 1;

    -- Determinar agente respons├ível baseado na categoria/departamento
    v_agent := CASE v_feature.department
        WHEN 'financeiro' THEN 'milton'
        WHEN 'fiscal' THEN 'cicero'
        WHEN 'dp' THEN 'advocato'
        WHEN 'contabil' THEN 'cicero'
        WHEN 'diretoria' THEN 'helena'
        ELSE 'atlas'
    END;

    -- Calcular complexidade baseada no texto
    v_complexity := CASE
        WHEN v_feature.description ILIKE '%api%' OR v_feature.description ILIKE '%integra%' THEN 'complexo'
        WHEN v_feature.description ILIKE '%relat%' OR v_feature.description ILIKE '%dashboard%' THEN 'simples'
        WHEN v_feature.description ILIKE '%automa%' THEN 'medio'
        ELSE 'medio'
    END;

    -- Calcular prioridade
    v_priority := CASE v_feature.department
        WHEN 'diretoria' THEN 80
        WHEN 'financeiro' THEN 70
        WHEN 'contabil' THEN 60
        ELSE 50
    END;

    -- Se encontrou template, usar como base
    IF v_template IS NOT NULL THEN
        v_complexity := COALESCE(v_template.estimated_effort, v_complexity);
        v_priority := v_priority + 10; -- Templates conhecidos s├úo mais f├íceis
    END IF;

    -- Atualizar solicita├º├úo
    UPDATE feature_requests SET
        category = COALESCE(v_template.category, 'melhoria'),
        complexity = v_complexity,
        assigned_agent = v_agent,
        priority_score = v_priority,
        status = 'analyzing',
        analyzed_at = now(),
        agent_analysis = 'Analisado automaticamente. ' ||
            CASE WHEN v_template IS NOT NULL
                THEN 'Template similar encontrado: ' || v_template.template_name
                ELSE 'Necessita an├ílise detalhada.'
            END
    WHERE id = p_feature_id;

    -- Registrar an├ílise
    INSERT INTO feature_analysis_history (
        feature_id, agent_id, agent_name, analysis_type,
        viability_score, impact_score, effort_score,
        recommendation
    ) VALUES (
        p_feature_id, v_agent,
        CASE v_agent
            WHEN 'cicero' THEN 'Dr. C├¡cero'
            WHEN 'milton' THEN 'Prof. Milton'
            WHEN 'helena' THEN 'Dra. Helena'
            WHEN 'atlas' THEN 'Atlas'
            WHEN 'advocato' THEN 'Dr. Advocato'
            ELSE 'Equipe IA'
        END,
        'viabilidade',
        80, -- viability
        v_priority, -- impact
        CASE v_complexity
            WHEN 'simples' THEN 20
            WHEN 'medio' THEN 50
            WHEN 'complexo' THEN 80
            ELSE 50
        END, -- effort
        CASE
            WHEN v_template IS NOT NULL THEN
                'Recomendo usar template "' || v_template.template_name || '". Estimativa: ' || v_template.estimated_effort
            ELSE
                'Solicita├º├úo v├ílida. Aguardando detalhamento t├®cnico.'
        END
    );

    RETURN jsonb_build_object(
        'success', true,
        'feature_id', p_feature_id,
        'assigned_agent', v_agent,
        'complexity', v_complexity,
        'priority_score', v_priority,
        'template_found', v_template IS NOT NULL,
        'template_name', v_template.template_name,
        'clarifying_questions', v_template.clarifying_questions,
        'message', 'Solicita├º├úo analisada! Agente ' || v_agent || ' assumiu.'
    );
END;
$$;


ALTER FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") IS 'Analisa automaticamente uma solicita├º├úo de melhoria';



CREATE OR REPLACE FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "previous_fee" numeric, "new_fee" numeric, "adjustment_percentage" numeric, "message" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_client RECORD;
  v_current_min_wage NUMERIC;
  v_new_fee NUMERIC;
  v_adjustment_pct NUMERIC;
BEGIN
  -- Obter dados do cliente
  SELECT * INTO v_client FROM clients WHERE id = p_client_id;

  IF v_client IS NULL THEN
    RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Cliente n├úo encontrado'::TEXT;
    RETURN;
  END IF;

  -- Verificar se usa reajuste autom├ítico
  IF NOT COALESCE(v_client.auto_adjust_by_minimum_wage, true) THEN
    RETURN QUERY SELECT false, v_client.monthly_fee, v_client.monthly_fee, 0::NUMERIC,
      'Cliente n├úo usa reajuste autom├ítico por SM'::TEXT;
    RETURN;
  END IF;

  -- Verificar se tem fee_in_minimum_wages
  IF v_client.fee_in_minimum_wages IS NULL OR v_client.fee_in_minimum_wages = 0 THEN
    RETURN QUERY SELECT false, v_client.monthly_fee, v_client.monthly_fee, 0::NUMERIC,
      'Cliente n├úo tem honor├írio em SM definido. Execute init_client_minimum_wage_fee primeiro.'::TEXT;
    RETURN;
  END IF;

  -- Obter SM atual
  v_current_min_wage := get_minimum_wage_at_date();

  -- Verificar se j├í foi reajustado com este SM
  IF v_client.last_adjustment_minimum_wage = v_current_min_wage THEN
    RETURN QUERY SELECT false, v_client.monthly_fee, v_client.monthly_fee, 0::NUMERIC,
      format('J├í reajustado para SM de R$ %s', v_current_min_wage)::TEXT;
    RETURN;
  END IF;

  -- Calcular novo honor├írio
  v_new_fee := calculate_adjusted_fee(v_client.fee_in_minimum_wages);

  -- Calcular percentual de reajuste
  IF v_client.monthly_fee > 0 THEN
    v_adjustment_pct := ROUND(((v_new_fee - v_client.monthly_fee) / v_client.monthly_fee) * 100, 2);
  ELSE
    v_adjustment_pct := 0;
  END IF;

  -- Registrar hist├│rico
  INSERT INTO fee_adjustment_history (
    client_id, adjustment_date, previous_fee, new_fee,
    previous_minimum_wage, new_minimum_wage, fee_in_minimum_wages,
    adjustment_percentage, adjustment_type, notes
  ) VALUES (
    p_client_id, CURRENT_DATE, v_client.monthly_fee, v_new_fee,
    COALESCE(v_client.last_adjustment_minimum_wage, get_minimum_wage_at_date(v_client.created_at::DATE)),
    v_current_min_wage, v_client.fee_in_minimum_wages,
    v_adjustment_pct, 'minimum_wage', p_notes
  );

  -- Atualizar cliente
  UPDATE clients SET
    monthly_fee = v_new_fee,
    last_fee_adjustment_date = CURRENT_DATE,
    last_adjustment_minimum_wage = v_current_min_wage,
    updated_at = NOW()
  WHERE id = p_client_id;

  RETURN QUERY SELECT true, v_client.monthly_fee, v_new_fee, v_adjustment_pct,
    format('Reajustado de R$ %s para R$ %s (%s%%)',
      v_client.monthly_fee, v_new_fee, v_adjustment_pct)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text") IS 'Aplica o reajuste de honor├írio em um cliente espec├¡fico';



CREATE OR REPLACE FUNCTION "public"."approve_negotiation"("p_negotiation_id" "uuid", "p_approved" boolean, "p_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "message" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    v_user_id := '00000000-0000-0000-0000-000000000000'::UUID;
  END IF;

  IF p_approved THEN
    UPDATE debt_negotiations
    SET
      status = 'approved',
      approved_by = v_user_id,
      approved_at = NOW(),
      approval_notes = p_notes,
      updated_at = NOW()
    WHERE id = p_negotiation_id
      AND status = 'pending_approval';
  ELSE
    UPDATE debt_negotiations
    SET
      status = 'rejected',
      approved_by = v_user_id,
      approved_at = NOW(),
      approval_notes = p_notes,
      updated_at = NOW()
    WHERE id = p_negotiation_id
      AND status = 'pending_approval';
  END IF;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Negocia├º├úo n├úo encontrada ou j├í processada'::TEXT;
    RETURN;
  END IF;

  RETURN QUERY SELECT
    true,
    CASE WHEN p_approved THEN 'Negocia├º├úo aprovada com sucesso' ELSE 'Negocia├º├úo rejeitada' END::TEXT;
END;
$$;


ALTER FUNCTION "public"."approve_negotiation"("p_negotiation_id" "uuid", "p_approved" boolean, "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_purchase_list"("p_list_id" "uuid", "p_agent_id" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_list RECORD;
    v_total DECIMAL;
    v_threshold DECIMAL;
    v_needs_human BOOLEAN := false;
BEGIN
    -- Buscar lista
    SELECT * INTO v_list FROM purchase_lists WHERE id = p_list_id;

    IF v_list IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Lista n├úo encontrada');
    END IF;

    -- Calcular total estimado
    SELECT COALESCE(SUM(pli.estimated_price * pli.quantity), 0) INTO v_total
    FROM purchase_list_items pli
    WHERE pli.list_id = p_list_id;

    -- Verificar threshold do agente para esta p├ígina
    SELECT approval_threshold INTO v_threshold
    FROM ai_page_agents
    WHERE page_path = '/purchases';

    -- Se acima do threshold, precisa aprova├º├úo humana
    IF v_threshold IS NOT NULL AND v_total > v_threshold THEN
        v_needs_human := true;
    END IF;

    -- Atualizar lista
    UPDATE purchase_lists SET
        approval_status = CASE WHEN v_needs_human THEN 'pending_human' ELSE 'approved' END,
        approved_by_agent = p_agent_id,
        approved_at = CASE WHEN NOT v_needs_human THEN now() ELSE NULL END,
        total_estimated = v_total,
        notes = COALESCE(notes || E'\n', '') || 'Prof. Milton: ' || COALESCE(p_notes, 'Or├ºamento analisado e aprovado.')
    WHERE id = p_list_id;

    RETURN jsonb_build_object(
        'success', true,
        'approved', NOT v_needs_human,
        'needs_human_approval', v_needs_human,
        'total', v_total,
        'threshold', v_threshold,
        'agent', p_agent_id,
        'message', CASE
            WHEN v_needs_human THEN 'Valor R$ ' || v_total || ' acima do limite. Aguardando aprova├º├úo humana.'
            ELSE 'Or├ºamento aprovado por Prof. Milton. Pode prosseguir com a compra.'
        END
    );
END;
$_$;


ALTER FUNCTION "public"."approve_purchase_list"("p_list_id" "uuid", "p_agent_id" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_termination RECORD;
    v_employee RECORD;
    v_entry_id UUID;
    v_entry_number TEXT;
    v_conta_despesa_id UUID;
    v_conta_rescisao_id UUID;
BEGIN
    -- Buscar rescis├úo
    SELECT * INTO v_termination FROM employee_terminations WHERE id = p_termination_id;

    IF v_termination IS NULL THEN
        RAISE EXCEPTION 'Rescis├úo n├úo encontrada';
    END IF;

    IF v_termination.status != 'pendente' THEN
        RAISE EXCEPTION 'Rescis├úo j├í foi processada';
    END IF;

    -- Buscar funcion├írio
    SELECT * INTO v_employee FROM employees WHERE id = v_termination.employee_id;

    IF v_employee IS NULL THEN
        RAISE EXCEPTION 'Funcion├írio n├úo encontrado';
    END IF;

    -- Buscar contas cont├íbeis (ou criar se n├úo existirem)
    SELECT id INTO v_conta_despesa_id FROM chart_of_accounts
    WHERE code = '3.1.1.01' OR name ILIKE '%despesas%indeniza%' LIMIT 1;

    IF v_conta_despesa_id IS NULL THEN
        -- Usar conta gen├®rica de despesas
        SELECT id INTO v_conta_despesa_id FROM chart_of_accounts
        WHERE type = 'expense' LIMIT 1;
    END IF;

    SELECT id INTO v_conta_rescisao_id FROM chart_of_accounts
    WHERE code = '2.1.2.01' OR name ILIKE '%rescis%pagar%' LIMIT 1;

    IF v_conta_rescisao_id IS NULL THEN
        -- Usar conta gen├®rica de passivo
        SELECT id INTO v_conta_rescisao_id FROM chart_of_accounts
        WHERE type = 'liability' LIMIT 1;
    END IF;

    -- Gerar n├║mero do lan├ºamento
    v_entry_number := 'RESC-' || to_char(now(), 'YYYYMMDD') || '-' ||
                      lpad((SELECT COALESCE(COUNT(*), 0) + 1 FROM accounting_entries
                            WHERE entry_date = CURRENT_DATE)::TEXT, 4, '0');

    -- Criar lan├ºamento cont├íbil
    INSERT INTO accounting_entries (
        entry_number,
        entry_date,
        competence_date,
        description,
        entry_type,
        document_type,
        total_debit,
        total_credit,
        is_draft,
        created_by
    ) VALUES (
        v_entry_number,
        v_termination.termination_date,
        v_termination.termination_date,
        'Rescis├úo contratual - ' || v_employee.name,
        'RESCISAO',
        'TRCT',
        v_termination.valor_liquido,
        v_termination.valor_liquido,
        false,
        p_approved_by
    ) RETURNING id INTO v_entry_id;

    -- Lan├ºamento: D├®bito em Despesa, Cr├®dito em Rescis├Áes a Pagar
    -- CORRE├ç├âO: usar "description" ao inv├®s de "history"
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description) VALUES
    -- D├®bito: Despesas com Indeniza├º├Áes
    (v_entry_id, v_conta_despesa_id, v_termination.valor_liquido, 0,
     'Rescis├úo ' || v_employee.name || ' - ' || v_termination.termination_type),
    -- Cr├®dito: Rescis├Áes a Pagar
    (v_entry_id, v_conta_rescisao_id, 0, v_termination.valor_liquido,
     'Rescis├úo ' || v_employee.name || ' - ' || v_termination.termination_type);

    -- Atualizar rescis├úo
    UPDATE employee_terminations SET
        status = 'aprovada',
        accounting_entry_id = v_entry_id,
        approved_at = now(),
        approved_by = p_approved_by,
        updated_at = now()
    WHERE id = p_termination_id;

    -- Marcar funcion├írio como inativo
    UPDATE employees SET
        is_active = false,
        termination_date = v_termination.termination_date,
        updated_at = now()
    WHERE id = v_termination.employee_id;

    RETURN v_entry_id;
END;
$$;


ALTER FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") IS 'Aprova rescis├úo de funcion├írio e cria lan├ºamento cont├íbil';



CREATE OR REPLACE FUNCTION "public"."audit_invoice_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    INSERT INTO invoice_status_audit (
      invoice_id,
      old_status,
      new_status,
      changed_by,
      change_reason,
      automatic
    ) VALUES (
      NEW.id,
      OLD.status,
      NEW.status,
      NEW.updated_by,
      'Status changed from ' || OLD.status || ' to ' || NEW.status,
      (NEW.updated_by IS NULL) -- Se n├úo tem updated_by, foi autom├ítico
    );
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."audit_invoice_status_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_classify_pro_bono"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Se honor├írio for 0 ou NULL, tornar Pro-Bono
  IF (NEW.monthly_fee IS NULL OR NEW.monthly_fee = 0) THEN
    NEW.is_pro_bono := true;

    -- Se n├úo tinha data de in├¡cio do Pro-Bono, definir como hoje
    IF NEW.pro_bono_start_date IS NULL THEN
      NEW.pro_bono_start_date := CURRENT_DATE;
    END IF;

    -- Se n├úo tinha justificativa, adicionar uma padr├úo
    IF NEW.pro_bono_reason IS NULL OR NEW.pro_bono_reason = '' THEN
      NEW.pro_bono_reason := 'Classificado automaticamente: honor├írio zerado';
    END IF;

  -- Se tinha honor├írio 0 e agora tem valor > 0, remover Pro-Bono
  ELSIF NEW.monthly_fee > 0 AND COALESCE(OLD.is_pro_bono, false) = true THEN
    NEW.is_pro_bono := false;

    -- Definir data de fim do Pro-Bono como a data da convers├úo
    IF OLD.pro_bono_start_date IS NOT NULL AND NEW.pro_bono_end_date IS NULL THEN
      NEW.pro_bono_end_date := CURRENT_DATE;
    END IF;

    -- Limpar campos de Pro-Bono (manter hist├│rico na pro_bono_end_date)
    -- NEW.pro_bono_start_date := NULL; -- Manter para hist├│rico
    -- NEW.pro_bono_reason := NULL; -- Manter para hist├│rico
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_classify_pro_bono"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_classify_pro_bono"() IS 'Classifica automaticamente clientes como Pro-Bono quando honor├írio = 0 e remove Pro-Bono quando honor├írio > 0';



CREATE OR REPLACE FUNCTION "public"."auto_generate_payroll"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- CORRE├ç├âO: usar UPPER() para compara├º├úo case-insensitive
    IF UPPER(NEW.contract_type) = 'CLT' AND NEW.is_active THEN
        PERFORM gerar_folha_funcionario(NEW.id, date_trunc('month', CURRENT_DATE)::date);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_generate_payroll"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_reconcile_expense_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_transaction_id UUID;
  v_match_found BOOLEAN := false;
BEGIN
  -- S├│ executa quando despesa muda para status 'paid'
  IF NEW.status = 'paid' AND (OLD.status IS NULL OR OLD.status != 'paid') THEN

    -- Buscar transa├º├úo banc├íria correspondente
    -- Crit├®rios: mesmo valor, tipo d├®bito, data pr├│xima (┬▒7 dias)
    SELECT bt.id INTO v_transaction_id
    FROM bank_transactions bt
    WHERE bt.transaction_type = 'debit'
      AND ABS(bt.amount) = NEW.amount
      AND bt.matched = false
      AND bt.transaction_date >= COALESCE(NEW.payment_date, NEW.due_date) - INTERVAL '7 days'
      AND bt.transaction_date <= COALESCE(NEW.payment_date, NEW.due_date) + INTERVAL '7 days'
    ORDER BY ABS(bt.transaction_date - COALESCE(NEW.payment_date, NEW.due_date))
    LIMIT 1;

    IF v_transaction_id IS NOT NULL THEN
      -- Marcar transa├º├úo como conciliada
      UPDATE bank_transactions
      SET matched = true,
          ai_suggestion = 'Dr. C├¡cero: Conciliado automaticamente com despesa paga #' || NEW.id::TEXT
      WHERE id = v_transaction_id;

      -- Criar registro de match
      INSERT INTO bank_transaction_matches (
        bank_transaction_id,
        expense_id,
        amount,
        description,
        confidence,
        created_by
      ) VALUES (
        v_transaction_id,
        NEW.id,
        NEW.amount,
        'Dr. C├¡cero: Concilia├º├úo autom├ítica - Despesa paga',
        0.95,
        COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID)
      );

      v_match_found := true;

      RAISE NOTICE 'Dr. C├¡cero: Despesa % conciliada automaticamente com transa├º├úo %', NEW.id, v_transaction_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_reconcile_expense_payment"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_reconcile_expense_payment"() IS 'Dr. C├¡cero: Concilia automaticamente despesas pagas com transa├º├Áes banc├írias';



CREATE OR REPLACE FUNCTION "public"."auto_reconcile_invoice_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_transaction_id UUID;
BEGIN
  -- S├│ executa quando fatura muda para status 'paid'
  IF NEW.status = 'paid' AND (OLD.status IS NULL OR OLD.status != 'paid') THEN

    -- Buscar transa├º├úo banc├íria correspondente
    SELECT bt.id INTO v_transaction_id
    FROM bank_transactions bt
    WHERE bt.transaction_type = 'credit'
      AND ABS(bt.amount) = NEW.amount
      AND bt.matched = false
      AND bt.transaction_date >= NEW.due_date - INTERVAL '7 days'
      AND bt.transaction_date <= NEW.due_date + INTERVAL '7 days'
    ORDER BY ABS(bt.transaction_date - NEW.due_date)
    LIMIT 1;

    IF v_transaction_id IS NOT NULL THEN
      -- Marcar transa├º├úo como conciliada
      UPDATE bank_transactions
      SET matched = true,
          ai_suggestion = 'Dr. C├¡cero: Conciliado automaticamente com fatura paga #' || NEW.id::TEXT
      WHERE id = v_transaction_id;

      -- Criar registro de match
      INSERT INTO bank_transaction_matches (
        bank_transaction_id,
        invoice_id,
        client_id,
        amount,
        description,
        confidence,
        created_by
      ) VALUES (
        v_transaction_id,
        NEW.id,
        NEW.client_id,
        NEW.amount,
        'Dr. C├¡cero: Concilia├º├úo autom├ítica - Fatura paga',
        0.95,
        COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID)
      );

      RAISE NOTICE 'Dr. C├¡cero: Fatura % conciliada automaticamente com transa├º├úo %', NEW.id, v_transaction_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_reconcile_invoice_payment"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_reconcile_invoice_payment"() IS 'Dr. C├¡cero: Concilia automaticamente faturas pagas com transa├º├Áes banc├írias';



CREATE OR REPLACE FUNCTION "public"."auto_reconcile_new_transaction"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_expense_id UUID;
  v_match_found BOOLEAN := false;
BEGIN
  -- S├│ executa para transa├º├Áes novas de d├®bito n├úo conciliadas
  IF NEW.transaction_type = 'debit' AND NEW.matched = false THEN

    -- Buscar despesa correspondente
    -- Crit├®rios: mesmo valor, status paid, data pr├│xima (┬▒7 dias)
    SELECT e.id INTO v_expense_id
    FROM expenses e
    WHERE e.amount = ABS(NEW.amount)
      AND e.status = 'paid'
      AND COALESCE(e.payment_date, e.due_date) >= NEW.transaction_date - INTERVAL '7 days'
      AND COALESCE(e.payment_date, e.due_date) <= NEW.transaction_date + INTERVAL '7 days'
      AND NOT EXISTS (
        SELECT 1 FROM bank_transaction_matches btm
        WHERE btm.expense_id = e.id
      )
    ORDER BY ABS(COALESCE(e.payment_date, e.due_date) - NEW.transaction_date)
    LIMIT 1;

    IF v_expense_id IS NOT NULL THEN
      -- Marcar transa├º├úo como conciliada
      NEW.matched := true;
      NEW.ai_suggestion := 'Dr. C├¡cero: Conciliado automaticamente com despesa existente #' || v_expense_id::TEXT;

      -- Criar registro de match
      INSERT INTO bank_transaction_matches (
        bank_transaction_id,
        expense_id,
        amount,
        description,
        confidence,
        created_by
      ) VALUES (
        NEW.id,
        v_expense_id,
        ABS(NEW.amount),
        'Dr. C├¡cero: Concilia├º├úo autom├ítica - Transa├º├úo importada',
        0.95,
        COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID)
      );

      v_match_found := true;

      RAISE NOTICE 'Dr. C├¡cero: Transa├º├úo % conciliada automaticamente com despesa %', NEW.id, v_expense_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_reconcile_new_transaction"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_reconcile_new_transaction"() IS 'Dr. C├¡cero: Concilia automaticamente novas transa├º├Áes com despesas existentes';



CREATE OR REPLACE FUNCTION "public"."bank_imports_set_statement_key"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    IF NEW.statement_key IS NULL THEN
        NEW.statement_key := public.generate_statement_key(NEW.bank_account_id, COALESCE(NEW.period_start, NEW.start_date), COALESCE(NEW.period_end, NEW.end_date), NEW.opening_balance, NEW.closing_balance);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."bank_imports_set_statement_key"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean DEFAULT true, "p_dry_run" boolean DEFAULT true) RETURNS TABLE("client_id" "uuid", "client_name" "text", "previous_fee" numeric, "new_fee" numeric, "adjustment_percentage" numeric, "status" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client RECORD;
  v_result RECORD;
  v_current_min_wage NUMERIC;
BEGIN
  v_current_min_wage := get_minimum_wage_at_date();

  FOR v_client IN
    SELECT c.id, c.name, c.monthly_fee, c.fee_in_minimum_wages,
           c.last_adjustment_minimum_wage, c.auto_adjust_by_minimum_wage
    FROM clients c
    WHERE c.is_active = true
      AND NOT COALESCE(c.is_pro_bono, false)
      AND NOT COALESCE(c.is_barter, false)
      AND c.monthly_fee > 0
      AND COALESCE(c.auto_adjust_by_minimum_wage, true)
      AND (NOT p_only_pending OR COALESCE(c.last_adjustment_minimum_wage, 0) < v_current_min_wage)
  LOOP
    -- Verificar se tem fee_in_minimum_wages
    IF v_client.fee_in_minimum_wages IS NULL OR v_client.fee_in_minimum_wages = 0 THEN
      client_id := v_client.id;
      client_name := v_client.name;
      previous_fee := v_client.monthly_fee;
      new_fee := v_client.monthly_fee;
      adjustment_percentage := 0;
      status := 'IGNORADO: Sem fee_in_minimum_wages definido';
      RETURN NEXT;
      CONTINUE;
    END IF;

    -- Calcular novo valor
    new_fee := calculate_adjusted_fee(v_client.fee_in_minimum_wages);
    adjustment_percentage := ROUND(((new_fee - v_client.monthly_fee) / v_client.monthly_fee) * 100, 2);

    client_id := v_client.id;
    client_name := v_client.name;
    previous_fee := v_client.monthly_fee;

    IF NOT p_dry_run THEN
      -- Aplicar reajuste
      SELECT * INTO v_result FROM apply_fee_adjustment(v_client.id);
      status := 'APLICADO';
    ELSE
      status := 'SIMULADO';
    END IF;

    RETURN NEXT;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean, "p_dry_run" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean, "p_dry_run" boolean) IS 'Aplica reajustes em lote para todos os clientes pendentes';



CREATE OR REPLACE FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean DEFAULT true, "p_dry_run" boolean DEFAULT false) RETURNS TABLE("client_id" "uuid", "client_name" "text", "invoices_generated" integer, "total_amount" numeric, "status" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client RECORD;
  v_count INTEGER;
  v_total NUMERIC;
BEGIN
  FOR v_client IN
    SELECT c.id, c.name, c.monthly_fee
    FROM clients c
    WHERE c.is_active = true
      AND NOT COALESCE(c.is_pro_bono, false)
      AND NOT COALESCE(c.is_barter, false)
      AND c.monthly_fee > 0
  LOOP
    BEGIN
      -- Contar faturas geradas
      SELECT COUNT(*), COALESCE(SUM(amount), 0)
      INTO v_count, v_total
      FROM generate_annual_invoices(v_client.id, p_year, p_include_13th, p_dry_run);

      client_id := v_client.id;
      client_name := v_client.name;
      invoices_generated := v_count;
      total_amount := v_total;
      status := CASE WHEN p_dry_run THEN 'SIMULADO' ELSE 'GERADO' END;
      RETURN NEXT;
    EXCEPTION WHEN OTHERS THEN
      client_id := v_client.id;
      client_name := v_client.name;
      invoices_generated := 0;
      total_amount := 0;
      status := 'ERRO: ' || SQLERRM;
      RETURN NEXT;
    END;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) IS 'Gera faturas anuais para todos os clientes ativos';



CREATE OR REPLACE FUNCTION "public"."buscar_clientes_inadimplentes"("p_tenant_id" integer DEFAULT NULL::integer) RETURNS TABLE("client_id" "uuid", "client_name" "text", "valor_em_aberto" numeric, "qtd_boletos" bigint, "dias_atraso" integer, "custo_manutencao" "text", "prioridade" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as client_id,
    c.name as client_name,
    COALESCE(SUM(i.amount), 0) as valor_em_aberto,
    COUNT(i.id) as qtd_boletos,
    MAX(DATE_PART('day', CURRENT_DATE - i.due_date)::integer) as dias_atraso,
    'R$ 48,48/m├¬s'::text as custo_manutencao,
    CASE 
        WHEN MAX(DATE_PART('day', CURRENT_DATE - i.due_date)) > 90 THEN 'CR├ìTICO'
        WHEN MAX(DATE_PART('day', CURRENT_DATE - i.due_date)) > 30 THEN 'ALTO RISCO'
        ELSE 'M├ëDIO'
    END::text as prioridade
  FROM invoices i
  JOIN clients c ON c.id = i.client_id
  WHERE i.status = 'overdue'
  AND i.tenant_id = public.get_my_tenant_id() -- Seguran├ºa Ativa
  GROUP BY c.id, c.name
  ORDER BY valor_em_aberto DESC;
END;
$_$;


ALTER FUNCTION "public"."buscar_clientes_inadimplentes"("p_tenant_id" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text" DEFAULT NULL::"text") RETURNS TABLE("categoria_codigo" "text", "categoria_nome" "text", "total" numeric, "quantidade" bigint, "percentual" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_total_geral NUMERIC;
BEGIN
  -- Calcular total geral
  SELECT COALESCE(SUM(ael.debit), 0) INTO v_total_geral
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE ae.entry_date BETWEEN p_data_inicio AND p_data_fim
    AND coa.code LIKE '4.%'
    AND ael.debit > 0;
  
  -- Retornar por categoria
  RETURN QUERY
  SELECT 
    LEFT(coa.code, 5) as categoria_codigo,
    coa.name as categoria_nome,
    SUM(ael.debit) as total,
    COUNT(*) as quantidade,
    CASE WHEN v_total_geral > 0 
      THEN ROUND((SUM(ael.debit) / v_total_geral * 100)::NUMERIC, 2) 
      ELSE 0 
    END as percentual
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE ae.entry_date BETWEEN p_data_inicio AND p_data_fim
    AND coa.code LIKE '4.%'
    AND ael.debit > 0
    AND (p_categoria IS NULL OR coa.code LIKE p_categoria || '%')
  GROUP BY LEFT(coa.code, 5), coa.name
  ORDER BY SUM(ael.debit) DESC;
END;
$$;


ALTER FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text") IS 'Retorna despesas agrupadas por categoria';



CREATE OR REPLACE FUNCTION "public"."buscar_despesas_periodo"("p_inicio" "date", "p_fim" "date") RETURNS TABLE("codigo" "text", "nome" "text", "valor" numeric, "quantidade" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    coa.code as codigo,
    coa.name as nome,
    COALESCE(SUM(ael.debit), 0) as valor,
    COUNT(*) as quantidade
  FROM chart_of_accounts coa
  LEFT JOIN accounting_entry_lines ael ON ael.account_id = coa.id
  LEFT JOIN accounting_entries ae ON ae.id = ael.entry_id
  WHERE coa.code LIKE '4.%'
    AND ae.entry_date BETWEEN p_inicio AND p_fim
    AND ael.debit > 0
  GROUP BY coa.code, coa.name
  HAVING COALESCE(SUM(ael.debit), 0) > 0
  ORDER BY SUM(ael.debit) DESC;
END;
$$;


ALTER FUNCTION "public"."buscar_despesas_periodo"("p_inicio" "date", "p_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid" DEFAULT NULL::"uuid", "p_cliente_nome" "text" DEFAULT NULL::"text", "p_limite" integer DEFAULT 12) RETURNS TABLE("cliente_id" "uuid", "cliente_nome" "text", "cnpj" "text", "status" "text", "saldo_devedor" numeric, "competencia" "text", "valor_pago" numeric, "data_pagamento" "date", "forma_pagamento" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_cliente_id UUID;
  v_cliente_nome TEXT;
  v_cnpj TEXT;
  v_saldo NUMERIC;
  v_conta_id UUID;
BEGIN
  -- Buscar cliente
  IF p_cliente_id IS NOT NULL THEN
    SELECT id, name, cnpj INTO v_cliente_id, v_cliente_nome, v_cnpj
    FROM clients WHERE id = p_cliente_id;
  ELSIF p_cliente_nome IS NOT NULL THEN
    SELECT id, name, cnpj INTO v_cliente_id, v_cliente_nome, v_cnpj
    FROM clients WHERE name ILIKE '%' || p_cliente_nome || '%'
    LIMIT 1;
  END IF;
  
  IF v_cliente_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Buscar conta anal├¡tica
  SELECT id INTO v_conta_id
  FROM chart_of_accounts
  WHERE name ILIKE '%' || v_cliente_nome || '%'
    AND code LIKE '1.1.2.01.%'
  LIMIT 1;
  
  -- Calcular saldo devedor
  SELECT COALESCE(SUM(debit), 0) - COALESCE(SUM(credit), 0) INTO v_saldo
  FROM accounting_entry_lines
  WHERE account_id = v_conta_id;
  
  -- Retornar hist├│rico
  RETURN QUERY
  SELECT 
    v_cliente_id as cliente_id,
    v_cliente_nome as cliente_nome,
    v_cnpj as cnpj,
    CASE WHEN v_saldo <= 0.01 THEN 'Em dia' ELSE 'Devendo' END as status,
    GREATEST(0, v_saldo) as saldo_devedor,
    to_char(ae.entry_date, 'Mon/YYYY') as competencia,
    ael.credit as valor_pago,
    ae.entry_date as data_pagamento,
    CASE 
      WHEN ae.description ILIKE '%PIX%' THEN 'PIX'
      WHEN ae.description ILIKE '%COB%' OR ae.description ILIKE '%BOLETO%' THEN 'Boleto'
      WHEN ae.description ILIKE '%TED%' THEN 'TED'
      ELSE 'Outro'
    END as forma_pagamento
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  WHERE ael.account_id = v_conta_id
    AND ael.credit > 0
  ORDER BY ae.entry_date DESC
  LIMIT p_limite;
END;
$$;


ALTER FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid", "p_cliente_nome" "text", "p_limite" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid", "p_cliente_nome" "text", "p_limite" integer) IS 'Retorna hist├│rico de pagamentos de um cliente espec├¡fico';



CREATE OR REPLACE FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") RETURNS TABLE("cliente_id" "uuid", "cliente_nome" "text", "valor" numeric, "data" "date", "quantidade" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as cliente_id,
    c.name as cliente_nome,
    SUM(ael.credit) as valor,
    ae.entry_date as data,
    COUNT(*) as quantidade
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  LEFT JOIN clients c ON c.id = (ae.metadata->>'client_id')::uuid
  WHERE ae.entry_date BETWEEN p_data_inicio AND p_data_fim
    AND (ae.description ILIKE '%PIX%' OR ae.metadata->>'forma_pagamento' = 'PIX')
    AND ael.credit > 0
    AND coa.code LIKE '1.1.2.01.%'
  GROUP BY c.id, c.name, ae.entry_date
  ORDER BY SUM(ael.credit) DESC;
END;
$$;


ALTER FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") IS 'Busca recebimentos via PIX no per├¡odo, agrupados por cliente';



CREATE OR REPLACE FUNCTION "public"."buscar_receita_por_cliente"("p_inicio" "date", "p_fim" "date") RETURNS TABLE("cliente_id" "uuid", "cliente_nome" "text", "receita" numeric, "quantidade" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id as cliente_id,
    c.name as cliente_nome,
    COALESCE(SUM(i.paid_amount), 0) as receita,
    COUNT(*) as quantidade
  FROM clients c
  LEFT JOIN invoices i ON i.client_id = c.id
  WHERE i.status = 'paid'
    AND i.paid_at BETWEEN p_inicio AND p_fim
  GROUP BY c.id, c.name
  HAVING COALESCE(SUM(i.paid_amount), 0) > 0
  ORDER BY SUM(i.paid_amount) DESC;
END;
$$;


ALTER FUNCTION "public"."buscar_receita_por_cliente"("p_inicio" "date", "p_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buscar_receitas_periodo"("p_inicio" "date", "p_fim" "date") RETURNS TABLE("codigo" "text", "nome" "text", "valor" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    coa.code as codigo,
    coa.name as nome,
    COALESCE(SUM(ael.credit), 0) as valor
  FROM chart_of_accounts coa
  LEFT JOIN accounting_entry_lines ael ON ael.account_id = coa.id
  LEFT JOIN accounting_entries ae ON ae.id = ael.entry_id
  WHERE coa.code LIKE '3.%'
    AND (ae.entry_date IS NULL OR ae.entry_date BETWEEN p_inicio AND p_fim)
    AND ael.credit > 0
  GROUP BY coa.code, coa.name
  HAVING COALESCE(SUM(ael.credit), 0) > 0
  ORDER BY coa.code;
END;
$$;


ALTER FUNCTION "public"."buscar_receitas_periodo"("p_inicio" "date", "p_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."buscar_saldos_bancos"() RETURNS TABLE("banco_codigo" "text", "banco_nome" "text", "saldo" numeric, "ultima_movimentacao" "date")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    coa.code as banco_codigo,
    coa.name as banco_nome,
    COALESCE(SUM(ael.debit), 0) - COALESCE(SUM(ael.credit), 0) as saldo,
    MAX(ae.entry_date) as ultima_movimentacao
  FROM chart_of_accounts coa
  LEFT JOIN accounting_entry_lines ael ON ael.account_id = coa.id
  LEFT JOIN accounting_entries ae ON ae.id = ael.entry_id
  WHERE coa.code LIKE '1.1.1.%'
    AND coa.is_analytical = true
  GROUP BY coa.code, coa.name
  ORDER BY coa.code;
END;
$$;


ALTER FUNCTION "public"."buscar_saldos_bancos"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."buscar_saldos_bancos"() IS 'Retorna saldo atual de cada conta banc├íria';



CREATE OR REPLACE FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer DEFAULT 10) RETURNS TABLE("cliente_id" "uuid", "cliente_nome" "text", "total_pago" numeric, "quantidade_pagamentos" bigint, "ticket_medio" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as cliente_id,
    c.name as cliente_nome,
    SUM(ael.credit) as total_pago,
    COUNT(*) as quantidade_pagamentos,
    ROUND((SUM(ael.credit) / COUNT(*))::NUMERIC, 2) as ticket_medio
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  JOIN clients c ON coa.name ILIKE '%' || c.name || '%'
  WHERE ae.entry_date BETWEEN p_data_inicio AND p_data_fim
    AND coa.code LIKE '1.1.2.01.%'
    AND ael.credit > 0
  GROUP BY c.id, c.name
  ORDER BY SUM(ael.credit) DESC
  LIMIT p_limite;
END;
$$;


ALTER FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer) IS 'Retorna os clientes que mais pagaram no per├¡odo';



CREATE OR REPLACE FUNCTION "public"."buscar_total_despesas"("p_inicio" "date", "p_fim" "date") RETURNS TABLE("total" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT COALESCE(SUM(ael.debit), 0) as total
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '4.%'
    AND ae.entry_date BETWEEN p_inicio AND p_fim
    AND ael.debit > 0;
END;
$$;


ALTER FUNCTION "public"."buscar_total_despesas"("p_inicio" "date", "p_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calcular_inss"("p_base_calculo" numeric) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_inss DECIMAL := 0;
    v_base_restante DECIMAL := p_base_calculo;
    v_faixa RECORD;
    v_valor_faixa DECIMAL;
BEGIN
    -- INSS progressivo por faixas
    FOR v_faixa IN
        SELECT * FROM tabela_inss
        WHERE is_active AND vigencia_fim IS NULL
        ORDER BY faixa
    LOOP
        IF v_base_restante <= 0 THEN
            EXIT;
        END IF;

        IF p_base_calculo > v_faixa.valor_inicial THEN
            v_valor_faixa := LEAST(p_base_calculo, v_faixa.valor_final) - v_faixa.valor_inicial;
            IF v_faixa.faixa = 1 THEN
                v_valor_faixa := LEAST(p_base_calculo, v_faixa.valor_final);
            END IF;
            v_inss := v_inss + (v_valor_faixa * v_faixa.aliquota / 100);
        END IF;
    END LOOP;

    -- Aplicar teto
    RETURN LEAST(v_inss, (SELECT valor FROM parametros_folha WHERE parametro = 'teto_inss') * 0.14);
END;
$$;


ALTER FUNCTION "public"."calcular_inss"("p_base_calculo" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calcular_irrf"("p_base_calculo" numeric, "p_dependentes" integer DEFAULT 0) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_base_irrf DECIMAL;
    v_deducao_dep DECIMAL;
    v_faixa RECORD;
    v_irrf DECIMAL := 0;
BEGIN
    -- Obter dedu├º├úo por dependente
    SELECT valor INTO v_deducao_dep
    FROM parametros_folha
    WHERE parametro = 'deducao_dependente_irrf';

    -- Calcular base IRRF
    v_base_irrf := p_base_calculo - (p_dependentes * v_deducao_dep);

    -- Encontrar faixa
    SELECT * INTO v_faixa
    FROM tabela_irrf
    WHERE is_active AND vigencia_fim IS NULL
      AND v_base_irrf BETWEEN valor_inicial AND valor_final
    LIMIT 1;

    IF v_faixa IS NOT NULL THEN
        v_irrf := (v_base_irrf * v_faixa.aliquota / 100) - v_faixa.parcela_deduzir;
    END IF;

    RETURN GREATEST(v_irrf, 0);
END;
$$;


ALTER FUNCTION "public"."calcular_irrf"("p_base_calculo" numeric, "p_dependentes" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calcular_prescricao"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Prescri├º├úo: 5 anos a partir do 1┬║ dia do ano seguinte ao fato gerador
  IF NEW.data_emissao IS NOT NULL THEN
    NEW.data_prescricao := DATE_TRUNC('year', NEW.data_emissao) + INTERVAL '6 years';
  END IF;
  
  -- Calcular urg├¬ncia
  IF NEW.data_prescricao IS NOT NULL THEN
    IF NEW.data_prescricao <= CURRENT_DATE THEN
      NEW.urgencia := 'PRESCRITO';
      IF NEW.status = 'PENDENTE' THEN
        NEW.status := 'PRESCRITA';
      END IF;
    ELSIF NEW.data_prescricao <= CURRENT_DATE + INTERVAL '90 days' THEN
      NEW.urgencia := 'CRITICO';
    ELSIF NEW.data_prescricao <= CURRENT_DATE + INTERVAL '180 days' THEN
      NEW.urgencia := 'ALTO';
    ELSIF NEW.data_prescricao <= CURRENT_DATE + INTERVAL '365 days' THEN
      NEW.urgencia := 'MEDIO';
    ELSE
      NEW.urgencia := 'BAIXO';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calcular_prescricao"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text" DEFAULT 'indenizado'::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_termination_id UUID;
    v_employee RECORD;
    v_salary DECIMAL;
    v_hire_date DATE;
    v_months_worked INTEGER;
    v_years_worked INTEGER;
    v_notice_days INTEGER;
    v_vacation_days INTEGER;
    v_thirteenth_months INTEGER;

    -- Proventos
    v_saldo_salario DECIMAL := 0;
    v_aviso_previo DECIMAL := 0;
    v_ferias_vencidas DECIMAL := 0;
    v_ferias_proporcionais DECIMAL := 0;
    v_terco_ferias DECIMAL := 0;
    v_decimo_terceiro DECIMAL := 0;
    v_multa_fgts DECIMAL := 0;
    v_saldo_fgts DECIMAL := 0;

    -- Descontos
    v_desconto_aviso DECIMAL := 0;
    v_desconto_inss DECIMAL := 0;
    v_desconto_irrf DECIMAL := 0;

    -- Totais
    v_total_proventos DECIMAL := 0;
    v_total_descontos DECIMAL := 0;
    v_valor_liquido DECIMAL := 0;

    -- Dr. Advocato
    v_advocato_consultation TEXT;
    v_advocato_warnings TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- Buscar dados do funcion├írio
    SELECT * INTO v_employee FROM employees WHERE id = p_employee_id;

    IF v_employee IS NULL THEN
        RAISE EXCEPTION 'Funcion├írio n├úo encontrado';
    END IF;

    -- Dados b├ísicos
    v_salary := COALESCE(v_employee.official_salary, 0);
    v_hire_date := v_employee.hire_date;

    -- Calcular tempo trabalhado
    v_months_worked := EXTRACT(YEAR FROM age(p_termination_date, v_hire_date)) * 12 +
                       EXTRACT(MONTH FROM age(p_termination_date, v_hire_date));
    v_years_worked := v_months_worked / 12;

    -- Dias de aviso pr├®vio (30 + 3 por ano, m├íximo 90)
    v_notice_days := LEAST(30 + (v_years_worked * 3), 90);

    -- Saldo de f├®rias e 13┬║
    v_vacation_days := COALESCE(v_employee.vacation_days_accrued, 0);
    v_thirteenth_months := EXTRACT(MONTH FROM p_termination_date)::INTEGER;

    -- ========== C├üLCULOS POR TIPO DE RESCIS├âO ==========

    -- 1. SALDO DE SAL├üRIO (sempre devido)
    v_saldo_salario := (v_salary / 30) * EXTRACT(DAY FROM p_last_working_day);

    -- 2. AVISO PR├ëVIO
    IF p_termination_type IN ('dispensa_sem_justa_causa', 'rescisao_indireta') THEN
        IF p_notice_type = 'indenizado' THEN
            v_aviso_previo := (v_salary / 30) * v_notice_days;
            v_advocato_warnings := array_append(v_advocato_warnings,
                'Aviso pr├®vio indenizado de ' || v_notice_days || ' dias ser├í pago');
        END IF;
    ELSIF p_termination_type = 'pedido_demissao' THEN
        IF p_notice_type = 'nao_cumprido' THEN
            v_desconto_aviso := v_salary; -- Desconta 30 dias
            v_advocato_warnings := array_append(v_advocato_warnings,
                'Funcion├írio n├úo cumpriu aviso - ser├í descontado');
        END IF;
    ELSIF p_termination_type = 'acordo_mutuo' THEN
        v_aviso_previo := (v_salary / 30) * v_notice_days * 0.5; -- 50% do aviso
        v_advocato_warnings := array_append(v_advocato_warnings,
            'Acordo m├║tuo: aviso pr├®vio de 50% = R$ ' || v_aviso_previo::TEXT);
    END IF;

    -- 3. F├ëRIAS
    IF p_termination_type != 'dispensa_com_justa_causa' THEN
        -- F├®rias vencidas (se houver)
        IF v_vacation_days >= 30 THEN
            v_ferias_vencidas := v_salary * (v_vacation_days / 30);
        END IF;

        -- F├®rias proporcionais (meses no per├¡odo aquisitivo atual)
        v_ferias_proporcionais := (v_salary / 12) * (v_months_worked % 12);

        -- 1/3 constitucional
        v_terco_ferias := (v_ferias_vencidas + v_ferias_proporcionais) / 3;
    ELSE
        v_advocato_warnings := array_append(v_advocato_warnings,
            'JUSTA CAUSA: Funcion├írio perde f├®rias proporcionais');
    END IF;

    -- 4. 13┬║ SAL├üRIO
    IF p_termination_type != 'dispensa_com_justa_causa' THEN
        v_decimo_terceiro := (v_salary / 12) * v_thirteenth_months;
    ELSE
        v_advocato_warnings := array_append(v_advocato_warnings,
            'JUSTA CAUSA: Funcion├írio perde 13┬║ proporcional');
    END IF;

    -- 5. FGTS E MULTA
    IF p_termination_type = 'dispensa_sem_justa_causa' OR p_termination_type = 'rescisao_indireta' THEN
        v_saldo_fgts := COALESCE(v_employee.fgts_balance, v_salary * 0.08 * v_months_worked);
        v_multa_fgts := v_saldo_fgts * 0.40; -- 40%
        v_advocato_warnings := array_append(v_advocato_warnings,
            'Multa 40% FGTS: R$ ' || v_multa_fgts::TEXT || ' - funcion├írio pode sacar');
    ELSIF p_termination_type = 'acordo_mutuo' THEN
        v_saldo_fgts := COALESCE(v_employee.fgts_balance, v_salary * 0.08 * v_months_worked);
        v_multa_fgts := v_saldo_fgts * 0.20; -- 20% no acordo
        v_advocato_warnings := array_append(v_advocato_warnings,
            'Acordo: Multa 20% FGTS + saque de 80% do saldo');
    ELSIF p_termination_type = 'pedido_demissao' THEN
        v_advocato_warnings := array_append(v_advocato_warnings,
            'Pedido de demiss├úo: sem multa FGTS, saldo fica retido');
    ELSIF p_termination_type = 'dispensa_com_justa_causa' THEN
        v_advocato_warnings := array_append(v_advocato_warnings,
            'JUSTA CAUSA: sem multa FGTS, saldo fica retido');
    END IF;

    -- 6. DESCONTOS (INSS e IRRF)
    v_desconto_inss := calcular_inss(v_saldo_salario + v_decimo_terceiro);
    v_desconto_irrf := calcular_irrf(
        v_saldo_salario + v_decimo_terceiro - v_desconto_inss,
        0  -- N├║mero de dependentes (n├úo temos essa informa├º├úo na tabela atual)
    );

    -- ========== TOTAIS ==========
    v_total_proventos := v_saldo_salario + v_aviso_previo + v_ferias_vencidas +
                         v_ferias_proporcionais + v_terco_ferias + v_decimo_terceiro + v_multa_fgts;

    v_total_descontos := v_desconto_aviso + v_desconto_inss + v_desconto_irrf;

    v_valor_liquido := v_total_proventos - v_total_descontos;

    -- ========== CONSULTA DR. ADVOCATO ==========
    v_advocato_consultation := 'Dr. Advocato analisou a rescis├úo de ' || v_employee.name || E':\n\n';
    v_advocato_consultation := v_advocato_consultation ||
        'TIPO: ' || CASE p_termination_type
            WHEN 'dispensa_sem_justa_causa' THEN 'Dispensa sem justa causa'
            WHEN 'dispensa_com_justa_causa' THEN 'Dispensa com justa causa'
            WHEN 'pedido_demissao' THEN 'Pedido de demiss├úo'
            WHEN 'acordo_mutuo' THEN 'Acordo m├║tuo (Art. 484-A CLT)'
            WHEN 'termino_contrato' THEN 'T├®rmino de contrato'
            WHEN 'aposentadoria' THEN 'Aposentadoria'
            WHEN 'falecimento' THEN 'Falecimento'
            WHEN 'rescisao_indireta' THEN 'Rescis├úo indireta'
        END || E'\n';

    v_advocato_consultation := v_advocato_consultation ||
        'TEMPO DE SERVI├çO: ' || v_years_worked || ' anos e ' || (v_months_worked % 12) || E' meses\n';
    v_advocato_consultation := v_advocato_consultation ||
        'PRAZO PAGAMENTO: ' || CASE
            WHEN p_notice_type = 'trabalhado' THEN '1┬║ dia ├║til ap├│s t├®rmino do aviso'
            ELSE '10 dias corridos ap├│s a data da rescis├úo'
        END || E'\n\n';

    v_advocato_consultation := v_advocato_consultation ||
        'VERBAS DEVIDAS: Saldo sal├írio, ';

    IF v_aviso_previo > 0 THEN
        v_advocato_consultation := v_advocato_consultation || 'aviso pr├®vio, ';
    END IF;
    IF v_ferias_vencidas > 0 OR v_ferias_proporcionais > 0 THEN
        v_advocato_consultation := v_advocato_consultation || 'f├®rias + 1/3, ';
    END IF;
    IF v_decimo_terceiro > 0 THEN
        v_advocato_consultation := v_advocato_consultation || '13┬║ proporcional, ';
    END IF;
    IF v_multa_fgts > 0 THEN
        v_advocato_consultation := v_advocato_consultation || 'multa FGTS';
    END IF;

    v_advocato_consultation := v_advocato_consultation || E'\n\n';
    v_advocato_consultation := v_advocato_consultation ||
        'DOCUMENTOS NECESS├üRIOS: TRCT, Guia FGTS (GRRF), Comunicado de dispensa (se aplic├ível), Exame demissional';

    -- ========== INSERIR RESCIS├âO ==========
    INSERT INTO employee_terminations (
        employee_id,
        termination_date,
        last_working_day,
        termination_type,
        termination_reason,
        notice_type,
        notice_days,
        salary_at_termination,
        months_worked,
        years_worked,
        vacation_days_balance,
        thirteenth_months_due,
        saldo_salario,
        aviso_previo,
        ferias_vencidas,
        ferias_proporcionais,
        terco_constitucional,
        decimo_terceiro_proporcional,
        multa_fgts,
        saldo_fgts,
        desconto_aviso,
        desconto_inss,
        desconto_irrf,
        total_proventos,
        total_descontos,
        valor_liquido,
        status,
        advocato_consultation,
        advocato_warnings,
        calculated_at
    ) VALUES (
        p_employee_id,
        p_termination_date,
        p_last_working_day,
        p_termination_type,
        p_termination_type,
        p_notice_type,
        v_notice_days,
        v_salary,
        v_months_worked,
        v_years_worked,
        v_vacation_days,
        v_thirteenth_months,
        v_saldo_salario,
        v_aviso_previo,
        v_ferias_vencidas,
        v_ferias_proporcionais,
        v_terco_ferias,
        v_decimo_terceiro,
        v_multa_fgts,
        v_saldo_fgts,
        v_desconto_aviso,
        v_desconto_inss,
        v_desconto_irrf,
        v_total_proventos,
        v_total_descontos,
        v_valor_liquido,
        'calculada',
        v_advocato_consultation,
        v_advocato_warnings,
        now()
    ) RETURNING id INTO v_termination_id;

    RETURN v_termination_id;
END;
$_$;


ALTER FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text") IS 'Calcula todos os valores rescis├│rios baseado no tipo de rescis├úo';



CREATE OR REPLACE FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_current_min_wage NUMERIC;
BEGIN
  v_current_min_wage := get_minimum_wage_at_date(p_target_date);

  IF v_current_min_wage IS NULL OR p_fee_in_minimum_wages IS NULL THEN
    RETURN NULL;
  END IF;

  -- Arredondar para 2 casas decimais
  RETURN ROUND(p_fee_in_minimum_wages * v_current_min_wage, 2);
END;
$$;


ALTER FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date") IS 'Calcula o honor├írio reajustado com base no SM atual';



CREATE OR REPLACE FUNCTION "public"."calculate_business_maturity"("p_period" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_analysis_id UUID;
    v_score INTEGER := 0;
    v_level TEXT;
    v_recommendations JSONB := '[]'::jsonb;
    v_blockers JSONB := '[]'::jsonb;

    -- Dados financeiros (simulados - integrar com dados reais)
    v_revenue DECIMAL := 0;
    v_expenses DECIMAL := 0;
    v_profit DECIMAL := 0;
    v_cash DECIMAL := 0;

    -- Scores parciais
    v_accounting_score INTEGER := 0;
    v_financial_score INTEGER := 0;
    v_compliance_score INTEGER := 0;
    v_structure_score INTEGER := 0;

    -- Flags
    v_has_balancete BOOLEAN := false;
    v_is_profitable BOOLEAN := false;
    v_labor_risks INTEGER := 0;
BEGIN
    -- Definir per├¡odo
    IF p_period IS NULL THEN
        p_period := TO_CHAR(CURRENT_DATE, 'YYYY-MM');
    END IF;

    -- 1. VERIFICAR ESTRUTURA CONT├üBIL (Dr. C├¡cero)
    -- Verificar se tem plano de contas
    IF EXISTS (SELECT 1 FROM chart_of_accounts WHERE is_active LIMIT 1) THEN
        v_accounting_score := v_accounting_score + 20;
    ELSE
        v_blockers := v_blockers || jsonb_build_array(
            jsonb_build_object('area', 'contabilidade', 'blocker', 'Plano de contas n├úo configurado')
        );
    END IF;

    -- Verificar se tem lan├ºamento de abertura
    IF EXISTS (SELECT 1 FROM journal_entries WHERE description ILIKE '%abertura%' LIMIT 1) THEN
        v_accounting_score := v_accounting_score + 20;
        v_has_balancete := true;
    ELSE
        v_blockers := v_blockers || jsonb_build_array(
            jsonb_build_object('area', 'contabilidade', 'blocker', 'Saldo de abertura n├úo registrado')
        );
    END IF;

    -- Verificar transa├º├Áes pendentes de classifica├º├úo
    IF EXISTS (SELECT 1 FROM bank_transactions WHERE category IS NULL AND status != 'ignored' LIMIT 1) THEN
        v_recommendations := v_recommendations || jsonb_build_array(
            jsonb_build_object('area', 'contabilidade', 'action', 'Classificar transa├º├Áes banc├írias pendentes')
        );
    ELSE
        v_accounting_score := v_accounting_score + 20;
    END IF;

    -- 2. VERIFICAR SITUA├ç├âO FINANCEIRA (Prof. Milton)
    -- Por enquanto, usar dados simulados
    -- TODO: Integrar com dados reais de receita/despesa
    v_financial_score := 50; -- Score base

    -- 3. VERIFICAR COMPLIANCE TRABALHISTA (Dr. Advocato)
    SELECT COUNT(*) INTO v_labor_risks FROM vw_all_labor_alerts;

    IF v_labor_risks = 0 THEN
        v_compliance_score := 100;
    ELSIF v_labor_risks <= 2 THEN
        v_compliance_score := 70;
        v_recommendations := v_recommendations || jsonb_build_array(
            jsonb_build_object('area', 'trabalhista', 'action', 'Regularizar ' || v_labor_risks || ' pend├¬ncias trabalhistas')
        );
    ELSE
        v_compliance_score := 30;
        v_blockers := v_blockers || jsonb_build_array(
            jsonb_build_object('area', 'trabalhista', 'blocker', v_labor_risks || ' riscos trabalhistas identificados')
        );
    END IF;

    -- 4. VERIFICAR ESTRUTURA SOCIET├üRIA (Sr. Empres├írio)
    IF EXISTS (SELECT 1 FROM company_partners WHERE is_active LIMIT 1) THEN
        v_structure_score := v_structure_score + 50;
    ELSE
        v_recommendations := v_recommendations || jsonb_build_array(
            jsonb_build_object('area', 'societario', 'action', 'Cadastrar s├│cios da empresa')
        );
    END IF;

    IF EXISTS (SELECT 1 FROM company_profile LIMIT 1) THEN
        v_structure_score := v_structure_score + 50;
    ELSE
        v_blockers := v_blockers || jsonb_build_array(
            jsonb_build_object('area', 'societario', 'blocker', 'Perfil da empresa n├úo cadastrado')
        );
    END IF;

    -- CALCULAR SCORE GERAL
    v_score := (v_accounting_score * 0.30 +
                v_financial_score * 0.30 +
                v_compliance_score * 0.20 +
                v_structure_score * 0.20)::integer;

    -- DETERMINAR N├ìVEL
    v_level := CASE
        WHEN v_score >= 85 THEN 'excellent'
        WHEN v_score >= 70 THEN 'mature'
        WHEN v_score >= 50 THEN 'structured'
        WHEN v_score >= 30 THEN 'developing'
        ELSE 'critical'
    END;

    -- SALVAR AN├üLISE
    INSERT INTO business_maturity_analysis (
        analysis_period,
        accounting_score,
        labor_risks_count,
        maturity_score,
        maturity_level,
        recommendations,
        blockers,
        cicero_diagnosis,
        milton_diagnosis,
        advocato_diagnosis,
        can_implement_plr,
        can_implement_incentives,
        can_implement_referrals
    ) VALUES (
        p_period,
        v_accounting_score,
        v_labor_risks,
        v_score,
        v_level,
        v_recommendations,
        v_blockers,
        'Dr. C├¡cero: Score cont├íbil ' || v_accounting_score || '/100. ' ||
            CASE WHEN v_accounting_score >= 60 THEN 'Estrutura b├ísica OK.' ELSE 'ATEN├ç├âO: Estrutura cont├íbil precisa ser organizada.' END,
        'Prof. Milton: Aguardando dados financeiros para an├ílise completa.',
        'Dr. Advocato: ' || v_labor_risks || ' riscos identificados. ' ||
            CASE WHEN v_labor_risks = 0 THEN 'Compliance OK.' ELSE 'A├ç├âO NECESS├üRIA!' END,
        v_score >= 70 AND v_labor_risks = 0,
        v_score >= 50,
        v_score >= 40
    )
    RETURNING id INTO v_analysis_id;

    -- RETORNAR RESULTADO
    RETURN jsonb_build_object(
        'analysis_id', v_analysis_id,
        'period', p_period,
        'maturity_score', v_score,
        'maturity_level', v_level,
        'scores', jsonb_build_object(
            'contabilidade', v_accounting_score,
            'financeiro', v_financial_score,
            'compliance', v_compliance_score,
            'estrutura', v_structure_score
        ),
        'can_implement', jsonb_build_object(
            'plr', v_score >= 70 AND v_labor_risks = 0,
            'incentivos', v_score >= 50,
            'indicacoes', v_score >= 40,
            'investidores', v_score >= 85
        ),
        'blockers_count', jsonb_array_length(v_blockers),
        'blockers', v_blockers,
        'recommendations', v_recommendations,
        'message', CASE v_level
            WHEN 'excellent' THEN 'Dra. Helena: Empresa em excelente situa├º├úo! Todos os programas podem ser implementados.'
            WHEN 'mature' THEN 'Dra. Helena: Empresa madura. PLR e incentivos podem ser implementados ap├│s resolver pend├¬ncias menores.'
            WHEN 'structured' THEN 'Dra. Helena: Empresa em estrutura├º├úo. Incentivos b├ísicos podem come├ºar, mas PLR deve esperar.'
            WHEN 'developing' THEN 'Dra. Helena: ATEN├ç├âO! Empresa em desenvolvimento. Foco deve ser em organizar a estrutura antes de criar programas.'
            ELSE 'Dra. Helena: SITUA├ç├âO CR├ìTICA! Todos os agentes devem se reunir URGENTE para organizar a empresa.'
        END
    );
END;
$$;


ALTER FUNCTION "public"."calculate_business_maturity"("p_period" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_business_maturity"("p_period" "text") IS 'Calcula o score de maturidade analisando contabilidade, finan├ºas, compliance e estrutura';



CREATE OR REPLACE FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") RETURNS TABLE("total_invoices" numeric, "total_opening_balance" numeric, "total_debt" numeric, "overdue_amount" numeric, "overdue_days" integer, "oldest_due_date" "date", "pending_invoices" integer, "pending_opening_balance" integer)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH invoice_debt AS (
    SELECT
      COALESCE(SUM(amount), 0) AS total,
      COALESCE(SUM(CASE WHEN due_date < CURRENT_DATE THEN amount ELSE 0 END), 0) AS overdue,
      MIN(CASE WHEN status = 'pending' THEN due_date END) AS oldest_date,
      COUNT(*) AS count
    FROM invoices
    WHERE client_id = p_client_id
      AND status IN ('pending', 'overdue')
  ),
  opening_debt AS (
    SELECT
      COALESCE(SUM(amount - COALESCE(paid_amount, 0)), 0) AS total,
      COUNT(*) AS count
    FROM client_opening_balance
    WHERE client_id = p_client_id
      AND status IN ('pending', 'partial')
  )
  SELECT
    id.total AS total_invoices,
    od.total AS total_opening_balance,
    (id.total + od.total) AS total_debt,
    id.overdue AS overdue_amount,
    CASE WHEN id.oldest_date IS NOT NULL
      THEN (CURRENT_DATE - id.oldest_date)
      ELSE 0
    END AS overdue_days,
    id.oldest_date AS oldest_due_date,
    id.count::INTEGER AS pending_invoices,
    od.count::INTEGER AS pending_opening_balance
  FROM invoice_debt id, opening_debt od;
END;
$$;


ALTER FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") IS 'Calcula a d├¡vida total de um cliente incluindo faturas e saldo de abertura';



CREATE OR REPLACE FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text" DEFAULT NULL::"text", "p_municipality_code" "text" DEFAULT NULL::"text", "p_adjust_direction" "text" DEFAULT 'backward'::"text") RETURNS "date"
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_due_date DATE;
  v_last_day INTEGER;
BEGIN
  -- Calcular ├║ltimo dia do m├¬s
  v_last_day := EXTRACT(DAY FROM (DATE_TRUNC('month', MAKE_DATE(p_year, p_month, 1)) + INTERVAL '1 month - 1 day'));

  -- Se o dia de vencimento for maior que o ├║ltimo dia do m├¬s, usar ├║ltimo dia
  IF p_payment_day > v_last_day THEN
    v_due_date := MAKE_DATE(p_year, p_month, v_last_day);
  ELSE
    v_due_date := MAKE_DATE(p_year, p_month, p_payment_day);
  END IF;

  -- Ajustar para dia ├║til
  RETURN adjust_to_business_day(v_due_date, p_adjust_direction, p_state_code, p_municipality_code);
END;
$$;


ALTER FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text", "p_municipality_code" "text", "p_adjust_direction" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text", "p_municipality_code" "text", "p_adjust_direction" "text") IS 'Calcula a data de vencimento ajustada para dia ├║til';



CREATE OR REPLACE FUNCTION "public"."calculate_employee_commission"("p_sale_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_sale RECORD;
    v_policy RECORD;
    v_commission DECIMAL;
BEGIN
    -- Buscar venda
    SELECT * INTO v_sale FROM employee_sales WHERE id = p_sale_id;

    IF v_sale IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Venda n├úo encontrada');
    END IF;

    -- Buscar pol├¡tica
    SELECT * INTO v_policy FROM employee_incentive_policies WHERE id = v_sale.policy_id;

    IF v_policy IS NULL THEN
        -- Usar pol├¡tica padr├úo
        SELECT * INTO v_policy
        FROM employee_incentive_policies
        WHERE policy_type = v_sale.sale_type AND is_active
        LIMIT 1;
    END IF;

    -- Calcular comiss├úo
    IF v_policy.employee_reward_percent IS NOT NULL THEN
        v_commission := v_sale.monthly_fee * v_policy.employee_reward_percent / 100;
    ELSE
        v_commission := v_policy.employee_reward_fixed;
    END IF;

    -- Aplicar m├¡nimo e m├íximo
    IF v_policy.employee_reward_min IS NOT NULL THEN
        v_commission := GREATEST(v_commission, v_policy.employee_reward_min);
    END IF;
    IF v_policy.employee_reward_max IS NOT NULL THEN
        v_commission := LEAST(v_commission, v_policy.employee_reward_max);
    END IF;

    -- Atualizar venda
    UPDATE employee_sales SET
        commission_percent = v_policy.employee_reward_percent,
        commission_value = v_commission,
        client_discount_percent = v_policy.client_discount_percent,
        client_discount_months = v_policy.client_discount_months
    WHERE id = p_sale_id;

    RETURN jsonb_build_object(
        'success', true,
        'employee', v_sale.employee_name,
        'commission', v_commission,
        'policy', v_policy.policy_name,
        'message', 'Sra. Marketing calculou: ' || v_sale.employee_name ||
                   ' ganha R$ ' || v_commission || ' pela indica├º├úo!'
    );
END;
$_$;


ALTER FUNCTION "public"."calculate_employee_commission"("p_sale_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_employee_plr"("p_program_id" "uuid", "p_employee_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_program RECORD;
    v_employee RECORD;
    v_criteria RECORD;
    v_score DECIMAL;
    v_total_score DECIMAL := 0;
    v_scores JSONB := '{}'::jsonb;
    v_sales_count INTEGER;
    v_sales_value DECIMAL;
    v_months_employed INTEGER;
BEGIN
    -- Buscar programa
    SELECT * INTO v_program FROM plr_programs WHERE id = p_program_id;
    IF v_program IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Programa n├úo encontrado');
    END IF;

    -- Buscar funcion├írio
    SELECT * INTO v_employee FROM employees WHERE id = p_employee_id;
    IF v_employee IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Funcion├írio n├úo encontrado');
    END IF;

    -- Buscar vendas do funcion├írio no per├¡odo
    SELECT
        COUNT(*) FILTER (WHERE status = 'won'),
        COALESCE(SUM(monthly_fee) FILTER (WHERE status = 'won'), 0)
    INTO v_sales_count, v_sales_value
    FROM employee_sales
    WHERE employee_id = p_employee_id
      AND close_date BETWEEN v_program.start_date AND v_program.end_date;

    -- Calcular tempo de casa em meses
    v_months_employed := EXTRACT(MONTH FROM age(COALESCE(v_program.end_date, CURRENT_DATE), v_employee.hire_date));

    -- Calcular score para cada crit├®rio
    FOR v_criteria IN
        SELECT * FROM plr_criteria WHERE program_id = p_program_id AND is_active
    LOOP
        CASE v_criteria.criteria_type
            WHEN 'sales' THEN
                -- Pontua├º├úo baseada em vendas (0-100)
                v_score := LEAST(v_sales_count * 10, 100);
            WHEN 'time_in_company' THEN
                -- Pontua├º├úo por tempo (at├® 100 para 5+ anos)
                v_score := LEAST(v_months_employed / 0.6, 100); -- 60 meses = 100%
            WHEN 'attendance' THEN
                -- Por enquanto, assume 100% (integrar com ponto depois)
                v_score := 100;
            WHEN 'company_goal' THEN
                -- Pontua├º├úo proporcional ao atingimento da meta
                IF v_criteria.criteria_name LIKE '%Faturamento%' AND v_program.revenue_target > 0 THEN
                    v_score := LEAST((COALESCE(v_program.revenue_actual, 0) / v_program.revenue_target) * 100, 100);
                ELSIF v_criteria.criteria_name LIKE '%Cliente%' AND v_program.client_target > 0 THEN
                    v_score := LEAST((COALESCE(v_program.client_actual, 0)::decimal / v_program.client_target) * 100, 100);
                ELSE
                    v_score := 0;
                END IF;
            ELSE
                v_score := 0;
        END CASE;

        -- Aplicar peso
        v_total_score := v_total_score + (v_score * v_criteria.weight_percent / 100);
        v_scores := v_scores || jsonb_build_object(v_criteria.id::text, v_score);
    END LOOP;

    -- Salvar ou atualizar participa├º├úo
    INSERT INTO plr_employee_share (program_id, employee_id, employee_name, scores, total_score)
    VALUES (p_program_id, p_employee_id, v_employee.name, v_scores, v_total_score)
    ON CONFLICT (program_id, employee_id)
    WHERE EXISTS (
        SELECT 1 FROM plr_employee_share
        WHERE program_id = p_program_id AND employee_id = p_employee_id
    )
    DO UPDATE SET
        scores = v_scores,
        total_score = v_total_score;

    RETURN jsonb_build_object(
        'success', true,
        'employee', v_employee.name,
        'total_score', v_total_score,
        'scores', v_scores,
        'sales_count', v_sales_count,
        'sales_value', v_sales_value,
        'months_employed', v_months_employed
    );
END;
$$;


ALTER FUNCTION "public"."calculate_employee_plr"("p_program_id" "uuid", "p_employee_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") RETURNS TABLE("employee_name" "text", "total_salary" numeric, "vacation_provision" numeric, "thirteenth_provision" numeric, "fgts_provision" numeric, "inss_provision" numeric, "total_provisions" numeric, "risk_level" "text", "risk_notes" "text")
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_employee employees%ROWTYPE;
  v_total_salary DECIMAL;
  v_months_worked INTEGER;
BEGIN
  SELECT * INTO v_employee FROM employees WHERE id = p_employee_id;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Calcular sal├írio total (oficial + n├úo oficial para fins de provis├úo de risco)
  v_total_salary := COALESCE(v_employee.official_salary, 0) + COALESCE(v_employee.unofficial_salary, 0);

  -- Meses trabalhados
  v_months_worked := EXTRACT(MONTH FROM AGE(CURRENT_DATE, v_employee.hire_date));
  IF v_months_worked < 0 THEN v_months_worked := 0; END IF;
  IF v_months_worked > 12 THEN v_months_worked := 12; END IF;

  RETURN QUERY SELECT
    v_employee.name,
    v_total_salary,
    -- F├®rias: 1/12 do sal├írio por m├¬s + 1/3 constitucional
    ROUND((v_total_salary / 12) * v_months_worked * 1.33, 2) AS vacation_provision,
    -- 13┬║: 1/12 do sal├írio por m├¬s
    ROUND((v_total_salary / 12) * v_months_worked, 2) AS thirteenth_provision,
    -- FGTS: 8% do sal├írio por m├¬s
    ROUND(v_total_salary * 0.08 * v_months_worked, 2) AS fgts_provision,
    -- INSS patronal: ~28% (simplificado)
    ROUND(v_total_salary * 0.28, 2) AS inss_provision,
    -- Total
    ROUND((v_total_salary / 12) * v_months_worked * 1.33 + -- F├®rias
          (v_total_salary / 12) * v_months_worked + -- 13┬║
          v_total_salary * 0.08 * v_months_worked + -- FGTS
          v_total_salary * 0.28, 2) AS total_provisions,
    -- N├¡vel de risco
    CASE
      WHEN v_employee.unofficial_salary > 0 THEN 'ALTO'
      WHEN v_employee.contract_type = 'Aut├┤nomo' AND v_employee.is_per_production = false THEN 'M├ëDIO'
      ELSE 'BAIXO'
    END AS risk_level,
    v_employee.labor_risk_notes;
END;
$$;


ALTER FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") IS 'Calcula provis├Áes trabalhistas considerando sal├írio total (oficial + n├úo oficial)';



CREATE OR REPLACE FUNCTION "public"."calculate_referral_end_date"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.end_date := NEW.start_date + (NEW.commission_months || ' months')::INTERVAL;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_referral_end_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") RETURNS TABLE("fee_id" "uuid", "fee_name" character varying, "percentage_rate" numeric, "revenue_base" numeric, "calculated_amount" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        cvf.id as fee_id,
        cvf.fee_name,
        cvf.percentage_rate,
        CASE cvf.calculation_base
            WHEN 'faturamento' THEN COALESCE(cmr.gross_revenue, 0)
            WHEN 'receita_bruta' THEN COALESCE(cmr.net_revenue, cmr.gross_revenue, 0)
            WHEN 'folha_pagamento' THEN COALESCE(cmr.payroll_amount, 0)
            ELSE COALESCE(cmr.gross_revenue, 0)
        END as revenue_base,
        ROUND(
            (CASE cvf.calculation_base
                WHEN 'faturamento' THEN COALESCE(cmr.gross_revenue, 0)
                WHEN 'receita_bruta' THEN COALESCE(cmr.net_revenue, cmr.gross_revenue, 0)
                WHEN 'folha_pagamento' THEN COALESCE(cmr.payroll_amount, 0)
                ELSE COALESCE(cmr.gross_revenue, 0)
            END * cvf.percentage_rate / 100)::DECIMAL, 2
        ) as calculated_amount
    FROM client_variable_fees cvf
    LEFT JOIN client_monthly_revenue cmr ON cmr.client_id = cvf.client_id
        AND cmr.reference_month = p_reference_month
    WHERE cvf.client_id = p_client_id
      AND cvf.is_active = true;
END;
$$;


ALTER FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") IS 'Calcula honor├írio vari├ível baseado no faturamento do m├¬s';



CREATE OR REPLACE FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_year" integer, "p_month" integer) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_config RECORD;
  v_revenue RECORD;
  v_calculated_fee DECIMAL := 0;
BEGIN
  -- Buscar configura├º├úo do honor├írio vari├ível
  SELECT * INTO v_config
  FROM client_variable_fees
  WHERE client_id = p_client_id
    AND is_active = true
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN 0;
  END IF;

  -- Buscar faturamento do per├¡odo de refer├¬ncia
  SELECT * INTO v_revenue
  FROM client_monthly_revenue
  WHERE client_id = p_client_id
    AND reference_year = p_year
    AND reference_month = p_month;

  IF NOT FOUND THEN
    RETURN 0;
  END IF;

  -- Calcular baseado no tipo
  IF v_config.fee_type = 'percentage' THEN
    CASE v_config.calculation_base
      WHEN 'faturamento' THEN
        v_calculated_fee := v_revenue.gross_revenue * v_config.percentage_rate / 100;
      WHEN 'receita_bruta' THEN
        v_calculated_fee := COALESCE(v_revenue.net_revenue, v_revenue.gross_revenue) * v_config.percentage_rate / 100;
      WHEN 'folha_pagamento' THEN
        v_calculated_fee := COALESCE(v_revenue.payroll_total, 0) * v_config.percentage_rate / 100;
    END CASE;
  ELSE
    v_calculated_fee := v_config.fixed_amount;
  END IF;

  -- Atualizar o registro com o valor calculado
  UPDATE client_monthly_revenue
  SET calculated_fee = v_calculated_fee,
      updated_at = NOW()
  WHERE id = v_revenue.id;

  RETURN v_calculated_fee;
END;
$$;


ALTER FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_implement_program"("p_program_code" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_prereq RECORD;
    v_analysis RECORD;
    v_missing JSONB := '[]'::jsonb;
    v_can_implement BOOLEAN := true;
    v_condition_key TEXT;
    v_condition_value JSONB;
BEGIN
    -- Buscar pr├®-requisitos
    SELECT * INTO v_prereq
    FROM program_prerequisites
    WHERE program_code = p_program_code AND is_active;

    IF v_prereq IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Programa n├úo encontrado');
    END IF;

    -- Buscar ├║ltima an├ílise
    SELECT * INTO v_analysis
    FROM business_maturity_analysis
    ORDER BY created_at DESC LIMIT 1;

    IF v_analysis IS NULL THEN
        -- Executar an├ílise primeiro
        PERFORM calculate_business_maturity();
        SELECT * INTO v_analysis
        FROM business_maturity_analysis
        ORDER BY created_at DESC LIMIT 1;
    END IF;

    -- Verificar score m├¡nimo
    IF v_analysis.maturity_score < v_prereq.min_maturity_score THEN
        v_can_implement := false;
        v_missing := v_missing || jsonb_build_array(
            jsonb_build_object(
                'condition', 'maturity_score',
                'required', v_prereq.min_maturity_score,
                'actual', v_analysis.maturity_score,
                'message', 'Score de maturidade insuficiente'
            )
        );
    END IF;

    -- Verificar condi├º├Áes obrigat├│rias
    FOR v_condition_key, v_condition_value IN
        SELECT * FROM jsonb_each(v_prereq.required_conditions)
    LOOP
        -- Verificar cada condi├º├úo
        CASE v_condition_key
            WHEN 'is_profitable' THEN
                IF NOT COALESCE(v_analysis.is_profitable, false) THEN
                    v_can_implement := false;
                    v_missing := v_missing || jsonb_build_array(
                        jsonb_build_object(
                            'condition', 'is_profitable',
                            'required', true,
                            'actual', false,
                            'message', 'Empresa precisa estar lucrativa'
                        )
                    );
                END IF;
            WHEN 'months_profitable' THEN
                IF COALESCE(v_analysis.months_profitable, 0) < (v_condition_value::integer) THEN
                    v_can_implement := false;
                    v_missing := v_missing || jsonb_build_array(
                        jsonb_build_object(
                            'condition', 'months_profitable',
                            'required', v_condition_value,
                            'actual', v_analysis.months_profitable,
                            'message', 'Precisa de mais meses consecutivos de lucro'
                        )
                    );
                END IF;
            WHEN 'has_updated_balancete' THEN
                IF NOT COALESCE(v_analysis.has_updated_balancete, false) THEN
                    v_can_implement := false;
                    v_missing := v_missing || jsonb_build_array(
                        jsonb_build_object(
                            'condition', 'has_updated_balancete',
                            'required', true,
                            'actual', false,
                            'message', 'Balancete precisa estar atualizado'
                        )
                    );
                END IF;
            WHEN 'labor_risks_count_max' THEN
                IF COALESCE(v_analysis.labor_risks_count, 99) > (v_condition_value::integer) THEN
                    v_can_implement := false;
                    v_missing := v_missing || jsonb_build_array(
                        jsonb_build_object(
                            'condition', 'labor_risks_count',
                            'required', '<= ' || v_condition_value::text,
                            'actual', v_analysis.labor_risks_count,
                            'message', 'Riscos trabalhistas precisam ser resolvidos'
                        )
                    );
                END IF;
            ELSE
                NULL; -- Ignorar condi├º├Áes n├úo implementadas ainda
        END CASE;
    END LOOP;

    RETURN jsonb_build_object(
        'success', true,
        'program', v_prereq.program_name,
        'can_implement', v_can_implement,
        'maturity_score', v_analysis.maturity_score,
        'min_score_required', v_prereq.min_maturity_score,
        'missing_conditions', v_missing,
        'risks_if_premature', v_prereq.risks_if_premature,
        'message', CASE
            WHEN v_can_implement THEN
                'Dra. Helena: Ô£à Empresa APTA para implementar ' || v_prereq.program_name || '!'
            ELSE
                'Dra. Helena: ÔÜá´©Å Empresa ainda N├âO est├í pronta para ' || v_prereq.program_name ||
                '. Resolver ' || jsonb_array_length(v_missing) || ' pend├¬ncia(s) primeiro.'
        END
    );
END;
$$;


ALTER FUNCTION "public"."can_implement_program"("p_program_code" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."can_implement_program"("p_program_code" "text") IS 'Verifica se a empresa pode implementar um programa espec├¡fico';



CREATE OR REPLACE FUNCTION "public"."capture_domain_event"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  event_type TEXT;
  payload JSONB;
  tenant_id UUID;
BEGIN
  -- Determinar tipo de evento
  event_type := CASE TG_OP
    WHEN 'INSERT' THEN 'created'
    WHEN 'UPDATE' THEN 'updated'
    WHEN 'DELETE' THEN 'deleted'
  END;

  -- Montar payload
  IF TG_OP = 'DELETE' THEN
    payload := to_jsonb(OLD);
  ELSE
    payload := to_jsonb(NEW);
    IF TG_OP = 'UPDATE' THEN
      payload := payload || jsonb_build_object('_previous', to_jsonb(OLD));
    END IF;
  END IF;

  -- Tentar obter tenant_id
  tenant_id := get_current_tenant_id();

  -- Inserir evento
  INSERT INTO domain_events (
    tenant_id,
    aggregate_type,
    aggregate_id,
    event_type,
    payload,
    user_id,
    metadata
  ) VALUES (
    tenant_id,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    event_type,
    payload,
    auth.uid(),
    jsonb_build_object(
      'table', TG_TABLE_NAME,
      'operation', TG_OP,
      'timestamp', NOW()
    )
  );

  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."capture_domain_event"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_analytical_account_only"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_is_analytical BOOLEAN;
  v_account_code VARCHAR;
BEGIN
  -- Buscar se a conta ├® anal├¡tica
  SELECT is_analytical, code INTO v_is_analytical, v_account_code
  FROM chart_of_accounts
  WHERE id = NEW.account_id;

  -- Se n├úo encontrar a conta (erro de integridade referencial pegaria, mas validamos aqui)
  IF NOT FOUND THEN
     RAISE EXCEPTION 'Conta cont├íbil ID % n├úo encontrada.', NEW.account_id;
  END IF;

  -- A Regra de Ouro do SPED
  IF v_is_analytical = FALSE THEN
     RAISE EXCEPTION 'ERRO CONT├üBIL: Tentativa de lan├ºamento na conta Sint├®tica/Grupo "%". Lan├ºamentos s├úo permitidos APENAS em contas Anal├¡ticas.', v_account_code;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_analytical_account_only"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_employee_hire_date_for_payroll"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_hire_date DATE;
  v_competencia_end DATE;
BEGIN
  -- Buscar data de admiss├úo do funcion├írio
  SELECT hire_date INTO v_hire_date
  FROM employees
  WHERE id = NEW.employee_id;

  -- Calcular ├║ltimo dia da compet├¬ncia
  v_competencia_end := (NEW.competencia + INTERVAL '1 month' - INTERVAL '1 day')::date;

  -- Verificar se funcion├írio foi admitido at├® o final da compet├¬ncia
  IF v_hire_date IS NOT NULL AND v_hire_date > v_competencia_end THEN
    RAISE EXCEPTION 'Funcion├írio n├úo pode ter folha gerada para compet├¬ncia anterior ├á data de admiss├úo. Admiss├úo: %, Compet├¬ncia: %',
      v_hire_date, NEW.competencia;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_employee_hire_date_for_payroll"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_employee_hire_date_for_payroll"() IS 'Valida que funcion├írio n├úo tenha folha gerada para compet├¬ncia anterior ├á sua data de admiss├úo';



CREATE OR REPLACE FUNCTION "public"."check_entry_balance"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  entry_total_debit NUMERIC;
  entry_total_credit NUMERIC;
  lines_total_debit NUMERIC;
  lines_total_credit NUMERIC;
BEGIN
  -- Calcular totais das linhas
  SELECT 
    COALESCE(SUM(debit), 0),
    COALESCE(SUM(credit), 0)
  INTO lines_total_debit, lines_total_credit
  FROM accounting_entry_lines
  WHERE entry_id = NEW.id;

  -- Comparar com os totais do cabe├ºalho
  IF ABS(NEW.total_debit - lines_total_debit) > 0.01 OR 
     ABS(NEW.total_credit - lines_total_credit) > 0.01 THEN
    RAISE EXCEPTION 'Entry totals do not match line totals';
  END IF;

  -- Verificar se est├í balanceado
  IF ABS(lines_total_debit - lines_total_credit) > 0.01 THEN
    NEW.balanced := false;
  ELSE
    NEW.balanced := true;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_entry_balance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_entry_exists"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date" DEFAULT NULL::"date", "p_amount" numeric DEFAULT NULL::numeric) RETURNS TABLE("exists_flag" boolean, "existing_id" "uuid", "existing_code" character varying)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        TRUE,
        ae.id,
        ae.internal_code
    FROM accounting_entries ae
    WHERE (ae.source_type = p_source_type AND ae.source_id = p_source_id)
       OR (ae.reference_type = p_source_type AND ae.reference_id = p_source_id)
    LIMIT 1;

    -- If no rows returned, return false
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, NULL::VARCHAR;
    END IF;
END;
$$;


ALTER FUNCTION "public"."check_entry_exists"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_period_before_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_year INTEGER;
  v_month INTEGER;
BEGIN
  v_year := EXTRACT(YEAR FROM NEW.entry_date);
  v_month := EXTRACT(MONTH FROM NEW.entry_date);

  IF NOT is_period_open(v_year, v_month) THEN
    RAISE EXCEPTION 'Per├¡odo %/% est├í fechado. Solicite reabertura para fazer altera├º├Áes.', v_month, v_year;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_period_before_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."classify_transaction_on_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_code TEXT;
  v_account_name TEXT;
  v_confidence NUMERIC;
  v_description_lower TEXT;
BEGIN
  -- Se j├í tem ai_suggestion, n├úo fazer nada
  IF NEW.ai_suggestion IS NOT NULL THEN
    RETURN NEW;
  END IF;

  -- Normalizar descri├º├úo para busca
  v_description_lower := LOWER(COALESCE(NEW.description, ''));
  v_confidence := 0;

  -- =====================================================
  -- REGRAS DE CLASSIFICA├ç├âO AUTOM├üTICA (ordem de prioridade)
  -- =====================================================

  -- ENERGIA EL├ëTRICA
  IF v_description_lower ~ '(cemig|copel|light|enel|celpe|coelba|energia|eletric)' THEN
    v_account_code := '4.1.2.02';
    v_account_name := 'Energia El├®trica';
    v_confidence := 95;

  -- ├üGUA E ESGOTO
  ELSIF v_description_lower ~ '(copasa|sabesp|cedae|saneago|embasa|agua|sanea)' THEN
    v_account_code := '4.1.2.03';
    v_account_name := '├ügua e Esgoto';
    v_confidence := 95;

  -- TELECOMUNICA├ç├òES
  ELSIF v_description_lower ~ '(vivo|tim|claro|oi telecom|net combo|internet|fibra|telefon)' THEN
    v_account_code := '4.1.2.04';
    v_account_name := 'Telefone e Comunica├º├úo';
    v_confidence := 92;

  -- IMPOSTOS E TAXAS
  ELSIF v_description_lower ~ '(darf|gps|inss|fgts|irrf|simples|das mei|iss|iptu|ipva|taxa)' THEN
    v_account_code := '4.1.4.01';
    v_account_name := 'Simples Nacional';
    v_confidence := 93;

  -- TARIFAS BANC├üRIAS
  ELSIF v_description_lower ~ '(tarifa|tar\.bancaria|iof|taxa.*manut|anuidade|ted|doc|pix.*taxa)' THEN
    v_account_code := '4.1.3.02';
    v_account_name := 'Tarifas Banc├írias';
    v_confidence := 90;

  -- SOFTWARE E SISTEMAS
  ELSIF v_description_lower ~ '(google|microsoft|adobe|dropbox|slack|zoom|notion|aws|azure|github|dominio|alterdata)' THEN
    v_account_code := '4.1.2.12';
    v_account_name := 'Software e Sistemas';
    v_confidence := 88;

  -- HONOR├üRIOS (RECEITA)
  ELSIF v_description_lower ~ '(honorario|mensalidade|contabil)' AND NEW.amount > 0 THEN
    v_account_code := '3.1.1.01';
    v_account_name := 'Honor├írios Cont├íbeis';
    v_confidence := 90;

  -- SAL├üRIOS
  ELSIF v_description_lower ~ '(salario|folha|pagto.*func|adiantamento.*func)' THEN
    v_account_code := '4.1.1.01';
    v_account_name := 'Sal├írios e Ordenados';
    v_confidence := 92;

  -- MATERIAL DE LIMPEZA/ESCRIT├ôRIO
  ELSIF v_description_lower ~ '(kalunga|papelaria|material.*escrit|limpeza)' THEN
    v_account_code := '4.1.2.08';
    v_account_name := 'Material de Limpeza';
    v_confidence := 85;

  -- CONDOM├ìNIO
  ELSIF v_description_lower ~ '(condominio|cond\.|taxa.*cond)' THEN
    v_account_code := '4.1.2.01';
    v_account_name := 'Aluguel e Condom├¡nio';
    v_confidence := 90;

  -- ALUGUEL
  ELSIF v_description_lower ~ '(aluguel|locacao|imobil)' THEN
    v_account_code := '4.1.2.01';
    v_account_name := 'Aluguel e Condom├¡nio';
    v_confidence := 90;

  -- SEGUROS
  ELSIF v_description_lower ~ '(seguro|porto.*seguro|sulamerica|bradesco.*seg|mapfre)' THEN
    v_account_code := '4.1.2.99';
    v_account_name := 'Outras Despesas Administrativas';
    v_confidence := 85;

  -- SE N├âO CONSEGUIU CLASSIFICAR - VAI PARA CONTA PENDENTE
  ELSE
    IF NEW.amount < 0 OR NEW.transaction_type = 'debit' THEN
      -- D├®bito n├úo classificado
      v_account_code := '1.1.9.01';
      v_account_name := 'Pendente de Classifica├º├úo - D├®bitos';
      v_confidence := 0;
    ELSE
      -- Cr├®dito n├úo classificado
      v_account_code := '2.1.9.01';
      v_account_name := 'Pendente de Classifica├º├úo - Cr├®ditos';
      v_confidence := 0;
    END IF;
  END IF;

  -- SEMPRE atribuir classifica├º├úo (nunca deixar NULL)
  IF v_confidence > 0 THEN
    NEW.ai_suggestion := 'Dr. C├¡cero (' || v_confidence || '%): ' || v_account_name || ' | Conta: ' || v_account_code;
  ELSE
    NEW.ai_suggestion := 'Dr. C├¡cero (PENDENTE): ' || v_account_name || ' | Conta: ' || v_account_code || ' | Requer reclassifica├º├úo manual';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."classify_transaction_on_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_closing_id UUID;
  v_total_revenue DECIMAL(15,2);
  v_total_expenses DECIMAL(15,2);
  v_accounts_receivable DECIMAL(15,2);
  v_accounts_payable DECIMAL(15,2);
  v_bank_balances JSONB;
  v_next_year INTEGER;
  v_next_month INTEGER;
  v_start_date DATE;
  v_end_date DATE;
BEGIN
  -- Calcular datas do per├¡odo
  v_start_date := make_date(p_year, p_month, 1);
  v_end_date := (v_start_date + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

  -- Verificar se j├í est├í fechado
  IF is_period_closed(p_year, p_month) THEN
    RAISE EXCEPTION 'O per├¡odo %/% j├í est├í fechado', p_month, p_year;
  END IF;

  -- CORRE├ç├âO: Calcular total de receitas (invoices pagas no per├¡odo)
  -- Coluna correta: paid_date (n├úo payment_date)
  SELECT COALESCE(SUM(amount), 0) INTO v_total_revenue
  FROM invoices
  WHERE paid_date BETWEEN v_start_date AND v_end_date
    AND status = 'paid';

  -- CORRE├ç├âO: Calcular total de despesas (expenses pagas no per├¡odo)
  -- Coluna correta: paid_date (n├úo payment_date)
  SELECT COALESCE(SUM(amount), 0) INTO v_total_expenses
  FROM expenses
  WHERE paid_date BETWEEN v_start_date AND v_end_date
    AND status = 'paid';

  -- Calcular contas a receber (invoices pendentes at├® o fim do per├¡odo)
  SELECT COALESCE(SUM(amount), 0) INTO v_accounts_receivable
  FROM invoices
  WHERE due_date <= v_end_date
    AND status IN ('pending', 'overdue');

  -- Calcular contas a pagar (expenses pendentes at├® o fim do per├¡odo)
  SELECT COALESCE(SUM(amount), 0) INTO v_accounts_payable
  FROM expenses
  WHERE due_date <= v_end_date
    AND status IN ('pending', 'overdue');

  -- Capturar saldos banc├írios
  SELECT COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'bank_account_id', id,
        'account_name', name,
        'closing_balance', current_balance
      )
    ),
    '[]'::jsonb
  ) INTO v_bank_balances
  FROM bank_accounts
  WHERE is_active = true;

  -- Criar ou atualizar registro de fechamento
  INSERT INTO monthly_closings (
    year, month, status,
    closed_at, closed_by,
    total_revenue, total_expenses, net_result,
    accounts_receivable, accounts_payable,
    bank_balances, notes
  ) VALUES (
    p_year, p_month, 'closed',
    now(), p_user_id,
    v_total_revenue, v_total_expenses, v_total_revenue - v_total_expenses,
    v_accounts_receivable, v_accounts_payable,
    v_bank_balances, p_notes
  )
  ON CONFLICT (year, month) DO UPDATE SET
    status = 'closed',
    closed_at = now(),
    closed_by = p_user_id,
    total_revenue = EXCLUDED.total_revenue,
    total_expenses = EXCLUDED.total_expenses,
    net_result = EXCLUDED.net_result,
    accounts_receivable = EXCLUDED.accounts_receivable,
    accounts_payable = EXCLUDED.accounts_payable,
    bank_balances = EXCLUDED.bank_balances,
    notes = EXCLUDED.notes,
    updated_at = now()
  RETURNING id INTO v_closing_id;

  -- Obter pr├│ximo per├¡odo
  SELECT * INTO v_next_year, v_next_month FROM get_next_period(p_year, p_month);

  -- Criar saldos de abertura para o pr├│ximo m├¬s (para cada conta banc├íria)
  INSERT INTO bank_opening_balances (bank_account_id, year, month, opening_balance, source_closing_id)
  SELECT
    ba.id,
    v_next_year,
    v_next_month,
    ba.current_balance,
    v_closing_id
  FROM bank_accounts ba
  WHERE ba.is_active = true
  ON CONFLICT (bank_account_id, year, month) DO UPDATE SET
    opening_balance = EXCLUDED.opening_balance,
    source_closing_id = EXCLUDED.source_closing_id;

  -- Marcar saldo como transferido
  UPDATE monthly_closings
  SET balance_transferred = true, transferred_at = now()
  WHERE id = v_closing_id;

  RETURN v_closing_id;
END;
$$;


ALTER FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text") IS 'Fecha o m├¬s, calcula totais e transfere saldos para o pr├│ximo per├¡odo';



CREATE OR REPLACE FUNCTION "public"."cmd_create_accounting_entry"("p_account_id" "uuid", "p_entry_date" "date", "p_entry_type" "text", "p_amount" numeric, "p_description" "text", "p_client_id" "uuid" DEFAULT NULL::"uuid", "p_reference_type" "text" DEFAULT NULL::"text", "p_reference_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  new_entry_id UUID;
  account_exists BOOLEAN;
  debit_amount NUMERIC := 0;
  credit_amount NUMERIC := 0;
BEGIN
  -- Valida├º├úo
  SELECT EXISTS(SELECT 1 FROM chart_of_accounts WHERE id = p_account_id) INTO account_exists;
  IF NOT account_exists THEN
    RAISE EXCEPTION 'Conta cont├íbil n├úo encontrada: %', p_account_id;
  END IF;

  IF p_amount <= 0 THEN
    RAISE EXCEPTION 'Valor deve ser maior que zero';
  END IF;

  IF p_entry_type NOT IN ('debit', 'credit') THEN
    RAISE EXCEPTION 'Tipo de lan├ºamento inv├ílido: %', p_entry_type;
  END IF;

  -- Definir valores de d├®bito/cr├®dito
  IF p_entry_type = 'debit' THEN
    debit_amount := p_amount;
  ELSE
    credit_amount := p_amount;
  END IF;

  -- Criar entrada principal (accounting_entries)
  INSERT INTO accounting_entries (
    entry_date, competence_date, description, entry_type,
    total_debit, total_credit, created_by
  ) VALUES (
    p_entry_date, p_entry_date, p_description, p_reference_type,
    debit_amount, credit_amount, auth.uid()
  ) RETURNING id INTO new_entry_id;

  -- Criar item do lan├ºamento (accounting_entry_items)
  INSERT INTO accounting_entry_items (
    entry_id, account_id, debit, credit, history, client_id
  ) VALUES (
    new_entry_id, p_account_id, debit_amount, credit_amount, p_description, p_client_id
  );

  -- Marcar views para refresh
  PERFORM pg_notify('refresh_views', 'mv_client_balances,mv_trial_balance');

  RETURN new_entry_id;
END;
$$;


ALTER FUNCTION "public"."cmd_create_accounting_entry"("p_account_id" "uuid", "p_entry_date" "date", "p_entry_type" "text", "p_amount" numeric, "p_description" "text", "p_client_id" "uuid", "p_reference_type" "text", "p_reference_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."comparar_meses"("p_mes_atual" "text", "p_mes_anterior" "text") RETURNS TABLE("indicador" "text", "valor_atual" numeric, "valor_anterior" numeric, "variacao_percentual" numeric, "variacao_absoluta" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_receita_atual NUMERIC;
  v_receita_anterior NUMERIC;
  v_despesa_atual NUMERIC;
  v_despesa_anterior NUMERIC;
BEGIN
  -- Receitas m├¬s atual
  SELECT COALESCE(SUM(ael.credit), 0) INTO v_receita_atual
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '3.%'
    AND to_char(ae.entry_date, 'YYYY-MM') = p_mes_atual
    AND ael.credit > 0;

  -- Receitas m├¬s anterior
  SELECT COALESCE(SUM(ael.credit), 0) INTO v_receita_anterior
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '3.%'
    AND to_char(ae.entry_date, 'YYYY-MM') = p_mes_anterior
    AND ael.credit > 0;

  -- Despesas m├¬s atual
  SELECT COALESCE(SUM(ael.debit), 0) INTO v_despesa_atual
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '4.%'
    AND to_char(ae.entry_date, 'YYYY-MM') = p_mes_atual
    AND ael.debit > 0;

  -- Despesas m├¬s anterior
  SELECT COALESCE(SUM(ael.debit), 0) INTO v_despesa_anterior
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '4.%'
    AND to_char(ae.entry_date, 'YYYY-MM') = p_mes_anterior
    AND ael.debit > 0;

  -- Retornar comparativo
  RETURN QUERY
  SELECT 'Receitas'::TEXT, v_receita_atual, v_receita_anterior,
    CASE WHEN v_receita_anterior > 0
      THEN ROUND(((v_receita_atual - v_receita_anterior) / v_receita_anterior * 100)::numeric, 2)
      ELSE 0
    END,
    v_receita_atual - v_receita_anterior
  UNION ALL
  SELECT 'Despesas'::TEXT, v_despesa_atual, v_despesa_anterior,
    CASE WHEN v_despesa_anterior > 0
      THEN ROUND(((v_despesa_atual - v_despesa_anterior) / v_despesa_anterior * 100)::numeric, 2)
      ELSE 0
    END,
    v_despesa_atual - v_despesa_anterior
  UNION ALL
  SELECT 'Lucro'::TEXT,
    v_receita_atual - v_despesa_atual,
    v_receita_anterior - v_despesa_anterior,
    CASE WHEN (v_receita_anterior - v_despesa_anterior) > 0
      THEN ROUND((((v_receita_atual - v_despesa_atual) - (v_receita_anterior - v_despesa_anterior)) / (v_receita_anterior - v_despesa_anterior) * 100)::numeric, 2)
      ELSE 0
    END,
    (v_receita_atual - v_despesa_atual) - (v_receita_anterior - v_despesa_anterior);
END;
$$;


ALTER FUNCTION "public"."comparar_meses"("p_mes_atual" "text", "p_mes_anterior" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric DEFAULT 0.9, "p_model" "text" DEFAULT 'gemini-2.0-flash'::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_entry_id UUID;
BEGIN
  -- Buscar entry_id
  SELECT entry_id INTO v_entry_id FROM ai_validation_queue WHERE id = p_queue_id;

  IF v_entry_id IS NULL THEN
    RAISE EXCEPTION 'Queue item not found: %', p_queue_id;
  END IF;

  -- Atualizar accounting_entry
  UPDATE accounting_entries SET
    ai_validated = true,
    ai_validated_at = now(),
    ai_validation_result = p_result,
    ai_validation_message = p_message,
    ai_confidence = p_confidence,
    ai_model = p_model
  WHERE id = v_entry_id;

  -- Marcar fila como conclu├¡da
  UPDATE ai_validation_queue SET
    status = 'completed',
    completed_at = now()
  WHERE id = p_queue_id;
END;
$$;


ALTER FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric, "p_model" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric, "p_model" "text") IS 'Marca uma valida├º├úo como conclu├¡da';



CREATE OR REPLACE FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_monthly_fee NUMERIC;
  v_min_wage NUMERIC;
BEGIN
  -- Obter honor├írio atual
  SELECT monthly_fee INTO v_monthly_fee
  FROM clients WHERE id = p_client_id;

  IF v_monthly_fee IS NULL OR v_monthly_fee = 0 THEN
    RETURN 0;
  END IF;

  -- Usar SM de refer├¬ncia ou o atual
  v_min_wage := COALESCE(p_reference_minimum_wage, get_minimum_wage_at_date());

  IF v_min_wage IS NULL OR v_min_wage = 0 THEN
    RETURN 0;
  END IF;

  RETURN ROUND(v_monthly_fee / v_min_wage, 4);
END;
$$;


ALTER FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric) IS 'Converte o honor├írio de um cliente para quantidade de sal├írios m├¡nimos';



CREATE OR REPLACE FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_invoice RECORD;
  v_client_name TEXT;
  v_client_account_id UUID;
  v_revenue_account_id UUID;
  v_entry_id UUID;
  v_competence TEXT;
BEGIN
  -- Buscar dados da fatura
  SELECT * INTO v_invoice FROM invoices WHERE id = p_invoice_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Fatura n├úo encontrada: %', p_invoice_id;
  END IF;

  -- Ignorar saldos de abertura (j├í foram migrados para PL)
  IF v_invoice.source = 'opening_balance' THEN
    RETURN NULL;
  END IF;

  -- Verificar se j├í existe lan├ºamento para esta fatura
  SELECT id INTO v_entry_id
  FROM accounting_entries
  WHERE reference_type = 'invoice'
    AND reference_id = p_invoice_id
    AND entry_type = 'receita_honorarios';

  IF v_entry_id IS NOT NULL THEN
    RETURN v_entry_id; -- J├í existe, retornar ID existente
  END IF;

  -- Buscar nome do cliente
  SELECT name INTO v_client_name FROM clients WHERE id = v_invoice.client_id;
  v_client_name := COALESCE(v_client_name, 'Cliente n├úo identificado');

  -- Buscar ou criar conta do cliente (1.1.2.01.XXX)
  SELECT id INTO v_client_account_id
  FROM chart_of_accounts
  WHERE code LIKE '1.1.2.01.%'
    AND name ILIKE '%' || v_client_name || '%'
  LIMIT 1;

  IF v_client_account_id IS NULL THEN
    -- Criar conta do cliente
    INSERT INTO chart_of_accounts (
      code,
      name,
      account_type,
      nature,
      level,
      is_synthetic,
      is_analytical,
      accepts_entries,
      is_active
    )
    SELECT
      '1.1.2.01.' || LPAD((COALESCE(MAX(NULLIF(SPLIT_PART(code, '.', 5), '')::INT), 0) + 1)::TEXT, 3, '0'),
      'Cliente: ' || v_client_name,
      'ATIVO',
      'DEVEDORA',
      5,
      false,
      true,
      true,
      true
    FROM chart_of_accounts
    WHERE code LIKE '1.1.2.01.%'
    RETURNING id INTO v_client_account_id;
  END IF;

  -- Buscar conta de receita (3.1.1.01 - Honor├írios Cont├íbeis)
  SELECT id INTO v_revenue_account_id
  FROM chart_of_accounts
  WHERE code = '3.1.1.01';

  IF v_revenue_account_id IS NULL THEN
    RAISE EXCEPTION 'Conta de receita 3.1.1.01 n├úo encontrada no plano de contas';
  END IF;

  -- Determinar compet├¬ncia (MM/YYYY)
  v_competence := TO_CHAR(COALESCE(v_invoice.competence_date, v_invoice.issue_date, v_invoice.created_at), 'MM/YYYY');

  -- Criar lan├ºamento cont├íbil
  INSERT INTO accounting_entries (
    entry_date,
    competence_date,
    entry_type,
    description,
    reference_type,
    reference_id,
    total_debit,
    total_credit,
    balanced,
    created_by
  ) VALUES (
    COALESCE(v_invoice.issue_date, CURRENT_DATE),
    v_competence,
    'receita_honorarios',
    'Provis├úo de honor├írios - ' || v_client_name || ' - ' || v_competence,
    'invoice',
    p_invoice_id,
    v_invoice.amount,
    v_invoice.amount,
    true,
    v_invoice.created_by
  )
  RETURNING id INTO v_entry_id;

  -- Criar linhas do lan├ºamento (partidas dobradas)
  -- D├®bito: Cliente a Receber
  INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
  VALUES (v_entry_id, v_client_account_id, 'D - ' || v_client_name, v_invoice.amount, 0);

  -- Cr├®dito: Receita de Honor├írios
  INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
  VALUES (v_entry_id, v_revenue_account_id, 'C - Honor├írios Cont├íbeis', 0, v_invoice.amount);

  RETURN v_entry_id;
END;
$$;


ALTER FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") IS 'Cria lan├ºamento cont├íbil para uma fatura espec├¡fica';



CREATE OR REPLACE FUNCTION "public"."create_auto_consultation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_solutions TEXT[];
    v_jurisprudence TEXT[];
    v_recommendation TEXT;
BEGIN
    -- Buscar solu├º├Áes baseado no tipo de alerta
    SELECT array_agg(code) INTO v_solutions
    FROM labor_solution_strategies
    WHERE code = ANY(
        SELECT unnest(solution_codes)
        FROM risk_solution_mapping
        WHERE risk_type = CASE
            WHEN NEW.alert_type = 'unofficial_salary' THEN 'pagamento_nao_registrado'
            WHEN NEW.alert_type = 'provider_no_contract' THEN 'vinculo_trabalhista'
            ELSE 'vinculo_trabalhista'
        END
    );

    -- Buscar jurisprud├¬ncia relevante
    SELECT array_agg(case_number) INTO v_jurisprudence
    FROM labor_jurisprudence
    WHERE risk_type = CASE
        WHEN NEW.alert_type = 'unofficial_salary' THEN 'pagamento_nao_registrado'
        WHEN NEW.alert_type = 'provider_no_contract' THEN 'vinculo_trabalhista'
        ELSE 'vinculo_trabalhista'
    END
    LIMIT 3;

    -- Gerar recomenda├º├úo baseada no agente
    v_recommendation := CASE
        WHEN NEW.severity = 'critical' THEN
            'Dr. Advocato URGENTE: Situa├º├úo de alto risco. Recomendo regulariza├º├úo imediata ou reestrutura├º├úo da rela├º├úo. Consulte jurisprud├¬ncia citada.'
        WHEN NEW.severity = 'high' THEN
            'Dr. Advocato ALERTA: Risco significativo identificado. Avalie as solu├º├Áes sugeridas com Sr. Empres├írio.'
        ELSE
            'Dr. Advocato ATEN├ç├âO: Situa├º├úo requer monitoramento. Considere implementar medidas preventivas.'
    END;

    -- Inserir consulta autom├ítica
    INSERT INTO ai_labor_consultations (
        person_type,
        person_id,
        person_name,
        risk_identified,
        risk_severity,
        solutions_suggested,
        ai_recommendation,
        jurisprudence_cited
    ) VALUES (
        NEW.entity_type,
        NEW.entity_id,
        NEW.entity_name,
        NEW.alert_type,
        NEW.severity,
        v_solutions,
        v_recommendation,
        v_jurisprudence
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_auto_consultation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_client_accounting_account"("p_client_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_client RECORD;
    v_parent_id UUID;
    v_account_id UUID;
    v_code VARCHAR;
    v_existing_id UUID;
BEGIN
    -- Buscar dados do cliente
    SELECT * INTO v_client FROM clients WHERE id = p_client_id;
    
    IF v_client IS NULL THEN
        RAISE EXCEPTION 'Cliente n├úo encontrado: %', p_client_id;
    END IF;
    
    -- Verificar se cliente j├í tem conta
    IF v_client.accounting_account_id IS NOT NULL THEN
        RETURN v_client.accounting_account_id;
    END IF;
    
    -- Buscar conta pai (1.1.2.01)
    SELECT id INTO v_parent_id FROM chart_of_accounts WHERE code = '1.1.2.01';
    
    -- Verificar se j├í existe conta com o nome do cliente
    SELECT id INTO v_existing_id 
    FROM chart_of_accounts 
    WHERE code LIKE '1.1.2.01.%' 
    AND (
        UPPER(name) LIKE '%' || UPPER(COALESCE(v_client.razao_social, v_client.name)) || '%'
        OR UPPER(name) LIKE '%' || UPPER(v_client.cnpj) || '%'
    )
    LIMIT 1;
    
    IF v_existing_id IS NOT NULL THEN
        -- Usar conta existente
        v_account_id := v_existing_id;
        
        -- Ativar se estiver inativa
        UPDATE chart_of_accounts SET is_active = true WHERE id = v_account_id;
    ELSE
        -- Criar nova conta
        v_code := get_next_client_account_code();
        
        INSERT INTO chart_of_accounts (
            code,
            name,
            parent_id,
            account_type,
            nature,
            level,
            is_synthetic,
            is_analytical,
            is_active
        ) VALUES (
            v_code,
            COALESCE(v_client.razao_social, v_client.name),
            v_parent_id,
            'asset',
            'debit',
            5,
            false,
            true,
            true
        ) RETURNING id INTO v_account_id;
    END IF;
    
    -- Vincular conta ao cliente
    UPDATE clients SET accounting_account_id = v_account_id WHERE id = p_client_id;
    
    RETURN v_account_id;
END;
$$;


ALTER FUNCTION "public"."create_client_accounting_account"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_confession_installments"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  i INTEGER;
  due_date DATE;
BEGIN
  -- S├│ criar se for nova confiss├úo com status signed ou active
  IF NEW.status IN ('signed', 'active') AND
     (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.status = 'draft')) THEN

    -- Deletar parcelas existentes se houver
    DELETE FROM debt_confession_installments WHERE confession_id = NEW.id;

    -- Criar novas parcelas
    FOR i IN 1..NEW.installments LOOP
      due_date := NEW.first_due_date + ((i - 1) * INTERVAL '1 month');

      INSERT INTO debt_confession_installments (
        confession_id,
        installment_number,
        amount,
        due_date,
        status
      ) VALUES (
        NEW.id,
        i,
        NEW.installment_value,
        due_date,
        'pending'
      );
    END LOOP;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_confession_installments"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "negotiation_id" "uuid", "negotiation_number" "text", "original_debt" numeric, "discount_amount" numeric, "final_amount" numeric, "installment_amount" numeric, "requires_approval" boolean, "approval_level" "text", "message" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_original_debt NUMERIC := 0;
  v_invoice_total NUMERIC := 0;
  v_opening_total NUMERIC := 0;
  v_discount NUMERIC;
  v_final NUMERIC;
  v_installment NUMERIC;
  v_negotiation_id UUID;
  v_negotiation_number TEXT;
  v_requires_approval BOOLEAN := false;
  v_approval_level TEXT := 'operator';
  v_user_id UUID;
BEGIN
  -- Obter usu├írio atual
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    v_user_id := '00000000-0000-0000-0000-000000000000'::UUID;
  END IF;

  -- Calcular total das faturas selecionadas
  IF p_invoice_ids IS NOT NULL AND array_length(p_invoice_ids, 1) > 0 THEN
    SELECT COALESCE(SUM(amount), 0)
    INTO v_invoice_total
    FROM invoices
    WHERE id = ANY(p_invoice_ids)
      AND status IN ('pending', 'overdue');
  END IF;

  -- Calcular total dos saldos de abertura selecionados
  IF p_opening_balance_ids IS NOT NULL AND array_length(p_opening_balance_ids, 1) > 0 THEN
    SELECT COALESCE(SUM(amount - COALESCE(paid_amount, 0)), 0)
    INTO v_opening_total
    FROM client_opening_balance
    WHERE id = ANY(p_opening_balance_ids)
      AND status IN ('pending', 'partial');
  END IF;

  v_original_debt := v_invoice_total + v_opening_total;

  IF v_original_debt <= 0 THEN
    RETURN QUERY SELECT
      false, NULL::UUID, NULL::TEXT, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, false, NULL::TEXT,
      'Nenhuma d├¡vida encontrada para os itens selecionados'::TEXT;
    RETURN;
  END IF;

  -- Calcular desconto e valor final
  v_discount := ROUND(v_original_debt * (p_discount_percentage / 100), 2);
  v_final := v_original_debt - v_discount;
  v_installment := ROUND(v_final / p_installments_count, 2);

  -- Verificar necessidade de aprova├º├úo
  SELECT
    CASE WHEN p_discount_percentage > 0 THEN true ELSE false END,
    COALESCE(
      (SELECT dar.approval_level
       FROM discount_approval_rules dar
       WHERE dar.is_active = true
         AND p_discount_percentage >= dar.min_discount_percentage
         AND p_discount_percentage <= dar.max_discount_percentage
       LIMIT 1),
      'owner'
    )
  INTO v_requires_approval, v_approval_level;

  -- Criar a negocia├º├úo
  INSERT INTO debt_negotiations (
    client_id,
    original_debt,
    discount_amount,
    discount_percentage,
    final_amount,
    payment_type,
    installments_count,
    first_due_date,
    installment_amount,
    status,
    requires_approval,
    approval_level,
    invoice_ids,
    opening_balance_ids,
    notes,
    negotiated_by
  ) VALUES (
    p_client_id,
    v_original_debt,
    v_discount,
    p_discount_percentage,
    v_final,
    CASE WHEN p_installments_count = 1 THEN 'single' ELSE 'installment' END,
    p_installments_count,
    p_first_due_date,
    v_installment,
    CASE WHEN v_requires_approval AND p_discount_percentage > 5 THEN 'pending_approval' ELSE 'draft' END,
    v_requires_approval,
    v_approval_level,
    p_invoice_ids,
    p_opening_balance_ids,
    p_notes,
    v_user_id
  )
  RETURNING id, negotiation_number INTO v_negotiation_id, v_negotiation_number;

  -- Gerar parcelas
  FOR i IN 1..p_installments_count LOOP
    INSERT INTO negotiation_installments (
      negotiation_id,
      installment_number,
      amount,
      due_date,
      status
    ) VALUES (
      v_negotiation_id,
      i,
      CASE WHEN i = p_installments_count
        THEN v_final - (v_installment * (p_installments_count - 1)) -- ├Ültima parcela ajusta diferen├ºa de arredondamento
        ELSE v_installment
      END,
      p_first_due_date + ((i - 1) * INTERVAL '1 month'),
      'pending'
    );
  END LOOP;

  RETURN QUERY SELECT
    true,
    v_negotiation_id,
    v_negotiation_number,
    v_original_debt,
    v_discount,
    v_final,
    v_installment,
    v_requires_approval,
    v_approval_level,
    CASE
      WHEN v_requires_approval AND p_discount_percentage > 5 THEN 'Negocia├º├úo criada - aguardando aprova├º├úo de ' || v_approval_level
      ELSE 'Negocia├º├úo criada com sucesso'
    END::TEXT;
END;
$$;


ALTER FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text") IS 'Cria uma nova negocia├º├úo de d├¡vida com desconto e parcelamento';



CREATE OR REPLACE FUNCTION "public"."create_economic_group"("p_group_name" "text", "p_main_company_name" "text", "p_main_company_cnpj" "text", "p_member_companies" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_group_id UUID;
    v_member JSONB;
    v_count INTEGER := 0;
BEGIN
    -- Criar grupo
    INSERT INTO economic_groups (
        group_name,
        main_company_name,
        main_company_cnpj,
        group_code
    ) VALUES (
        p_group_name,
        p_main_company_name,
        p_main_company_cnpj,
        'GRP-' || LPAD(nextval('economic_group_seq')::text, 4, '0')
    )
    RETURNING id INTO v_group_id;

    -- Adicionar empresa principal como membro
    INSERT INTO economic_group_members (
        group_id, company_name, cnpj, relationship_type, ownership_percent
    ) VALUES (
        v_group_id, p_main_company_name, p_main_company_cnpj, 'holding', 100
    );
    v_count := 1;

    -- Adicionar demais membros
    FOR v_member IN SELECT * FROM jsonb_array_elements(p_member_companies)
    LOOP
        INSERT INTO economic_group_members (
            group_id,
            company_name,
            cnpj,
            relationship_type,
            ownership_percent
        ) VALUES (
            v_group_id,
            v_member->>'name',
            v_member->>'cnpj',
            COALESCE(v_member->>'relationship', 'subsidiary'),
            COALESCE((v_member->>'ownership')::decimal, 0)
        );
        v_count := v_count + 1;
    END LOOP;

    RETURN jsonb_build_object(
        'success', true,
        'group_id', v_group_id,
        'total_members', v_count,
        'message', 'Dra. Helena: Grupo econ├┤mico "' || p_group_name || '" criado com ' || v_count || ' empresas!'
    );
END;
$$;


ALTER FUNCTION "public"."create_economic_group"("p_group_name" "text", "p_main_company_name" "text", "p_main_company_cnpj" "text", "p_member_companies" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_entry_from_bank_transaction"("p_transaction_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_tx RECORD;
    v_entry_id UUID;
    v_entry_type VARCHAR;
    v_debit_account_id UUID;
    v_credit_account_id UUID;
    v_bank_account_id UUID;
    v_description VARCHAR;
    v_client_id UUID;
    v_client_account_id UUID;
BEGIN
    -- Get transaction data
    SELECT * INTO v_tx FROM bank_transactions WHERE id = p_transaction_id;

    IF v_tx IS NULL THEN
        RAISE EXCEPTION 'Transaction not found: %', p_transaction_id;
    END IF;

    -- Check if entry already exists
    SELECT id INTO v_entry_id
    FROM accounting_entries
    WHERE source_type = 'bank_transaction' AND source_id = p_transaction_id;

    IF v_entry_id IS NOT NULL THEN
        RETURN v_entry_id; 
    END IF;

    -- Get Sicredi account
    SELECT id INTO v_bank_account_id
    FROM chart_of_accounts WHERE code = '1.1.1.05';

    -- Determine entry type and accounts based on transaction
    IF v_tx.transaction_type = 'credit' THEN
        -- RECEBIMENTO (entrada de dinheiro)
        v_entry_type := 'recebimento';
        v_debit_account_id := v_bank_account_id;
        
        -- NOVO: Tentar identificar cliente pelo CNPJ/CPF na descri├º├úo
        -- e usar sua conta espec├¡fica
        v_client_account_id := NULL;
        
        -- Buscar cliente pelo CNPJ na descri├º├úo
        SELECT c.accounting_account_id, c.id INTO v_client_account_id, v_client_id
        FROM clients c
        WHERE c.cnpj IS NOT NULL 
        AND v_tx.description LIKE '%' || c.cnpj || '%'
        AND c.accounting_account_id IS NOT NULL
        LIMIT 1;
        
        -- Se n├úo achou pelo CNPJ, buscar por parte do nome
        IF v_client_account_id IS NULL THEN
            SELECT c.accounting_account_id, c.id INTO v_client_account_id, v_client_id
            FROM clients c
            WHERE c.accounting_account_id IS NOT NULL
            AND UPPER(v_tx.description) LIKE '%' || UPPER(SUBSTRING(c.name FROM 1 FOR 15)) || '%'
            LIMIT 1;
        END IF;
        
        -- Usar conta do cliente ou conta gen├®rica
        IF v_client_account_id IS NOT NULL THEN
            v_credit_account_id := v_client_account_id;
        ELSE
            -- Fallback: conta gen├®rica (n├úo ideal, mas evita erro)
            SELECT id INTO v_credit_account_id FROM chart_of_accounts WHERE code = '1.1.2.01';
        END IF;
        
        v_description := CONCAT('Recebimento: ', LEFT(v_tx.description, 70));

    ELSE
        -- PAGAMENTO (sa├¡da de dinheiro)
        
        -- A. SOCIOS E ADIANTAMENTOS
        IF UPPER(v_tx.description) LIKE '%SERGIO CARNEIRO%' 
           OR UPPER(v_tx.description) LIKE '%NAYARA%' 
           OR UPPER(v_tx.description) LIKE '%VICTOR HUGO%' 
           OR UPPER(v_tx.description) LIKE '%SERGIO AUGUSTO%' 
           OR UPPER(v_tx.description) LIKE '%AMPLA CONTABILIDADE%' 
           OR UPPER(v_tx.description) LIKE '%AMPLA SAUDE%' THEN
            
            v_entry_type := 'adiantamento_socio';
            v_credit_account_id := v_bank_account_id;

            IF UPPER(v_tx.description) LIKE '%SERGIO CARNEIRO%' THEN
                SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.3.04.01';
            ELSIF UPPER(v_tx.description) LIKE '%NAYARA%' THEN
                SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.3.04.04';
            ELSIF UPPER(v_tx.description) LIKE '%VICTOR HUGO%' THEN
                SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.3.04.03';
            ELSIF UPPER(v_tx.description) LIKE '%SERGIO AUGUSTO%' THEN
                SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.3.04.05';
            ELSE
                SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.3.04.02';
            END IF;
            v_description := CONCAT('Adiantamento Socio: ', LEFT(v_tx.description, 60));

        -- B. REGRA ESPEC├ìFICA: ECONET / REVISTAS
        ELSIF UPPER(v_tx.description) LIKE '%ECONET%' 
           OR UPPER(v_tx.description) LIKE '%REVISTA%' 
           OR UPPER(v_tx.description) LIKE '%PERIODICO%' THEN
           
            v_entry_type := 'pagamento_despesa';
            v_credit_account_id := v_bank_account_id;
            SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '4.1.2.16';
            v_description := CONCAT('Assinatura/Revista: ', LEFT(v_tx.description, 70));

        -- C. REGRA GERAL: OUTRAS DESPESAS
        ELSE
            v_entry_type := 'pagamento_despesa';
            v_credit_account_id := v_bank_account_id;
            SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '4.1.1.08';
            v_description := CONCAT('Despesa: ', LEFT(v_tx.description, 70));
        END IF;
    END IF;

    -- Create accounting entry
    INSERT INTO accounting_entries (
        description,
        entry_date,
        competence_date,
        entry_type,
        is_draft,
        source_type,
        source_id,
        client_id,
        created_at,
        updated_at
    ) VALUES (
        v_description,
        v_tx.transaction_date,
        v_tx.transaction_date,
        v_entry_type,
        true,
        'bank_transaction',
        p_transaction_id,
        v_client_id,
        NOW(),
        NOW()
    ) RETURNING id INTO v_entry_id;

    -- Create Debit Line
    INSERT INTO accounting_entry_lines (
        entry_id,
        account_id,
        debit,
        credit,
        description
    ) VALUES (
        v_entry_id,
        v_debit_account_id,
        v_tx.amount, 
        0,
        CONCAT('D - ', (SELECT name FROM chart_of_accounts WHERE id = v_debit_account_id))
    );

    -- Create Credit Line
    INSERT INTO accounting_entry_lines (
        entry_id,
        account_id,
        debit,
        credit,
        description
    ) VALUES (
        v_entry_id,
        v_credit_account_id,
        0,
        v_tx.amount,
        CONCAT('C - ', (SELECT name FROM chart_of_accounts WHERE id = v_credit_account_id))
    );

    RETURN v_entry_id;
END;
$$;


ALTER FUNCTION "public"."create_entry_from_bank_transaction"("p_transaction_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_entry_from_invoice"("p_invoice_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_inv RECORD;
    v_entry_id UUID;
    v_receivable_account_id UUID;
    v_revenue_account_id UUID;
    v_client_name VARCHAR;
    v_competence_date DATE;
BEGIN
    -- Get invoice data
    SELECT i.*, c.name as client_name
    INTO v_inv
    FROM invoices i
    LEFT JOIN clients c ON c.id = i.client_id
    WHERE i.id = p_invoice_id;

    IF v_inv IS NULL THEN
        RAISE EXCEPTION 'Invoice not found: %', p_invoice_id;
    END IF;

    -- Check if entry already exists
    SELECT id INTO v_entry_id
    FROM accounting_entries
    WHERE source_type = 'invoice' AND source_id = p_invoice_id;

    IF v_entry_id IS NOT NULL THEN
        RETURN v_entry_id; -- Already exists
    END IF;

    -- Parse competence to date (format: MM/YYYY)
    v_competence_date := TO_DATE('01/' || v_inv.competence, 'DD/MM/YYYY');
    -- Set to last day of competence month
    v_competence_date := (v_competence_date + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

    -- Get accounts
    SELECT id INTO v_receivable_account_id FROM chart_of_accounts WHERE code = '1.1.2.01';
    SELECT id INTO v_revenue_account_id FROM chart_of_accounts WHERE code = '3.1.01.001';

    v_client_name := COALESCE(v_inv.client_name, 'Cliente');

    -- Create accounting entry
    INSERT INTO accounting_entries (
        entry_date,
        competence_date,
        description,
        entry_type,
        total_debit,
        total_credit,
        balanced,
        source_type,
        source_id,
        reference_type,
        reference_id
    ) VALUES (
        v_competence_date,
        v_competence_date,
        CONCAT('Receita Honorarios: ', v_client_name),
        'receita_honorarios',
        v_inv.amount,
        v_inv.amount,
        TRUE,
        'invoice',
        p_invoice_id,
        'invoice',
        p_invoice_id
    )
    RETURNING id INTO v_entry_id;

    -- Create debit line (D - Clientes a Receber)
    INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
    VALUES (v_entry_id, v_receivable_account_id, 'D - Clientes a Receber', v_inv.amount, 0);

    -- Create credit line (C - Receita de Honorarios)
    INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
    VALUES (v_entry_id, v_revenue_account_id, 'C - Receita de Honorarios', 0, v_inv.amount);

    -- Update invoice with journal_entry_id
    UPDATE invoices SET journal_entry_id = v_entry_id WHERE id = p_invoice_id;

    RETURN v_entry_id;
END;
$$;


ALTER FUNCTION "public"."create_entry_from_invoice"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_expense_payment_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_user_id UUID;
  v_entry_id UUID;
  v_bank_id UUID;
  v_payable_id UUID;
BEGIN
  IF NEW.status = 'paid' AND OLD.status != 'paid' THEN
    v_user_id := NEW.created_by;
    
    SELECT id INTO v_bank_id 
    FROM chart_of_accounts 
    WHERE code = '1.1.1.02' AND is_active = true 
    LIMIT 1;
    
    SELECT id INTO v_payable_id 
    FROM chart_of_accounts 
    WHERE code = '2.1.1.08' AND is_active = true 
    LIMIT 1;
    
    IF v_bank_id IS NULL OR v_payable_id IS NULL THEN
      RAISE NOTICE 'Contas cont├íbeis n├úo encontradas para pagamento de despesa';
      RETURN NEW;
    END IF;
    
    INSERT INTO accounting_entries (
      entry_type, description, entry_date, reference_type,
      reference_id, document_number, total_debit, total_credit,
      balanced, created_by
    ) VALUES (
      'payment',
      'Pagamento de Despesa - ' || NEW.description,
      COALESCE(NEW.payment_date, CURRENT_DATE),
      'expense', NEW.id, NEW.id::text,
      NEW.amount, NEW.amount, true, v_user_id
    ) RETURNING id INTO v_entry_id;
    
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_payable_id, NEW.amount, 0, 'Baixa de Contas a Pagar');
    
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_bank_id, 0, NEW.amount, 'Pagamento via Banco');
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_expense_payment_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_expense_provision_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_user_id UUID;
  v_entry_id UUID;
  v_expense_account_id UUID;
  v_payable_id UUID;
BEGIN
  v_user_id := NEW.created_by;
  
  SELECT id INTO v_expense_account_id
  FROM chart_of_accounts
  WHERE type = 'expense' 
    AND is_active = true
    AND is_synthetic = false
  ORDER BY 
    CASE 
      WHEN LOWER(name) LIKE '%' || LOWER(NEW.category) || '%' THEN 1
      ELSE 2
    END, code
  LIMIT 1;
  
  SELECT id INTO v_payable_id 
  FROM chart_of_accounts 
  WHERE code = '2.1.1.08' AND is_active = true 
  LIMIT 1;
  
  IF v_expense_account_id IS NULL OR v_payable_id IS NULL THEN
    RAISE NOTICE 'Contas cont├íbeis n├úo encontradas para provisionamento de despesa';
    RETURN NEW;
  END IF;
  
  INSERT INTO accounting_entries (
    entry_type, description, entry_date, reference_type,
    reference_id, document_number, total_debit, total_credit,
    balanced, created_by
  ) VALUES (
    'provision',
    'Provisionamento de Despesa - ' || NEW.description,
    COALESCE(NEW.competence::date, NEW.due_date),
    'expense', NEW.id, NEW.id::text,
    NEW.amount, NEW.amount, true, v_user_id
  ) RETURNING id INTO v_entry_id;
  
  INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
  VALUES (v_entry_id, v_expense_account_id, NEW.amount, 0, NEW.category || ' - ' || NEW.description);
  
  INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
  VALUES (v_entry_id, v_payable_id, 0, NEW.amount, 'Contas a Pagar');
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_expense_provision_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_invoice_accounting_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_revenue_account_id UUID;
  v_client_account_id UUID;
  v_entry_id UUID;
  v_client_name TEXT;
  v_competence_date DATE;
  v_entry_date DATE;
  v_next_code TEXT;
  v_last_num INT;
BEGIN
  -- Get client name
  SELECT name INTO v_client_name FROM clients WHERE id = NEW.client_id;

  -- Get revenue account (3.1.1.01)
  SELECT id INTO v_revenue_account_id FROM chart_of_accounts WHERE code = '3.1.1.01';
  IF v_revenue_account_id IS NULL THEN
    RAISE WARNING 'Revenue account 3.1.1.01 not found, skipping accounting entry';
    RETURN NEW;
  END IF;

  -- Get or create client account (1.1.2.01.xxx)
  SELECT id INTO v_client_account_id
  FROM chart_of_accounts
  WHERE code LIKE '1.1.2.01.%' AND name ILIKE '%' || v_client_name || '%';

  IF v_client_account_id IS NULL THEN
    -- Find next available client account number
    SELECT COALESCE(MAX(CAST(SPLIT_PART(code, '.', 5) AS INT)), 0) + 1
    INTO v_last_num FROM chart_of_accounts WHERE code LIKE '1.1.2.01.%';

    v_next_code := '1.1.2.01.' || LPAD(v_last_num::TEXT, 3, '0');

    INSERT INTO chart_of_accounts (code, name, account_type, nature, level, is_analytical, is_active, parent_id)
    VALUES (v_next_code, 'Cliente: ' || COALESCE(v_client_name, 'Desconhecido'), 'ATIVO', 'DEVEDORA', 5, true, true,
            (SELECT id FROM chart_of_accounts WHERE code = '1.1.2.01'))
    RETURNING id INTO v_client_account_id;
  END IF;

  -- Determine entry date (use due_date or created_at)
  v_entry_date := COALESCE(NEW.due_date, NEW.created_at::DATE, CURRENT_DATE);

  -- Parse competence (format: MM/YYYY or YYYY-MM)
  IF NEW.competence IS NOT NULL AND NEW.competence ~ '^\d{2}/\d{4}$' THEN
    v_competence_date := (SPLIT_PART(NEW.competence, '/', 2) || '-' || SPLIT_PART(NEW.competence, '/', 1) || '-01')::DATE;
  ELSIF NEW.competence IS NOT NULL AND NEW.competence ~ '^\d{4}-\d{2}$' THEN
    v_competence_date := (NEW.competence || '-01')::DATE;
  ELSE
    v_competence_date := v_entry_date;
  END IF;

  -- Check if accounting entry already exists for this invoice
  IF EXISTS (
    SELECT 1 FROM accounting_entries
    WHERE reference_type = 'invoice' AND reference_id = NEW.id
  ) THEN
    RETURN NEW;
  END IF;

  -- Create accounting entry
  INSERT INTO accounting_entries (
    entry_date, competence_date, entry_type, description,
    reference_type, reference_id, total_debit, total_credit, balanced, created_by
  ) VALUES (
    v_entry_date, v_competence_date, 'receita_honorarios',
    'Honor├írios: ' || COALESCE(v_client_name, 'Cliente') || ' - ' || NEW.competence,
    'invoice', NEW.id, NEW.amount, NEW.amount, true, NEW.created_by
  ) RETURNING id INTO v_entry_id;

  -- Create debit line (Cliente a Receber)
  INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
  VALUES (v_entry_id, v_client_account_id, 'D - ' || v_client_name, NEW.amount, 0);

  -- Create credit line (Receita de Honor├írios)
  INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
  VALUES (v_entry_id, v_revenue_account_id, 'C - Receita Honor├írios', 0, NEW.amount);

  RETURN NEW;

EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the invoice creation
  RAISE WARNING 'Failed to create accounting entry for invoice %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."create_invoice_accounting_entry"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_invoice_accounting_entry"() IS 'Trigger function: creates accounting entry when invoice is inserted';


SET default_tablespace = '';

SET default_table_access_method = "heap";



-- ============================================================================
-- SECAO 4: TABELAS DO SISTEMA
-- ============================================================================
-- 230 tabelas organizadas por modulo:
--
-- CORE/MULTI-TENANT:
--   - tenants: Escritorios/empresas do sistema
--   - tenant_users: Vinculo usuario-tenant
--   - user_roles: Papeis dos usuarios
--
-- CLIENTES:
--   - clients: Cadastro de clientes
--   - client_contacts: Contatos do cliente
--   - contracts/accounting_contracts: Contratos
--   - economic_groups: Grupos economicos
--
-- FINANCEIRO:
--   - invoices: Faturas/honorarios
--   - expenses: Contas a pagar
--   - cash_flow_projections: Projecoes de fluxo de caixa
--
-- CONTABIL:
--   - chart_of_accounts: Plano de contas
--   - accounting_entries/journal_entries: Lancamentos
--   - accounting_entry_lines/items: Partidas
--   - monthly_closings: Fechamentos mensais
--
-- BANCO:
--   - bank_accounts: Contas bancarias
--   - bank_transactions: Transacoes
--   - bank_imports: Importacoes OFX
--   - bank_reconciliation: Conciliacoes
--
-- DEPARTAMENTO PESSOAL:
--   - employees: Funcionarios
--   - payrolls: Folhas de pagamento
--   - payroll_events: Eventos da folha
--   - employee_terminations: Rescisoes
--
-- FISCAL:
--   - nfse: Notas fiscais emitidas
--   - nfse_tomadas: Notas fiscais recebidas
--   - tax_obligations: Obrigacoes fiscais
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "competence" character varying(7),
    "amount" numeric(15,2) NOT NULL,
    "due_date" "date",
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "paid_date" "date",
    "paid_amount" numeric(15,2) DEFAULT 0,
    "boleto_digitable_line" "text",
    "external_charge_id" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "boleto_url" "text",
    "boleto_barcode" "text",
    "pix_qrcode" "text",
    "pix_copy_paste" "text",
    "pix_txid" "text",
    "payment_method" "text",
    "payment_link" "text",
    "created_by" "uuid",
    "revenue_type_id" "uuid",
    "calculation_base" numeric,
    "calculated_amount" numeric,
    "fine_amount" numeric(10,2) DEFAULT 0,
    "interest_amount" numeric(10,2) DEFAULT 0,
    "total_received" numeric(10,2),
    "discount_amount" numeric(10,2) DEFAULT 0,
    "journal_entry_id" "uuid",
    "cnab_reference" "text",
    "reconciled_at" timestamp with time zone,
    "type" "text" DEFAULT 'standard'::"text",
    "description" "text",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "check_invoice_amount_positive" CHECK (("amount" > (0)::numeric))
);


ALTER TABLE "public"."invoices" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoices" IS 'Faturas e honor├írios';



COMMENT ON COLUMN "public"."invoices"."external_charge_id" IS 'ID da cobran├ºa no banco (Cora, Asaas, etc)';



COMMENT ON COLUMN "public"."invoices"."boleto_url" IS 'URL do boleto gerado pelo banco';



COMMENT ON COLUMN "public"."invoices"."pix_qrcode" IS 'QR Code PIX em base64';



COMMENT ON COLUMN "public"."invoices"."pix_copy_paste" IS 'C├│digo PIX copia e cola';



COMMENT ON COLUMN "public"."invoices"."payment_method" IS 'M├®todo de pagamento utilizado';



COMMENT ON COLUMN "public"."invoices"."fine_amount" IS 'Valor de multa por atraso (2% padr├úo)';



COMMENT ON COLUMN "public"."invoices"."interest_amount" IS 'Valor de juros por atraso (1% ao m├¬s padr├úo)';



COMMENT ON COLUMN "public"."invoices"."total_received" IS 'Valor total efetivamente recebido';



COMMENT ON COLUMN "public"."invoices"."discount_amount" IS 'Desconto concedido ao cliente';



CREATE OR REPLACE FUNCTION "public"."create_invoice_accounting_entry_manual"("p_invoice" "public"."invoices") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_revenue_account_id UUID;
  v_client_account_id UUID;
  v_entry_id UUID;
  v_client_name TEXT;
  v_competence_date DATE;
  v_entry_date DATE;
  v_next_code TEXT;
  v_last_num INT;
BEGIN
  SELECT name INTO v_client_name FROM clients WHERE id = p_invoice.client_id;

  SELECT id INTO v_revenue_account_id FROM chart_of_accounts WHERE code = '3.1.1.01';
  IF v_revenue_account_id IS NULL THEN
    RAISE EXCEPTION 'Revenue account 3.1.1.01 not found';
  END IF;

  SELECT id INTO v_client_account_id
  FROM chart_of_accounts
  WHERE code LIKE '1.1.2.01.%' AND name ILIKE '%' || v_client_name || '%';

  IF v_client_account_id IS NULL THEN
    SELECT COALESCE(MAX(CAST(SPLIT_PART(code, '.', 5) AS INT)), 0) + 1
    INTO v_last_num FROM chart_of_accounts WHERE code LIKE '1.1.2.01.%';
    v_next_code := '1.1.2.01.' || LPAD(v_last_num::TEXT, 3, '0');

    INSERT INTO chart_of_accounts (code, name, account_type, nature, level, is_analytical, is_active, parent_id)
    VALUES (v_next_code, 'Cliente: ' || COALESCE(v_client_name, 'Desconhecido'), 'ATIVO', 'DEVEDORA', 5, true, true,
            (SELECT id FROM chart_of_accounts WHERE code = '1.1.2.01'))
    RETURNING id INTO v_client_account_id;
  END IF;

  v_entry_date := COALESCE(p_invoice.due_date, p_invoice.created_at::DATE, CURRENT_DATE);

  IF p_invoice.competence IS NOT NULL AND p_invoice.competence ~ '^\d{2}/\d{4}$' THEN
    v_competence_date := (SPLIT_PART(p_invoice.competence, '/', 2) || '-' || SPLIT_PART(p_invoice.competence, '/', 1) || '-01')::DATE;
  ELSE
    v_competence_date := v_entry_date;
  END IF;

  IF EXISTS (SELECT 1 FROM accounting_entries WHERE reference_type = 'invoice' AND reference_id = p_invoice.id) THEN
    RETURN;
  END IF;

  INSERT INTO accounting_entries (entry_date, competence_date, entry_type, description, reference_type, reference_id, total_debit, total_credit, balanced, created_by)
  VALUES (v_entry_date, v_competence_date, 'receita_honorarios', 
          'Honor├írios: ' || COALESCE(v_client_name, 'Cliente') || ' - ' || p_invoice.competence, 
          'invoice', p_invoice.id, p_invoice.amount, p_invoice.amount, true, p_invoice.created_by)
  RETURNING id INTO v_entry_id;

  INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
  VALUES (v_entry_id, v_client_account_id, 'D - ' || v_client_name, p_invoice.amount, 0),
         (v_entry_id, v_revenue_account_id, 'C - Receita', 0, p_invoice.amount);

  INSERT INTO client_ledger (client_id, transaction_date, description, debit, credit, balance, reference_type, reference_id, created_by)
  VALUES (p_invoice.client_id, v_entry_date, 'Honor├írios ' || p_invoice.competence, p_invoice.amount, 0, 0, 'invoice', p_invoice.id, p_invoice.created_by);
  
  UPDATE invoices SET journal_entry_id = v_entry_id WHERE id = p_invoice.id;
END;
$_$;


ALTER FUNCTION "public"."create_invoice_accounting_entry_manual"("p_invoice" "public"."invoices") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_invoice_payment_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_user_id UUID;
  v_entry_id UUID;
  v_bank_id UUID;
  v_account_receivable_id UUID;
BEGIN
  IF NEW.status = 'paid' AND OLD.status != 'paid' THEN
    v_user_id := NEW.created_by;
    
    SELECT id INTO v_bank_id 
    FROM chart_of_accounts 
    WHERE code = '1.1.1.02' AND is_active = true 
    LIMIT 1;
    
    SELECT id INTO v_account_receivable_id 
    FROM chart_of_accounts 
    WHERE code = '1.1.2.02' AND is_active = true 
    LIMIT 1;
    
    IF v_bank_id IS NULL OR v_account_receivable_id IS NULL THEN
      RAISE NOTICE 'Contas cont├íbeis n├úo encontradas para baixa de receita';
      RETURN NEW;
    END IF;
    
    INSERT INTO accounting_entries (
      entry_type, description, entry_date, reference_type,
      reference_id, document_number, total_debit, total_credit,
      balanced, created_by
    ) VALUES (
      'payment',
      'Recebimento de Invoice ' || NEW.id,
      COALESCE(NEW.payment_date, CURRENT_DATE),
      'invoice', NEW.id, NEW.id::text,
      NEW.amount, NEW.amount, true, v_user_id
    ) RETURNING id INTO v_entry_id;
    
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_bank_id, NEW.amount, 0, 'Recebimento via Banco');
    
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_account_receivable_id, 0, NEW.amount, 'Baixa de Honor├írios a Receber');
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_invoice_payment_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_invoice_provision_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_user_id UUID;
  v_entry_id UUID;
  v_account_receivable_id UUID;
  v_revenue_id UUID;
BEGIN
  v_user_id := NEW.created_by;
  
  SELECT id INTO v_account_receivable_id 
  FROM chart_of_accounts 
  WHERE code = '1.1.2.02' AND is_active = true 
  LIMIT 1;
  
  SELECT id INTO v_revenue_id 
  FROM chart_of_accounts 
  WHERE code = '4.1.1' AND is_active = true 
  LIMIT 1;
  
  IF v_account_receivable_id IS NULL OR v_revenue_id IS NULL THEN
    RAISE NOTICE 'Contas cont├íbeis n├úo encontradas para provisionamento de receita';
    RETURN NEW;
  END IF;
  
  INSERT INTO accounting_entries (
    entry_type, description, entry_date, reference_type,
    reference_id, document_number, total_debit, total_credit,
    balanced, created_by
  ) VALUES (
    'provision',
    'Provisionamento de Receita - Invoice ' || NEW.id,
    COALESCE(NEW.competence::date, NEW.due_date),
    'invoice', NEW.id, NEW.id::text,
    NEW.amount, NEW.amount, true, v_user_id
  ) RETURNING id INTO v_entry_id;
  
  INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
  VALUES (v_entry_id, v_account_receivable_id, NEW.amount, 0, 'Honor├írios a Receber');
  
  INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
  VALUES (v_entry_id, v_revenue_id, 0, NEW.amount, 'Receita de Honor├írios Cont├íbeis');
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_invoice_provision_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_entry_id UUID;
BEGIN
  -- Criar o lan├ºamento principal (cabe├ºalho do di├írio)
  INSERT INTO accounting_entries (
    entry_date,
    competence_date,
    entry_type,
    description,
    reference_type,
    reference_id,
    total_debit,
    total_credit,
    balanced,
    created_by
  ) VALUES (
    p_entry_date,
    p_competence_date,
    p_entry_type,
    p_description,
    p_reference_type,
    p_reference_id,
    p_amount,
    p_amount,
    true,
    p_created_by
  )
  RETURNING id INTO v_entry_id;

  -- Criar linha de d├®bito
  INSERT INTO accounting_entry_lines (
    entry_id,
    account_id,
    description,
    debit,
    credit
  ) VALUES (
    v_entry_id,
    p_debit_account_id,
    'D - ' || p_description,
    p_amount,
    0
  );

  -- Criar linha de cr├®dito
  INSERT INTO accounting_entry_lines (
    entry_id,
    account_id,
    description,
    debit,
    credit
  ) VALUES (
    v_entry_id,
    p_credit_account_id,
    'C - ' || p_description,
    0,
    p_amount
  );

  RETURN v_entry_id;
END;
$$;


ALTER FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") IS 'Cria lan├ºamento no Livro Di├írio com d├®bito e cr├®dito';



CREATE OR REPLACE FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text" DEFAULT 'viewer'::"text", "p_employee_id" "uuid" DEFAULT NULL::"uuid", "p_phone" "text" DEFAULT NULL::"text") RETURNS TABLE("user_id" "uuid", "temp_password" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_password TEXT;
  v_user_id UUID;
BEGIN
  -- Gerar senha tempor├íria
  v_password := generate_random_password(8);

  -- Inserir usu├írio
  INSERT INTO system_users (name, email, role, employee_id, phone, temp_password, must_change_password)
  VALUES (p_name, p_email, p_role, p_employee_id, p_phone, v_password, true)
  RETURNING id INTO v_user_id;

  RETURN QUERY SELECT v_user_id, v_password;
END;
$$;


ALTER FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text", "p_employee_id" "uuid", "p_phone" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text", "p_employee_id" "uuid", "p_phone" "text") IS 'Cria usu├írio do sistema com senha tempor├íria gerada';



CREATE OR REPLACE FUNCTION "public"."create_tenant_trigger"("table_name" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- Verifica se a tabela existe no esquema 'public'
    IF EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = table_name) THEN
        -- Verifica se o gatilho j├í existe para n├úo duplicar
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_set_tenant_' || table_name) THEN
            EXECUTE format('CREATE TRIGGER trg_set_tenant_%I BEFORE INSERT ON public.%I FOR EACH ROW EXECUTE FUNCTION public.fn_auto_set_tenant_id();', table_name, table_name);
            RAISE NOTICE 'Vacina aplicada na tabela: %', table_name;
        ELSE
            RAISE NOTICE 'Tabela % j├í estava vacinada.', table_name;
        END IF;
    ELSE
        RAISE NOTICE 'Tabela % n├úo existe no seu banco (pulando).', table_name;
    END IF;
END;
$$;


ALTER FUNCTION "public"."create_tenant_trigger"("table_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date" DEFAULT NULL::"date", "p_data_fim" "date" DEFAULT NULL::"date") RETURNS TABLE("receitas" numeric, "despesas" numeric, "lucro" numeric, "saldo_bancos" numeric, "a_receber" numeric, "a_pagar" numeric, "clientes_inadimplentes" integer, "total_inadimplencia" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_inicio DATE; v_fim DATE; v_my_tenant UUID;
  v_receitas NUMERIC; v_despesas NUMERIC; v_saldo_bancos NUMERIC;
  v_a_receber NUMERIC; v_a_pagar NUMERIC; v_inadimplentes INTEGER; v_total_inad NUMERIC;
BEGIN
  v_my_tenant := public.get_my_tenant_id();
  v_inicio := COALESCE(p_data_inicio, date_trunc('month', CURRENT_DATE)::DATE);
  v_fim := COALESCE(p_data_fim, CURRENT_DATE);
  
  -- Receitas
  SELECT COALESCE(SUM(ael.credit), 0) INTO v_receitas FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE ae.entry_date BETWEEN v_inicio AND v_fim AND coa.code LIKE '3.%' AND ael.credit > 0 AND ae.tenant_id = v_my_tenant;
  
  -- Despesas
  SELECT COALESCE(SUM(ael.debit), 0) INTO v_despesas FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE ae.entry_date BETWEEN v_inicio AND v_fim AND coa.code LIKE '4.%' AND ael.debit > 0 AND ae.tenant_id = v_my_tenant;
  
  -- Saldos e Contas
  SELECT COALESCE(SUM(ael.debit), 0) - COALESCE(SUM(ael.credit), 0) INTO v_saldo_bancos FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '1.1.1.%' AND ae.tenant_id = v_my_tenant;
  
  SELECT COALESCE(SUM(ael.debit), 0) - COALESCE(SUM(ael.credit), 0) INTO v_a_receber FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id JOIN chart_of_accounts coa ON coa.id = ael.account_id
  WHERE coa.code LIKE '1.1.2.01.%' AND ae.tenant_id = v_my_tenant;
  
  SELECT COALESCE(SUM(amount), 0) INTO v_a_pagar FROM expenses WHERE status = 'pending' AND tenant_id = v_my_tenant;
  
  -- Inadimpl├¬ncia
  SELECT COUNT(DISTINCT client_id), COALESCE(SUM(amount), 0) INTO v_inadimplentes, v_total_inad
  FROM invoices WHERE status = 'overdue' AND tenant_id = v_my_tenant;

  RETURN QUERY SELECT v_receitas, v_despesas, v_receitas - v_despesas, v_saldo_bancos, GREATEST(0, v_a_receber), v_a_pagar, v_inadimplentes, v_total_inad;
END;
$$;


ALTER FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date", "p_data_fim" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date", "p_data_fim" "date") IS 'Retorna vis├úo geral financeira (receitas, despesas, saldos)';



CREATE OR REPLACE FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_deleted INTEGER := 0;
BEGIN
  -- Deletar linhas primeiro (FK constraint)
  DELETE FROM accounting_entry_lines
  WHERE entry_id IN (
    SELECT id FROM accounting_entries
    WHERE reference_type = p_reference_type
      AND reference_id = p_reference_id
  );

  -- Deletar entradas
  DELETE FROM accounting_entries
  WHERE reference_type = p_reference_type
    AND reference_id = p_reference_id;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$;


ALTER FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") IS 'Remove lan├ºamentos cont├íbeis por refer├¬ncia';



CREATE OR REPLACE FUNCTION "public"."distribute_plr"("p_program_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_program RECORD;
    v_employee RECORD;
    v_total_scores DECIMAL;
    v_share_count INTEGER := 0;
BEGIN
    -- Buscar programa
    SELECT * INTO v_program FROM plr_programs WHERE id = p_program_id;

    -- Calcular para cada funcion├írio eleg├¡vel
    FOR v_employee IN
        SELECT id FROM employees WHERE is_active AND contract_type = 'clt'
    LOOP
        PERFORM calculate_employee_plr(p_program_id, v_employee.id);
        v_share_count := v_share_count + 1;
    END LOOP;

    -- Calcular soma total dos scores
    SELECT SUM(total_score) INTO v_total_scores
    FROM plr_employee_share WHERE program_id = p_program_id;

    -- Distribuir proporcionalmente
    UPDATE plr_employee_share SET
        share_percent = total_score / NULLIF(v_total_scores, 0),
        base_value = (total_score / NULLIF(v_total_scores, 0)) * COALESCE(v_program.plr_pool_value, 0),
        final_value = (total_score / NULLIF(v_total_scores, 0)) * COALESCE(v_program.plr_pool_value, 0) + COALESCE(bonus_value, 0)
    WHERE program_id = p_program_id;

    -- Atualizar status do programa
    UPDATE plr_programs SET status = 'calculating' WHERE id = p_program_id;

    RETURN jsonb_build_object(
        'success', true,
        'employees_calculated', v_share_count,
        'total_scores', v_total_scores,
        'pool_value', v_program.plr_pool_value,
        'message', 'Sra. Marketing: PLR calculada para ' || v_share_count || ' funcion├írios!'
    );
END;
$$;


ALTER FUNCTION "public"."distribute_plr"("p_program_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fail_ai_validation"("p_queue_id" "uuid", "p_error" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_attempts INTEGER;
  v_max_attempts INTEGER;
BEGIN
  -- Buscar tentativas
  SELECT attempts, max_attempts INTO v_attempts, v_max_attempts
  FROM ai_validation_queue WHERE id = p_queue_id;

  -- Atualizar status baseado nas tentativas
  UPDATE ai_validation_queue SET
    status = CASE WHEN v_attempts >= v_max_attempts THEN 'failed' ELSE 'retry' END,
    last_error = p_error,
    completed_at = CASE WHEN v_attempts >= v_max_attempts THEN now() ELSE NULL END
  WHERE id = p_queue_id;
END;
$$;


ALTER FUNCTION "public"."fail_ai_validation"("p_queue_id" "uuid", "p_error" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."find_known_pattern"("description" "text", "txn_type" "text", "amount" numeric) RETURNS TABLE("pattern_id" "uuid", "category" "text", "debit_account" "text", "credit_account" "text", "entity_name" "text", "entity_relationship" "text", "confidence" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  normalized TEXT;
BEGIN
  normalized := normalize_for_matching(description);

  RETURN QUERY
  SELECT
    p.id AS pattern_id,
    p.category,
    p.debit_account_code AS debit_account,
    p.credit_account_code AS credit_account,
    e.display_name AS entity_name,
    e.relationship AS entity_relationship,
    p.confidence
  FROM ai_classification_patterns p
  LEFT JOIN ai_known_entities e ON p.entity_id = e.id
  WHERE p.is_active = true
    AND (p.transaction_type = 'ANY' OR p.transaction_type = txn_type)
    AND (p.min_amount IS NULL OR amount >= p.min_amount)
    AND (p.max_amount IS NULL OR amount <= p.max_amount)
    AND (
      (p.pattern_type = 'literal' AND normalized = normalize_for_matching(p.transaction_pattern))
      OR (p.pattern_type = 'contains' AND normalized LIKE '%' || normalize_for_matching(p.transaction_pattern) || '%')
      OR (p.pattern_type = 'regex' AND normalized ~ p.transaction_pattern)
    )
  ORDER BY p.priority DESC, p.usage_count DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."find_known_pattern"("description" "text", "txn_type" "text", "amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_updated INTEGER := 0;
    v_comp_month INTEGER;
    v_comp_year INTEGER;
BEGIN
    -- Extrair m├¬s e ano da compet├¬ncia (formato MM/YYYY)
    v_comp_month := CAST(SPLIT_PART(p_competence, '/', 1) AS INTEGER);
    v_comp_year := CAST(SPLIT_PART(p_competence, '/', 2) AS INTEGER);

    -- Atualizar invoices onde o vencimento est├í no mesmo m├¬s da compet├¬ncia
    UPDATE invoices
    SET due_date = (due_date + INTERVAL '1 month')::date
    WHERE competence = p_competence
      AND EXTRACT(MONTH FROM due_date) = v_comp_month
      AND EXTRACT(YEAR FROM due_date) = v_comp_year
      AND status = 'pending';

    GET DIAGNOSTICS v_updated = ROW_COUNT;

    RETURN v_updated;
END;
$$;


ALTER FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") IS 'Corrige datas de vencimento de honor├írios para o m├¬s seguinte ├á compet├¬ncia';



CREATE OR REPLACE FUNCTION "public"."fix_pro_bono_classification"() RETURNS TABLE("updated_to_pro_bono" integer, "updated_to_regular" integer, "errors" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_to_pro_bono INT := 0;
  v_to_regular INT := 0;
  v_errors INT := 0;
  v_client RECORD;
BEGIN
  -- Desabilitar temporariamente triggers de valida├º├úo
  SET session_replication_role = replica;

  -- Clientes que deveriam ser Pro-Bono
  FOR v_client IN
    SELECT id, name FROM clients
    WHERE (monthly_fee IS NULL OR monthly_fee = 0)
      AND is_pro_bono = false
      AND is_active = true
      AND NOT COALESCE(is_barter, false)
  LOOP
    BEGIN
      UPDATE clients SET
        is_pro_bono = true,
        pro_bono_start_date = COALESCE(pro_bono_start_date, created_at::DATE),
        pro_bono_reason = COALESCE(pro_bono_reason, 'Classificado automaticamente: honor├írio zerado'),
        updated_at = NOW()
      WHERE id = v_client.id;
      v_to_pro_bono := v_to_pro_bono + 1;
    EXCEPTION WHEN OTHERS THEN
      v_errors := v_errors + 1;
    END;
  END LOOP;

  -- Clientes que n├úo deveriam ser Pro-Bono
  FOR v_client IN
    SELECT id, name FROM clients
    WHERE monthly_fee > 0
      AND is_pro_bono = true
      AND is_active = true
  LOOP
    BEGIN
      UPDATE clients SET
        is_pro_bono = false,
        pro_bono_end_date = COALESCE(pro_bono_end_date, CURRENT_DATE),
        updated_at = NOW()
      WHERE id = v_client.id;
      v_to_regular := v_to_regular + 1;
    EXCEPTION WHEN OTHERS THEN
      v_errors := v_errors + 1;
    END;
  END LOOP;

  -- Reabilitar triggers
  SET session_replication_role = DEFAULT;

  updated_to_pro_bono := v_to_pro_bono;
  updated_to_regular := v_to_regular;
  errors := v_errors;
  RETURN NEXT;
END;
$$;


ALTER FUNCTION "public"."fix_pro_bono_classification"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."fix_pro_bono_classification"() IS 'Corrige classifica├º├úo Pro-Bono de clientes existentes. Execute: SELECT * FROM fix_pro_bono_classification();';



CREATE OR REPLACE FUNCTION "public"."fn_auto_accounting_expense_provision"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_debit_account_id UUID; -- Despesa (Natureza)
  v_credit_account_id UUID; -- Fornecedor (Passivo)
  v_entry_id UUID;
  v_history TEXT;
BEGIN
  -- Verificar duplicidade
  PERFORM 1 FROM accounting_entries 
  WHERE document_number = NEW.id::TEXT AND entry_type = 'PROVISAO_DESPESA';
  IF FOUND THEN RETURN NEW; END IF;

  -- 1. Identificar Conta de D├®bito (Natureza da Despesa)
  v_debit_account_id := NEW.chart_account_id;
  
  -- Se n├úo informada, tentar mapear pela categoria (Texto) - Legado
  IF v_debit_account_id IS NULL THEN
     -- Exemplo simples de mapeamento, ideal ├® o frontend passar o ID
     CASE NEW.category
       WHEN 'Aluguel' THEN SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '4.1.01';
       WHEN 'Energia' THEN SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '4.1.03';
       ELSE 
         -- Fallback para "Outras Despesas Administrativas"
         SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '4.1.12';
     END CASE;
  END IF;

  -- 2. Identificar Conta de Cr├®dito (Fornecedor)
  IF NEW.supplier_id IS NOT NULL THEN
     SELECT account_id INTO v_credit_account_id FROM suppliers WHERE id = NEW.supplier_id;
  END IF;

  -- Se n├úo tem fornecedor espec├¡fico, usa "Fornecedores Diversos" (criar se n├úo existir ou usar gen├®rica se permitido)
  -- Como a ordem ├® "evitar gen├®ricas", vamos for├ºar o uso de fornecedor. Mas precisamos de um fallback para n├úo quebrar.
  IF v_credit_account_id IS NULL THEN
     -- Fallback: Fornecedores Nacionais (Grupo) -> Isso vai falhar no trigger de seguran├ºa!
     -- Precisamos de uma conta "Fornecedor N├úo Identificado" anal├¡tica para transi├º├úo se necess├írio
     -- Ou buscar pela descri├º├úo.
     -- Por seguran├ºa Fase 2.5, vamos logar aviso e usar conta transit├│ria ou gen├®rica ANALITICA
     -- Criando conta gen├®rica anal├¡tica '2.1.1.01.9999 - Fornecedores Diversos' se n├úo existir
     PERFORM 1; -- Placeholder
  END IF;

  -- Se ainda nulo, aborta contabiliza├º├úo autom├ítica (melhor n├úo lan├ºar do que lan├ºar errado gen├®rico)
  IF v_debit_account_id IS NULL OR v_credit_account_id IS NULL THEN
     RETURN NEW; 
  END IF;

  v_history := 'Provis├úo Despesa - ' || NEW.description;

  INSERT INTO accounting_entries (
    entry_date, competence_date, description, history, entry_type, document_type, document_number, total_debit, total_credit, created_by
  ) VALUES (
    NEW.created_at::DATE, NEW.due_date, 
    'Provis├úo de Despesa', v_history, 'PROVISAO_DESPESA', 'FATURA_FORNECEDOR', NEW.id::TEXT, NEW.amount, NEW.amount, NEW.created_by
  ) RETURNING id INTO v_entry_id;

  -- D├ëBITO: Despesa (Natureza)
  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history) 
  VALUES (v_entry_id, v_debit_account_id, NEW.amount, 0, v_history);

  -- CR├ëDITO: Fornecedor (Passivo)
  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history) 
  VALUES (v_entry_id, v_credit_account_id, 0, NEW.amount, v_history);

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_accounting_expense_provision"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_accounting_invoice_provision"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_credit_account_id UUID; -- Receita
  v_debit_account_id UUID;  -- Clientes (Espec├¡fica)
  v_entry_id UUID;
  v_history TEXT;
BEGIN
  -- Verifica duplicidade
  PERFORM 1 FROM accounting_entries 
  WHERE invoice_id = NEW.id AND entry_type = 'PROVISAO_RECEITA';
  IF FOUND THEN RETURN NEW; END IF;

  -- 1. Identificar Contas
  -- Receita de Servi├ºos (3.1.1.01)
  SELECT id INTO v_credit_account_id FROM chart_of_accounts WHERE code = '3.1.1.01';
  
  -- Busca a CONTA DO CLIENTE na tabela clients
  SELECT account_id INTO v_debit_account_id FROM clients WHERE id = NEW.client_id;
  
  -- Se o cliente n├úo tiver conta, tenta fallback para a gen├®rica (mas o ideal ├® ter)
  IF v_debit_account_id IS NULL THEN
     SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.2.01';
  END IF;

  IF v_credit_account_id IS NULL OR v_debit_account_id IS NULL THEN
    RAISE WARNING 'Contas cont├íbeis n├úo encontradas para Invoice %', NEW.id;
    RETURN NEW;
  END IF;

  v_history := 'Provis├úo de Honor├írios - ' || COALESCE(NEW.description, 'Servi├ºos Cont├íbeis') || ' - Comp: ' || COALESCE(NEW.competence, TO_CHAR(NEW.due_date, 'MM/YYYY'));

  INSERT INTO accounting_entries (
    entry_date, competence_date, description, history, entry_type, document_type, invoice_id, total_debit, total_credit, created_by
  ) VALUES (
    NEW.created_at::DATE, COALESCE(TO_DATE(NEW.competence, 'MM/YYYY'), NEW.due_date), 
    'Provis├úo de Receita', v_history, 'PROVISAO_RECEITA', 'FATURA', NEW.id, NEW.amount, NEW.amount, NEW.created_by
  ) RETURNING id INTO v_entry_id;

  -- D├ëBITO: Conta ESPEC├ìFICA do Cliente
  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_debit_account_id, NEW.amount, 0, v_history, NEW.client_id);

  -- CR├ëDITO: Receita
  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_credit_account_id, 0, NEW.amount, v_history, NEW.client_id);

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_accounting_invoice_provision"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_accounting_opening_balance"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_debit_account_id UUID;  -- Clientes (Espec├¡fica)
  v_credit_account_id UUID; -- Ajustes (5.3.02.02)
  v_entry_id UUID;
  v_history TEXT;
BEGIN
  -- Busca Conta do Cliente
  SELECT account_id INTO v_debit_account_id FROM clients WHERE id = NEW.client_id;
  
  -- Fallback Gen├®rico
  IF v_debit_account_id IS NULL THEN
    SELECT id INTO v_debit_account_id FROM chart_of_accounts WHERE code = '1.1.2.01';
  END IF;

  SELECT id INTO v_credit_account_id FROM chart_of_accounts WHERE code = '5.3.02.02';
  IF v_credit_account_id IS NULL THEN
     SELECT id INTO v_credit_account_id FROM chart_of_accounts WHERE code = '5.3.02'; 
  END IF;

  v_history := 'Saldo Inicial Migra├º├úo - Comp: ' || NEW.competence || ' - ' || COALESCE(NEW.description, '');

  INSERT INTO accounting_entries (
    entry_date, competence_date, description, history, entry_type, document_type, total_debit, total_credit, created_by
  ) VALUES (
    '2025-01-01', TO_DATE(NEW.competence, 'MM/YYYY'), 'Implanta├º├úo de Saldo', v_history, 'SALDO_ABERTURA', 'MEMORANDO', NEW.amount, NEW.amount, NEW.created_by
  ) RETURNING id INTO v_entry_id;

  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_debit_account_id, NEW.amount, 0, v_history, NEW.client_id);

  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_credit_account_id, 0, NEW.amount, v_history, NEW.client_id);

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_accounting_opening_balance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_accounting_reconciliation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_bank_account_id UUID;
  v_bank_chart_account_id UUID;
  v_client_account_id UUID;     -- Conta Clientes (Espec├¡fica)
  v_amount DECIMAL;
  v_date DATE;
  v_history TEXT;
  v_entry_id UUID;
  v_client_id UUID;
  v_invoice_id UUID;
BEGIN
  SELECT bank_account_id, amount, transaction_date, description 
  INTO v_bank_account_id, v_amount, v_date, v_history
  FROM bank_transactions WHERE id = NEW.transaction_id;

  IF NEW.invoice_id IS NOT NULL THEN
     SELECT client_id INTO v_client_id FROM invoices WHERE id = NEW.invoice_id;
     v_invoice_id := NEW.invoice_id;
  END IF;

  -- Banco (Fallback Sicredi)
  SELECT id INTO v_bank_chart_account_id FROM chart_of_accounts WHERE code = '1.1.1.05'; 

  -- Conta Clientes: Busca a espec├¡fica do cliente
  IF v_client_id IS NOT NULL THEN
     SELECT account_id INTO v_client_account_id FROM clients WHERE id = v_client_id;
  END IF;

  -- Fallback se n├úo achou cliente ou conta do cliente
  IF v_client_account_id IS NULL THEN
     SELECT id INTO v_client_account_id FROM chart_of_accounts WHERE code = '1.1.2.01';
  END IF;

  v_history := 'Recebimento Fatura - ' || v_history;

  INSERT INTO accounting_entries (
    entry_date, competence_date, description, history, entry_type, document_type, transaction_id, invoice_id, total_debit, total_credit
  ) VALUES (
    v_date, v_date, 'Recebimento de Cliente', v_history, 'RECEBIMENTO', 'EXTRATO', NEW.transaction_id, v_invoice_id, v_amount, v_amount
  ) RETURNING id INTO v_entry_id;

  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_bank_chart_account_id, v_amount, 0, v_history, v_client_id);

  INSERT INTO accounting_entry_items (entry_id, account_id, debit, credit, history, client_id) 
  VALUES (v_entry_id, v_client_account_id, 0, v_amount, v_history, v_client_id);

  UPDATE bank_reconciliation SET accounting_entry_id = v_entry_id WHERE id = NEW.id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_accounting_reconciliation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_contabilizar_invoice"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_account_debit UUID;
    v_account_credit UUID;
    v_entry_id UUID;
    v_client_name TEXT;
    v_source_hash TEXT;
BEGIN
    -- Busca conta de cliente (1.1.2.01)
    SELECT id INTO v_account_debit 
    FROM chart_of_accounts 
    WHERE code = '1.1.2.01' LIMIT 1;

    -- Busca conta de Receita de Honor├írios (3.1.1.01 - Exemplo, ajustar se necess├írio)
    -- Vou buscar por nome 'Receita de Honor├írios' ou c├│digo comum de receita
    SELECT id INTO v_account_credit
    FROM chart_of_accounts
    WHERE name ILIKE '%Honor├írios%' AND account_type = 'Revenue' LIMIT 1;
    
    -- Se n├úo achar receita espec├¡fica, pega gen├®rica
    IF v_account_credit IS NULL THEN
        SELECT id INTO v_account_credit
        FROM chart_of_accounts
        WHERE code LIKE '3.1%' AND account_type = 'Revenue' LIMIT 1;
    END IF;

    IF v_account_debit IS NULL OR v_account_credit IS NULL THEN
         RAISE WARNING 'Contas cont├íbeis n├úo encontradas para blindagem de invoice.';
         RETURN NEW;
    END IF;

    SELECT name INTO v_client_name FROM clients WHERE id = NEW.client_id;
    v_source_hash := encode(digest(NEW.id::text || now()::text, 'sha256'), 'hex');

    INSERT INTO accounting_entries (
        entry_date,
        competence_date,
        description,
        history,
        entry_type,
        document_type,
        reference_type,
        reference_id,
        total_debit,
        total_credit,
        balanced,
        source_type,
        source_id,
        source_hash,
        created_by
    ) VALUES (
        NEW.created_at::date,
        to_date(NEW.competence, 'MM/YYYY'),
        'Honor├írios - ' || v_client_name,
        'Emiss├úo de Nota (Blindagem)',
        'revenue',
        'invoice',
        'invoice',
        NEW.id,
        NEW.amount,
        NEW.amount,
        TRUE,
        'invoices',
        NEW.id,
        v_source_hash,
        NEW.created_by
    ) RETURNING id INTO v_entry_id;

    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_account_debit, NEW.amount, 0, 'D├®bito: Clientes');

    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_account_credit, 0, NEW.amount, 'Cr├®dito: Receita Honor├írios');

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_contabilizar_invoice"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_contabilizar_saldo_abertura"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_account_debit UUID;
    v_account_credit UUID;
    v_entry_id UUID;
    v_client_name TEXT;
    v_source_hash TEXT;
BEGIN
    -- Busca conta de cliente (1.1.2.01)
    SELECT id INTO v_account_debit 
    FROM chart_of_accounts 
    WHERE code = '1.1.2.01' LIMIT 1;

    -- Busca conta de contrapartida (Saldo Abertura - 5.3.02.02)
    SELECT id INTO v_account_credit
    FROM chart_of_accounts
    WHERE code = '5.3.02.02' LIMIT 1;

    -- Fallback se n├úo achar
    IF v_account_debit IS NULL OR v_account_credit IS NULL THEN
        RAISE WARNING 'Contas cont├íbeis n├úo encontradas para blindagem de saldo abertura.';
        RETURN NEW;
    END IF;

    -- Busca nome do cliente
    SELECT name INTO v_client_name FROM clients WHERE id = NEW.client_id;

    -- Gera Hash ├Ünico (Certid├úo de Nascimento)
    v_source_hash := encode(digest(NEW.id::text || now()::text, 'sha256'), 'hex');

    -- Cria o lan├ºamento (Entry)
    INSERT INTO accounting_entries (
        entry_date,
        competence_date,
        description,
        history,
        entry_type,
        document_type,
        reference_type,
        reference_id,
        total_debit,
        total_credit,
        balanced,
        source_type,
        source_id,
        source_hash,
        created_by
    ) VALUES (
        COALESCE(NEW.due_date, '2025-01-01'), -- Data do lan├ºamento
        to_date(NEW.competence, 'MM/YYYY'),   -- Compet├¬ncia
        'Saldo Abertura - ' || v_client_name,
        'Importa├º├úo Autom├ítica via Trigger (Blindagem)',
        'opening_balance',
        'opening_balance',
        'client_opening_balance',
        NEW.id,
        NEW.amount,
        NEW.amount,
        TRUE,
        'client_opening_balance',
        NEW.id,
        v_source_hash,
        NEW.created_by
    ) RETURNING id INTO v_entry_id;

    -- Cria as Linhas (Lines)
    -- D├®bito
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_account_debit, NEW.amount, 0, 'D├®bito: ' || v_client_name);

    -- Cr├®dito
    INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
    VALUES (v_entry_id, v_account_credit, 0, NEW.amount, 'Cr├®dito: Saldo de Abertura');

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_contabilizar_saldo_abertura"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_auto_set_tenant_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Se o tenant_id n├úo foi enviado (est├í vazio), preenche com o ID do usu├írio logado
  IF NEW.tenant_id IS NULL THEN
    NEW.tenant_id := public.get_my_tenant_id();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_auto_set_tenant_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_create_client_account"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_parent_id UUID;
  v_parent_code VARCHAR;
  v_next_code VARCHAR;
  v_new_account_id UUID;
  v_count INTEGER;
BEGIN
  -- Se j├í tem conta vinculada, n├úo faz nada
  IF NEW.account_id IS NOT NULL THEN
    RETURN NEW;
  END IF;

  -- 1. Busca o pai (Grupo Clientes a Receber - 1.1.2.01) DO MESMO TENANT
  SELECT id, code INTO v_parent_id, v_parent_code 
  FROM chart_of_accounts 
  WHERE code = '1.1.2.01'
  AND tenant_id = NEW.tenant_id; -- Adicionei essa prote├º├úo

  -- Se n├úo achar a conta pai, avisa e segue a vida (n├úo trava o cadastro)
  IF v_parent_id IS NULL THEN
      RAISE WARNING 'Conta pai Clientes a Receber (1.1.2.01) n├úo encontrada para este Tenant.';
      RETURN NEW;
  END IF;

  -- 2. Gera o pr├│ximo c├│digo sequencial APENAS DENTRO DESTE GRUPO
  SELECT COUNT(*) INTO v_count 
  FROM chart_of_accounts 
  WHERE parent_id = v_parent_id;
  
  v_next_code := v_parent_code || '.' || LPAD((v_count + 1)::TEXT, 4, '0');

  -- 3. Cria a conta no Plano de Contas (AGORA COM TENANT_ID)
  INSERT INTO chart_of_accounts (
    code, 
    name, 
    account_type, 
    nature, 
    level, 
    is_analytical, 
    parent_id,
    sped_referencial_code,
    tenant_id -- <--- Coluna adicionada
  ) VALUES (
    v_next_code,
    NEW.name,
    'ATIVO',
    'DEVEDORA',
    5,
    true,
    v_parent_id,
    '1.01.02.01.00',
    NEW.tenant_id -- <--- Valor adicionado (pega do cliente novo)
  ) RETURNING id INTO v_new_account_id;

  -- Atualiza o cliente com o ID da nova conta
  NEW.account_id := v_new_account_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_create_client_account"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_create_supplier_account"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_parent_id UUID;
  v_parent_code VARCHAR;
  v_next_code VARCHAR;
  v_new_account_id UUID;
  v_count INTEGER;
BEGIN
  IF NEW.account_id IS NOT NULL THEN RETURN NEW; END IF;

  -- Busca pai: Fornecedores Nacionais (2.1.1.01)
  SELECT id, code INTO v_parent_id, v_parent_code FROM chart_of_accounts WHERE code = '2.1.1.01';

  IF v_parent_id IS NULL THEN RETURN NEW; END IF;

  SELECT COUNT(*) INTO v_count FROM chart_of_accounts WHERE parent_id = v_parent_id;
  v_next_code := v_parent_code || '.' || LPAD((v_count + 1)::TEXT, 4, '0');

  INSERT INTO chart_of_accounts (
    code, name, account_type, nature, level, is_analytical, parent_id, sped_referencial_code
  ) VALUES (
    v_next_code, NEW.name, 'PASSIVO', 'CREDORA', 5, true, v_parent_id, '2.01.01.01.00'
  ) RETURNING id INTO v_new_account_id;

  NEW.account_id := v_new_account_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_create_supplier_account"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_learn_from_classification"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    clean_desc TEXT;
BEGIN
    -- S├│ aprende se:
    -- 1. A conta cont├íbil foi definida (n├úo era nula e agora ├®, ou mudou)
    -- 2. A transa├º├úo n├úo ├® antiga demais (opcional, aqui aceitamos tudo)
    -- 3. Trigger disparado por UPDATE
    
    IF NEW.chart_account_id IS NOT NULL AND (OLD.chart_account_id IS NULL OR OLD.chart_account_id <> NEW.chart_account_id) THEN
        
        -- Limpeza b├ísica da descri├º├úo para virar padr├úo
        -- Pega a descri├º├úo, remove espa├ºos extras e converte para mai├║sculo
        clean_desc := TRIM(UPPER(NEW.description));
        
        -- Regra simplificada V1: Aprende a descri├º├úo EXATA.
        -- Futuro: Extrair apenas as 2-3 primeiras palavras.
        
        IF length(clean_desc) > 3 THEN
            INSERT INTO classification_learning (keyword, chart_account_id, confidence_score)
            VALUES (clean_desc, NEW.chart_account_id, 1)
            ON CONFLICT (keyword, chart_account_id) 
            DO UPDATE SET 
                confidence_score = classification_learning.confidence_score + 1,
                last_used_at = NOW();
        END IF;

    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_learn_from_classification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_predict_classification"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    match_record RECORD;
BEGIN
    -- S├│ tenta prever se ainda n├úo tem classifica├º├úo
    IF NEW.chart_account_id IS NULL THEN
        
        -- Tenta encontrar a melhor correspond├¬ncia
        -- Ordena por score de confian├ºa (mais usados primeiro)
        -- Estrat├®gia: ILIKE para encontrar se a KEYWORD aprendida est├í contida na NOVA DESCRI├ç├âO
        -- Ex: Pattern "UBER" (aprendido) d├í match em "UBER DO BRASIL VIAGENS" (nova)
        
        SELECT chart_account_id 
        INTO match_record
        FROM classification_learning
        WHERE NEW.description ILIKE '%' || keyword || '%'
        ORDER BY confidence_score DESC, length(keyword) DESC
        LIMIT 1;

        -- Se achou, aplica
        IF FOUND THEN
            NEW.chart_account_id := match_record.chart_account_id;
            -- Podemos marcar algo como "auto_classified = true" se tiver coluna pra isso
        END IF;

    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."fn_predict_classification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean DEFAULT true, "p_dias_vencimento" integer DEFAULT 30) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_nfse_tomada RECORD;
  v_supplier_id UUID;
  v_conta_pagar_id UUID;
  v_vencimento DATE;
BEGIN
  -- Buscar NFS-e tomada
  SELECT * INTO v_nfse_tomada FROM nfse_tomadas WHERE id = p_nfse_tomada_id;

  IF v_nfse_tomada IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'NFS-e tomada n├úo encontrada');
  END IF;

  IF v_nfse_tomada.status != 'pendente' THEN
    RETURN json_build_object('success', false, 'error', 'NFS-e j├í processada');
  END IF;

  -- Buscar ou criar fornecedor
  SELECT id INTO v_supplier_id FROM suppliers
  WHERE cnpj = v_nfse_tomada.prestador_cnpj
  LIMIT 1;

  IF v_supplier_id IS NULL THEN
    INSERT INTO suppliers (name, cnpj, status)
    VALUES (
      COALESCE(v_nfse_tomada.prestador_razao_social, 'Fornecedor ' || v_nfse_tomada.prestador_cnpj),
      v_nfse_tomada.prestador_cnpj,
      'active'
    )
    RETURNING id INTO v_supplier_id;
  END IF;

  -- Atualizar refer├¬ncia do fornecedor
  UPDATE nfse_tomadas SET supplier_id = v_supplier_id WHERE id = p_nfse_tomada_id;

  -- Criar conta a pagar se solicitado
  IF p_criar_conta_pagar THEN
    v_vencimento := COALESCE(v_nfse_tomada.data_emissao, CURRENT_DATE) + p_dias_vencimento;

    INSERT INTO accounts_payable (
      supplier_id,
      description,
      amount,
      due_date,
      status,
      document_number,
      nfse_tomada_id
    ) VALUES (
      v_supplier_id,
      'NFS-e ' || v_nfse_tomada.numero_nfse || ' - ' || LEFT(COALESCE(v_nfse_tomada.discriminacao, 'Servi├ºo'), 100),
      COALESCE(v_nfse_tomada.valor_liquido, v_nfse_tomada.valor_servicos),
      v_vencimento,
      'pending',
      'NFSE-' || v_nfse_tomada.numero_nfse,
      p_nfse_tomada_id
    )
    RETURNING id INTO v_conta_pagar_id;

    -- Atualizar NFS-e com refer├¬ncia
    UPDATE nfse_tomadas
    SET
      conta_pagar_id = v_conta_pagar_id,
      status = 'lancada'
    WHERE id = p_nfse_tomada_id;
  ELSE
    UPDATE nfse_tomadas SET status = 'ignorada' WHERE id = p_nfse_tomada_id;
  END IF;

  RETURN json_build_object(
    'success', true,
    'nfse_tomada_id', p_nfse_tomada_id,
    'supplier_id', v_supplier_id,
    'conta_pagar_id', v_conta_pagar_id
  );
END;
$$;


ALTER FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean, "p_dias_vencimento" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean, "p_dias_vencimento" integer) IS 'Processa uma NFS-e tomada, criando fornecedor e conta a pagar automaticamente';



CREATE OR REPLACE FUNCTION "public"."fn_validar_honorarios_mensais"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_ano VARCHAR(4);
  v_mes VARCHAR(2);
  v_count_monthly INTEGER;
  v_count_thirteenth INTEGER;
BEGIN
  -- S├│ validar honor├írios do tipo monthly ou thirteenth
  IF NEW.fee_type NOT IN ('monthly', 'thirteenth') THEN
    RETURN NEW;
  END IF;

  -- Extrair ano e m├¬s da compet├¬ncia
  v_ano := SUBSTRING(NEW.competence FROM 4 FOR 4);
  v_mes := SUBSTRING(NEW.competence FROM 1 FOR 2);

  -- Validar formato da compet├¬ncia
  IF NOT NEW.competence ~ '^\d{2}/\d{4}$' THEN
    RAISE EXCEPTION 'Compet├¬ncia inv├ílida: %. Formato esperado: MM/YYYY', NEW.competence;
  END IF;

  -- Para honor├írios mensais (monthly): m├¬s deve ser 01-12
  IF NEW.fee_type = 'monthly' THEN
    IF NOT v_mes ~ '^(0[1-9]|1[0-2])$' THEN
      RAISE EXCEPTION 'Honor├írio mensal deve ter compet├¬ncia de 01 a 12. Recebido: %', v_mes;
    END IF;

    -- Verificar limite de 12 mensais por ano
    SELECT COUNT(*) INTO v_count_monthly
    FROM client_opening_balance
    WHERE client_id = NEW.client_id
      AND SUBSTRING(competence FROM 4 FOR 4) = v_ano
      AND fee_type = 'monthly'
      AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid);

    IF v_count_monthly >= 12 THEN
      RAISE EXCEPTION 'Limite de 12 honor├írios mensais por ano atingido (ano: %)', v_ano;
    END IF;
  END IF;

  -- Para 13┬║ sal├írio (thirteenth): m├¬s deve ser 13
  IF NEW.fee_type = 'thirteenth' THEN
    IF v_mes != '13' THEN
      RAISE EXCEPTION '13┬║ honor├írio deve ter compet├¬ncia 13/YYYY. Recebido: %', NEW.competence;
    END IF;

    -- Verificar limite de 1 d├®cimo terceiro por ano
    SELECT COUNT(*) INTO v_count_thirteenth
    FROM client_opening_balance
    WHERE client_id = NEW.client_id
      AND SUBSTRING(competence FROM 4 FOR 4) = v_ano
      AND fee_type = 'thirteenth'
      AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid);

    IF v_count_thirteenth >= 1 THEN
      RAISE EXCEPTION 'J├í existe 13┬║ honor├írio para o ano %', v_ano;
    END IF;
  END IF;

  -- Verificar duplicata de compet├¬ncia para o mesmo tipo
  IF EXISTS (
    SELECT 1 FROM client_opening_balance
    WHERE client_id = NEW.client_id
      AND competence = NEW.competence
      AND fee_type = NEW.fee_type
      AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
  ) THEN
    RAISE EXCEPTION 'J├í existe honor├írio (%) para compet├¬ncia % neste cliente', NEW.fee_type, NEW.competence;
  END IF;

  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."fn_validar_honorarios_mensais"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."fn_validar_honorarios_mensais"() IS 'Valida limite de honor├írios: 12 mensais + 1 d├®cimo terceiro por ano. Outros tipos (legaliza├º├úo, altera├º├úo, etc.) n├úo t├¬m limite.';



CREATE OR REPLACE FUNCTION "public"."generate_addendum_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(addendum_number FROM 'ADT-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM contract_addendums
  WHERE addendum_number LIKE 'ADT-' || year_part || '-%';

  new_number := 'ADT-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_addendum_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean DEFAULT true, "p_dry_run" boolean DEFAULT false) RETURNS TABLE("month" integer, "competence" "text", "due_date" "date", "amount" numeric, "is_13th" boolean, "status" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client RECORD;
  v_due_date DATE;
  v_amount NUMERIC;
  v_invoice_id UUID;
  v_competence TEXT;
BEGIN
  -- Buscar dados do cliente
  SELECT
    c.id, c.name, c.monthly_fee, c.payment_day, c.uf,
    c.has_13th_fee, c.thirteenth_fee_day, c.thirteenth_fee_amount,
    c.fee_in_minimum_wages, c.auto_adjust_by_minimum_wage
  INTO v_client
  FROM clients c
  WHERE c.id = p_client_id AND c.is_active = true;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Cliente n├úo encontrado ou inativo';
  END IF;

  -- Gerar 12 parcelas mensais
  FOR i IN 1..12 LOOP
    v_competence := LPAD(i::TEXT, 2, '0') || '/' || p_year;
    v_due_date := calculate_due_date(p_year, i, COALESCE(v_client.payment_day, 10), v_client.uf);
    v_amount := v_client.monthly_fee;

    IF NOT p_dry_run THEN
      -- Inserir fatura (se n├úo existir)
      INSERT INTO invoices (client_id, amount, due_date, competence, status, description)
      VALUES (
        p_client_id,
        v_amount,
        v_due_date,
        v_competence,
        'pending',
        'Honor├írio mensal ' || v_competence
      )
      ON CONFLICT DO NOTHING
      RETURNING id INTO v_invoice_id;
    END IF;

    month := i;
    competence := v_competence;
    due_date := v_due_date;
    amount := v_amount;
    is_13th := false;
    status := CASE WHEN p_dry_run THEN 'SIMULADO' ELSE 'GERADO' END;
    RETURN NEXT;
  END LOOP;

  -- Gerar 13┬¬ parcela (se habilitado)
  IF p_include_13th AND COALESCE(v_client.has_13th_fee, true) THEN
    v_competence := '13/' || p_year;
    v_due_date := calculate_due_date(
      p_year,
      12, -- Dezembro
      COALESCE(v_client.thirteenth_fee_day, 20),
      v_client.uf
    );
    v_amount := COALESCE(v_client.thirteenth_fee_amount, v_client.monthly_fee);

    IF NOT p_dry_run THEN
      INSERT INTO invoices (client_id, amount, due_date, competence, status, description)
      VALUES (
        p_client_id,
        v_amount,
        v_due_date,
        v_competence,
        'pending',
        '13┬║ Honor├írio ' || p_year
      )
      ON CONFLICT DO NOTHING
      RETURNING id INTO v_invoice_id;
    END IF;

    month := 13;
    competence := v_competence;
    due_date := v_due_date;
    amount := v_amount;
    is_13th := true;
    status := CASE WHEN p_dry_run THEN 'SIMULADO' ELSE 'GERADO' END;
    RETURN NEXT;
  END IF;
END;
$$;


ALTER FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) IS 'Gera as 13 faturas anuais de um cliente (12 mensais + 13┬║ honor├írio)';



CREATE OR REPLACE FUNCTION "public"."generate_bank_tx_code"("p_reference" "text", "p_date" "date", "p_amount" numeric, "p_description" "text", "p_uuid" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_hash TEXT;
BEGIN
    -- Usamos o UUID da transa├º├úo para garantir uma unicidade absoluta.
    v_hash := LEFT(MD5(CONCAT_WS('|', COALESCE(p_reference, 'ref'), p_date::TEXT, p_amount::TEXT, COALESCE(p_description, 'desc'), p_uuid::TEXT)), 8);
    RETURN CONCAT('bank_tx:', TO_CHAR(p_date, 'YYYYMMDD'), ':', v_hash);
END;
$$;


ALTER FUNCTION "public"."generate_bank_tx_code"("p_reference" "text", "p_date" "date", "p_amount" numeric, "p_description" "text", "p_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_confession_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(confession_number FROM 'CDV-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM debt_confessions
  WHERE confession_number LIKE 'CDV-' || year_part || '-%';

  new_number := 'CDV-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_confession_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_contract_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(contract_number FROM 'CTR-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM accounting_contracts
  WHERE contract_number LIKE 'CTR-' || year_part || '-%';

  new_number := 'CTR-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_contract_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_internal_code"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) RETURNS character varying
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_hash VARCHAR;
    v_code VARCHAR;
BEGIN
    -- Generate hash from source data
    v_hash := LEFT(MD5(CONCAT(
        COALESCE(p_source_type, 'manual'),
        ':',
        COALESCE(p_source_id::TEXT, gen_random_uuid()::TEXT),
        ':',
        p_date::TEXT,
        ':',
        p_amount::TEXT
    )), 12);

    -- Build internal code
    v_code := CONCAT(
        COALESCE(p_source_type, 'manual'),
        ':',
        TO_CHAR(p_date, 'YYYYMMDD'),
        ':',
        v_hash
    );

    RETURN v_code;
END;
$$;


ALTER FUNCTION "public"."generate_internal_code"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_irpf_forecast"("p_calendar_year" integer) RETURNS TABLE("taxpayer_name" character varying, "taxpayer_cpf" character varying, "client_name" character varying, "client_id" "uuid", "already_registered" boolean)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT DISTINCT
    (s.socio->>'nome')::VARCHAR as taxpayer_name,
    -- Tentar extrair CPF do QSA (pode n├úo ter)
    COALESCE(s.socio->>'cpf', '')::VARCHAR as taxpayer_cpf,
    c.name::VARCHAR as client_name,
    c.id as client_id,
    EXISTS (
      SELECT 1 FROM irpf_declarations ir
      WHERE ir.taxpayer_cpf = COALESCE(s.socio->>'cpf', '')
        AND ir.calendar_year = p_calendar_year
    ) as already_registered
  FROM clients c,
  LATERAL jsonb_array_elements(c.qsa) as s(socio)
  WHERE c.is_active = true
    AND c.qsa IS NOT NULL
    AND jsonb_array_length(c.qsa) > 0
  ORDER BY taxpayer_name;
END;
$$;


ALTER FUNCTION "public"."generate_irpf_forecast"("p_calendar_year" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_journal_entry_number"("p_fiscal_year" integer) RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_next_number INTEGER;
BEGIN
  SELECT COALESCE(MAX(entry_number), 0) + 1 INTO v_next_number
  FROM journal_entries
  WHERE fiscal_year = p_fiscal_year;

  RETURN v_next_number;
END;
$$;


ALTER FUNCTION "public"."generate_journal_entry_number"("p_fiscal_year" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_letter_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(letter_number FROM 'CRA-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM responsibility_letters
  WHERE letter_number LIKE 'CRA-' || year_part || '-%';

  new_number := 'CRA-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_letter_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_meeting_agenda"("p_meeting_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_meeting RECORD;
    v_agenda JSONB := '[]'::jsonb;
    v_alerts INTEGER;
    v_pending_invoices INTEGER;
    v_low_stock INTEGER;
    v_cash_flow DECIMAL;
BEGIN
    SELECT * INTO v_meeting FROM ai_meetings WHERE id = p_meeting_id;

    -- Contar alertas trabalhistas
    SELECT COUNT(*) INTO v_alerts FROM vw_all_labor_alerts;

    -- Contar NFs pendentes
    SELECT COUNT(*) INTO v_pending_invoices
    FROM service_providers WHERE contract_signed = false;

    -- Contar itens com estoque baixo
    SELECT COUNT(*) INTO v_low_stock FROM vw_low_stock_products;

    -- Montar pauta baseada nos dados
    v_agenda := jsonb_build_array(
        jsonb_build_object(
            'ordem', 1,
            'titulo', 'Abertura e Boas-vindas',
            'responsavel', 'helena',
            'duracao_minutos', 5,
            'descricao', 'Dra. Helena abre a reuni├úo e apresenta a pauta'
        ),
        jsonb_build_object(
            'ordem', 2,
            'titulo', 'An├ílise Financeira do Per├¡odo',
            'responsavel', 'milton',
            'duracao_minutos', 15,
            'descricao', 'Prof. Milton apresenta indicadores, receitas, despesas e fluxo de caixa'
        ),
        jsonb_build_object(
            'ordem', 3,
            'titulo', 'Situa├º├úo Cont├íbil',
            'responsavel', 'cicero',
            'duracao_minutos', 10,
            'descricao', 'Dr. C├¡cero apresenta balancete, pend├¬ncias e regulariza├º├Áes'
        )
    );

    -- Se houver alertas trabalhistas
    IF v_alerts > 0 THEN
        v_agenda := v_agenda || jsonb_build_array(
            jsonb_build_object(
                'ordem', 4,
                'titulo', 'Riscos Trabalhistas (' || v_alerts || ' alertas)',
                'responsavel', 'advocato',
                'duracao_minutos', 15,
                'descricao', 'Dr. Advocato apresenta riscos identificados e solu├º├Áes propostas',
                'urgente', true
            )
        );
    END IF;

    -- Se houver estoque baixo
    IF v_low_stock > 0 THEN
        v_agenda := v_agenda || jsonb_build_array(
            jsonb_build_object(
                'ordem', 5,
                'titulo', 'Reposi├º├úo de Estoque (' || v_low_stock || ' itens)',
                'responsavel', 'helena',
                'duracao_minutos', 5,
                'descricao', 'Aprovar lista de compras para reposi├º├úo'
            )
        );
    END IF;

    -- Encerramento sempre
    v_agenda := v_agenda || jsonb_build_array(
        jsonb_build_object(
            'ordem', 99,
            'titulo', 'Delibera├º├Áes e Encerramento',
            'responsavel', 'helena',
            'duracao_minutos', 10,
            'descricao', 'Registrar decis├Áes, definir respons├íveis e pr├│ximos passos'
        )
    );

    -- Atualizar reuni├úo
    UPDATE ai_meetings SET
        agenda = v_agenda,
        ai_generated_topics = jsonb_build_object(
            'alertas_trabalhistas', v_alerts,
            'nfs_pendentes', v_pending_invoices,
            'estoque_baixo', v_low_stock,
            'gerado_em', now(),
            'gerado_por', 'helena'
        )
    WHERE id = p_meeting_id;

    RETURN v_agenda;
END;
$$;


ALTER FUNCTION "public"."generate_meeting_agenda"("p_meeting_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_meeting_presentation"("p_meeting_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_meeting RECORD;
    v_presentation_id UUID;
    v_slides JSONB := '[]'::jsonb;
BEGIN
    SELECT * INTO v_meeting FROM ai_meetings WHERE id = p_meeting_id;

    -- Slide 1: Capa
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'numero', 1,
            'tipo', 'capa',
            'titulo', v_meeting.title,
            'subtitulo', to_char(v_meeting.scheduled_date, 'DD/MM/YYYY'),
            'logo', true,
            'background', 'gradient-blue'
        )
    );

    -- Slide 2: Pauta
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'numero', 2,
            'tipo', 'lista',
            'titulo', 'Pauta da Reuni├úo',
            'icone', 'clipboard',
            'items', (
                SELECT jsonb_agg(item->>'titulo')
                FROM jsonb_array_elements(v_meeting.agenda) item
            )
        )
    );

    -- Slide 3: Indicadores Financeiros
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'numero', 3,
            'tipo', 'kpis',
            'titulo', 'Indicadores Financeiros',
            'responsavel', 'Prof. Milton',
            'kpis', jsonb_build_array(
                jsonb_build_object('nome', 'Receita Bruta', 'valor', 'R$ XX.XXX,XX', 'variacao', '+5%'),
                jsonb_build_object('nome', 'Despesas', 'valor', 'R$ XX.XXX,XX', 'variacao', '-2%'),
                jsonb_build_object('nome', 'Lucro L├¡quido', 'valor', 'R$ XX.XXX,XX', 'variacao', '+8%'),
                jsonb_build_object('nome', 'Inadimpl├¬ncia', 'valor', 'X%', 'variacao', '-1%')
            )
        )
    );

    -- Slide 4: Alertas (se houver)
    IF (v_meeting.ai_generated_topics->>'alertas_trabalhistas')::int > 0 THEN
        v_slides := v_slides || jsonb_build_array(
            jsonb_build_object(
                'numero', 4,
                'tipo', 'alerta',
                'titulo', 'ATEN├ç├âO: Riscos Identificados',
                'responsavel', 'Dr. Advocato',
                'urgente', true,
                'items', jsonb_build_array(
                    'Pagamentos n├úo registrados em folha',
                    'Contratos de prestadores pendentes',
                    'Sugest├úo: Regulariza├º├úo imediata'
                )
            )
        );
    END IF;

    -- Slide Final: Pr├│ximos Passos
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'numero', 99,
            'tipo', 'acoes',
            'titulo', 'Pr├│ximos Passos',
            'responsavel', 'Dra. Helena',
            'items', jsonb_build_array(
                jsonb_build_object('acao', 'Definir na reuni├úo', 'responsavel', 'A definir', 'prazo', 'A definir')
            )
        )
    );

    -- Criar apresenta├º├úo
    INSERT INTO ai_presentations (
        meeting_id, title, presentation_type, purpose,
        slides, generated_by, status
    ) VALUES (
        p_meeting_id,
        v_meeting.title || ' - Apresenta├º├úo',
        'slides',
        'Apresenta├º├úo gerada automaticamente para exibi├º├úo em TV durante a reuni├úo',
        v_slides,
        'helena',
        'ready'
    )
    RETURNING id INTO v_presentation_id;

    -- Atualizar reuni├úo
    UPDATE ai_meetings SET presentation_id = v_presentation_id WHERE id = p_meeting_id;

    RETURN v_presentation_id;
END;
$_$;


ALTER FUNCTION "public"."generate_meeting_presentation"("p_meeting_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_count INTEGER := 0;
    r_contract RECORD;
    v_due_date DATE;
    v_invoice_id UUID;
BEGIN
    FOR r_contract IN 
        SELECT id, client_id, monthly_fee, payment_day 
        FROM accounting_contracts 
        WHERE status = 'active'
        AND start_date <= p_competence_date
        AND (end_date IS NULL OR end_date >= p_competence_date)
    LOOP
        v_due_date := (p_competence_date + INTERVAL '1 month');
        BEGIN
            v_due_date := make_date(
                extract(year from v_due_date)::int,
                extract(month from v_due_date)::int,
                LEAST(COALESCE(r_contract.payment_day, 10), 28)
            );
        EXCEPTION WHEN OTHERS THEN
             v_due_date := (date_trunc('month', v_due_date) + interval '1 month - 1 day')::date;
        END;

        IF NOT EXISTS (
            SELECT 1 FROM invoices 
            WHERE client_id = r_contract.client_id 
            AND competence = to_char(p_competence_date, 'MM/YYYY')
        ) THEN
            INSERT INTO invoices (
                client_id,
                amount,
                due_date,
                status,
                notes,
                competence
            ) VALUES (
                r_contract.client_id,
                r_contract.monthly_fee,
                v_due_date,
                'pending',
                'Honor├írios Cont├íbeis ' || to_char(p_competence_date, 'MM/YYYY'),
                to_char(p_competence_date, 'MM/YYYY')
            );
            
            v_count := v_count + 1;
        END IF;
    END LOOP;

    RETURN v_count;
END;
$$;


ALTER FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date", "p_due_day" integer DEFAULT 10, "p_simulate" boolean DEFAULT false) RETURNS TABLE("client_name" "text", "fee_value" numeric, "result_status" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    r_client RECORD;
    v_due_date DATE;
    v_competence_text VARCHAR;
    v_count INTEGER := 0;
    v_sm_value NUMERIC;
BEGIN
    -- 1. Obter Sal├írio M├¡nimo Vigente na Compet├¬ncia
    SELECT value INTO v_sm_value
    FROM minimum_wage_history
    WHERE effective_date <= p_competence_date
    ORDER BY effective_date DESC
    LIMIT 1;

    -- 1.1 Configurar datas
    -- Vencimento no m├¬s seguinte
    v_due_date := (p_competence_date + INTERVAL '1 month')::DATE;
    -- Ajustar dia do vencimento
    v_due_date := make_date(
        EXTRACT(YEAR FROM v_due_date)::INTEGER,
        EXTRACT(MONTH FROM v_due_date)::INTEGER,
        p_due_day
    );
    
    v_competence_text := TO_CHAR(p_competence_date, 'MM/YYYY');

    -- 2. Loop por contratos v├ílidos no per├¡odo
    FOR r_client IN 
        SELECT 
            c.id as client_id,
            c.name as client_name, 
            c.fee_in_minimum_wages, -- Adicionado para c├ílculo din├ómico
            con.monthly_fee,
            con.id as contract_id,
            con.start_date,
            con.adjustment_index
        FROM accounting_contracts con
        JOIN clients c ON con.client_id = c.id
        WHERE 
            -- Contrato deve ter iniciado antes ou no m├¬s da compet├¬ncia
            con.start_date <= (p_competence_date + INTERVAL '1 month' - INTERVAL '1 day')::DATE
            -- Contrato n├úo pode ter sido encerrado antes do in├¡cio da compet├¬ncia
            AND (con.termination_date IS NULL OR con.termination_date >= p_competence_date)
            -- Apenas contratos com valor (qualquer um dos dois)
            AND (con.monthly_fee > 0 OR c.fee_in_minimum_wages > 0)
            -- Status considerados (ignora rascunhos 'draft')
            AND con.status IN ('active', 'suspended', 'terminated')
    LOOP
        -- Definir valor do honor├írio (Prioridade: Sal├írio M├¡nimo > Valor Fixo do Contrato)
        IF r_client.fee_in_minimum_wages IS NOT NULL AND r_client.fee_in_minimum_wages > 0 AND v_sm_value IS NOT NULL THEN
            fee_value := ROUND(r_client.fee_in_minimum_wages * v_sm_value, 2);
        ELSE
            fee_value := r_client.monthly_fee;
        END IF;

        -- Verifica se j├í existe invoice para esta competencia e cliente
        -- (Adicionado verifica├º├úo extra de contrato para evitar duplicidade se houver multiplos contratos, embora nao deva haver)
        IF EXISTS (
            SELECT 1 FROM invoices 
            WHERE client_id = r_client.client_id 
              AND competence = v_competence_text
        ) THEN
            client_name := r_client.client_name;
            fee_value := r_client.monthly_fee;
            result_status := 'SKIPPED (Already Exists)';
            RETURN NEXT;
            CONTINUE;
        END IF;

        IF p_simulate THEN
            client_name := r_client.client_name;
            -- fee_value j├í calculado acima
            result_status := 'SIMULATED (Would Create)';
            RETURN NEXT;
        ELSE
            -- 3. Criar Invoice
            IF fee_value IS NOT NULL AND fee_value > 0 THEN
                INSERT INTO invoices (
                    client_id,
                    amount,
                    due_date,
                    competence,
                    description,
                    status,
                    type
                ) VALUES (
                    r_client.client_id,
                    fee_value, -- Usando valor calculado
                    v_due_date,
                    v_competence_text,
                    'Honor├írios Mensais - ' || v_competence_text || ' (Contrato ' || TO_CHAR(r_client.start_date, 'DD/MM/YYYY') || ')',
                    'pending',
                    'honorario_mensal'
                );
                
                client_name := r_client.client_name;
                -- fee_value definido acima
                result_status := 'CREATED';
                RETURN NEXT;
            END IF;
        END IF;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date", "p_due_day" integer, "p_simulate" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_monthly_results_video"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_video_id UUID;
    v_slides JSONB := '[]'::jsonb;
    v_ranking RECORD;
    v_position INTEGER := 1;
    v_total_sales INTEGER;
    v_total_revenue DECIMAL;
BEGIN
    -- Calcular totais do m├¬s
    SELECT
        COUNT(*) FILTER (WHERE status = 'won'),
        COALESCE(SUM(monthly_fee) FILTER (WHERE status = 'won'), 0)
    INTO v_total_sales, v_total_revenue
    FROM employee_sales
    WHERE DATE_TRUNC('month', close_date) = DATE_TRUNC('month', CURRENT_DATE);

    -- Slide inicial
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'titulo', '­ƒÅå Resultados de ' || TO_CHAR(CURRENT_DATE, 'Month/YYYY'),
            'conteudo', 'Parab├®ns ├á equipe!'
        )
    );

    -- Top 3 vendedores
    FOR v_ranking IN
        SELECT employee_name, vendas_fechadas, total_comissoes
        FROM vw_employee_sales_ranking
        WHERE vendas_fechadas > 0
        ORDER BY vendas_fechadas DESC, total_comissoes DESC
        LIMIT 3
    LOOP
        v_slides := v_slides || jsonb_build_array(
            jsonb_build_object(
                'titulo', CASE v_position
                    WHEN 1 THEN '­ƒÑç 1┬║ Lugar'
                    WHEN 2 THEN '­ƒÑê 2┬║ Lugar'
                    WHEN 3 THEN '­ƒÑë 3┬║ Lugar'
                END,
                'conteudo', v_ranking.employee_name || ' - ' ||
                           v_ranking.vendas_fechadas || ' vendas - R$ ' ||
                           v_ranking.total_comissoes
            )
        );
        v_position := v_position + 1;
    END LOOP;

    -- Totais
    v_slides := v_slides || jsonb_build_array(
        jsonb_build_object(
            'titulo', '­ƒôè Total do M├¬s',
            'conteudo', v_total_sales || ' novos clientes = R$ ' || v_total_revenue || '/m├¬s'
        ),
        jsonb_build_object(
            'titulo', '­ƒÜÇ Voc├¬ pode ser o pr├│ximo!',
            'conteudo', 'Indique e ganhe at├® R$ 500!'
        )
    );

    -- Criar v├¡deo
    INSERT INTO marketing_videos (
        title, description, video_type, target_audience,
        slides, tags, status, priority, created_by,
        start_date, end_date
    ) VALUES (
        'Resultados ' || TO_CHAR(CURRENT_DATE, 'MM/YYYY'),
        'Ranking de vendedores do m├¬s',
        'results',
        ARRAY['all'],
        v_slides,
        ARRAY['resultados', 'ranking', 'm├¬s'],
        'active',
        10,
        'marketing',
        DATE_TRUNC('month', CURRENT_DATE),
        (DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month - 1 day')::date
    )
    RETURNING id INTO v_video_id;

    RETURN v_video_id;
END;
$_$;


ALTER FUNCTION "public"."generate_monthly_results_video"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_negotiation_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.negotiation_number IS NULL THEN
    NEW.negotiation_number := 'NEG-' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(NEXTVAL('negotiation_number_seq')::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_negotiation_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_payroll_journal_entries"("p_payroll_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_payroll RECORD;
    v_employee RECORD;
    v_count INTEGER := 0;
    v_competencia DATE;
BEGIN
    -- Buscar dados da folha
    SELECT p.*, e.name as employee_name, e.work_area
    INTO v_payroll
    FROM payroll p
    JOIN employees e ON e.id = p.employee_id
    WHERE p.id = p_payroll_id;

    IF v_payroll IS NULL THEN
        RAISE EXCEPTION 'Folha n├úo encontrada';
    END IF;

    v_competencia := v_payroll.competencia;

    -- Limpar lan├ºamentos anteriores
    DELETE FROM payroll_journal_entries WHERE payroll_id = p_payroll_id;

    -- 1. SAL├üRIOS OFICIAIS (Despesa)
    -- D - 4.1.1.01 Sal├írios e Ordenados
    -- C - 2.1.3.01 Sal├írios a Pagar
    IF v_payroll.total_proventos_oficial > 0 THEN
        INSERT INTO payroll_journal_entries (payroll_id, entry_type, description, debit_account, credit_account, amount, competence_date)
        VALUES (
            p_payroll_id,
            'salarios',
            'Sal├írios - ' || v_payroll.employee_name || ' - ' || to_char(v_competencia, 'MM/YYYY'),
            '4.1.1.01', -- Despesa com Sal├írios
            '2.1.3.01', -- Sal├írios a Pagar
            v_payroll.total_proventos_oficial,
            v_competencia
        );
        v_count := v_count + 1;
    END IF;

    -- 2. INSS EMPRESA (Encargo)
    -- D - 4.1.2.01 INSS Patronal
    -- C - 2.1.3.02 INSS a Recolher
    IF v_payroll.inss_empresa > 0 THEN
        INSERT INTO payroll_journal_entries (payroll_id, entry_type, description, debit_account, credit_account, amount, competence_date)
        VALUES (
            p_payroll_id,
            'encargos',
            'INSS Patronal - ' || v_payroll.employee_name || ' - ' || to_char(v_competencia, 'MM/YYYY'),
            '4.1.2.01', -- INSS Patronal
            '2.1.3.02', -- INSS a Recolher
            v_payroll.inss_empresa,
            v_competencia
        );
        v_count := v_count + 1;
    END IF;

    -- 3. FGTS (Encargo)
    -- D - 4.1.2.02 FGTS
    -- C - 2.1.3.03 FGTS a Recolher
    IF v_payroll.fgts_valor > 0 THEN
        INSERT INTO payroll_journal_entries (payroll_id, entry_type, description, debit_account, credit_account, amount, competence_date)
        VALUES (
            p_payroll_id,
            'encargos',
            'FGTS - ' || v_payroll.employee_name || ' - ' || to_char(v_competencia, 'MM/YYYY'),
            '4.1.2.02', -- FGTS
            '2.1.3.03', -- FGTS a Recolher
            v_payroll.fgts_valor,
            v_competencia
        );
        v_count := v_count + 1;
    END IF;

    -- 4. PROVIS├âO DE F├ëRIAS
    -- D - 4.1.3.01 Provis├úo de F├®rias
    -- C - 2.1.4.01 F├®rias a Pagar
    IF v_payroll.provisao_ferias > 0 THEN
        INSERT INTO payroll_journal_entries (payroll_id, entry_type, description, debit_account, credit_account, amount, competence_date)
        VALUES (
            p_payroll_id,
            'provisoes',
            'Provis├úo F├®rias - ' || v_payroll.employee_name || ' - ' || to_char(v_competencia, 'MM/YYYY'),
            '4.1.3.01', -- Provis├úo de F├®rias
            '2.1.4.01', -- F├®rias a Pagar
            v_payroll.provisao_ferias,
            v_competencia
        );
        v_count := v_count + 1;
    END IF;

    -- 5. PROVIS├âO 13┬║ SAL├üRIO
    -- D - 4.1.3.02 Provis├úo 13┬║ Sal├írio
    -- C - 2.1.4.02 13┬║ Sal├írio a Pagar
    IF v_payroll.provisao_13 > 0 THEN
        INSERT INTO payroll_journal_entries (payroll_id, entry_type, description, debit_account, credit_account, amount, competence_date)
        VALUES (
            p_payroll_id,
            'provisoes',
            'Provis├úo 13┬║ - ' || v_payroll.employee_name || ' - ' || to_char(v_competencia, 'MM/YYYY'),
            '4.1.3.02', -- Provis├úo 13┬║
            '2.1.4.02', -- 13┬║ a Pagar
            v_payroll.provisao_13,
            v_competencia
        );
        v_count := v_count + 1;
    END IF;

    -- Atualizar status da folha
    UPDATE payroll SET status = 'contabilizada' WHERE id = p_payroll_id;

    RETURN v_count;
END;
$$;


ALTER FUNCTION "public"."generate_payroll_journal_entries"("p_payroll_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_proposal_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(proposal_number FROM 'PROP-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM service_proposals
  WHERE proposal_number LIKE 'PROP-' || year_part || '-%';

  new_number := 'PROP-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_proposal_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_random_password"("length" integer DEFAULT 8) RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
  result TEXT := '';
  i INTEGER;
BEGIN
  FOR i IN 1..length LOOP
    result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
  END LOOP;
  RETURN result;
END;
$$;


ALTER FUNCTION "public"."generate_random_password"("length" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_random_password"("length" integer) IS 'Gera senha aleat├│ria segura (sem caracteres amb├¡guos)';



CREATE OR REPLACE FUNCTION "public"."generate_recurring_expenses"() RETURNS TABLE("generated_count" integer, "expenses_created" "uuid"[])
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  parent_expense RECORD;
  new_expense_id UUID;
  current_month DATE;
  expenses_array UUID[] := ARRAY[]::UUID[];
  count_generated INTEGER := 0;
BEGIN
  current_month := date_trunc('month', CURRENT_DATE);
  
  FOR parent_expense IN
    SELECT *
    FROM accounts_payable
    WHERE is_recurring = true
      AND is_suspended = false
      AND recurrence_frequency IS NOT NULL
      AND recurrence_day IS NOT NULL
  LOOP
    -- Calcular a data de vencimento do novo gasto
    DECLARE
      next_due_date DATE;
    BEGIN
      next_due_date := (current_month + INTERVAL '1 month' * 
        CASE parent_expense.recurrence_frequency
          WHEN 'monthly' THEN 1
          WHEN 'quarterly' THEN 3
          WHEN 'semiannual' THEN 6
          WHEN 'annual' THEN 12
          ELSE 1
        END
      )::DATE + (parent_expense.recurrence_day - 1);

      -- Verificar se j├í existe um gasto para este m├¬s
      IF NOT EXISTS (
        SELECT 1 FROM accounts_payable
        WHERE parent_expense_id = parent_expense.id
          AND due_date = next_due_date
      ) THEN
        -- Criar novo gasto recorrente
        INSERT INTO accounts_payable (
          supplier_name,
          supplier_document,
          amount,
          due_date,
          category,
          description,
          status,
          parent_expense_id,
          is_recurring,
          recurrence_frequency,
          recurrence_day,
          created_by,
          cost_center,
          payment_method,
          bank_account
        )
        VALUES (
          parent_expense.supplier_name,
          parent_expense.supplier_document,
          parent_expense.amount,
          next_due_date,
          parent_expense.category,
          parent_expense.description || ' (Recorrente - ' || TO_CHAR(next_due_date, 'MM/YYYY') || ')',
          'pending',
          parent_expense.id,
          false,
          parent_expense.recurrence_frequency,
          parent_expense.recurrence_day,
          parent_expense.created_by,
          parent_expense.cost_center,
          parent_expense.payment_method,
          parent_expense.bank_account
        )
        RETURNING id INTO new_expense_id;

        expenses_array := array_append(expenses_array, new_expense_id);
        count_generated := count_generated + 1;
      END IF;
    END;
  END LOOP;

  RETURN QUERY SELECT count_generated, expenses_array;
END;
$$;


ALTER FUNCTION "public"."generate_recurring_expenses"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_shopping_list"("p_created_by" "text" DEFAULT 'Sistema'::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_list_id UUID;
  v_product RECORD;
  v_estimated_total DECIMAL := 0;
BEGIN
  -- Criar lista de compras
  INSERT INTO purchase_lists (title, description, status, created_by, needed_by_date)
  VALUES (
    'Lista de Compras ' || TO_CHAR(CURRENT_DATE, 'DD/MM/YYYY'),
    'Lista gerada automaticamente baseada no estoque m├¡nimo',
    'pending_quote',
    p_created_by,
    CURRENT_DATE + INTERVAL '7 days'
  )
  RETURNING id INTO v_list_id;

  -- Adicionar produtos com estoque baixo
  FOR v_product IN
    SELECT * FROM vw_low_stock_products WHERE priority IN ('URGENTE', 'ALTO', 'NORMAL')
  LOOP
    INSERT INTO purchase_list_items (
      list_id, product_id, product_name, brand, quantity, unit,
      last_price, estimated_price, suggested_supplier, priority
    ) VALUES (
      v_list_id,
      v_product.id,
      v_product.name,
      v_product.brand,
      v_product.quantity_to_buy,
      v_product.unit,
      v_product.last_price,
      v_product.last_price,
      v_product.preferred_supplier,
      v_product.priority
    );

    v_estimated_total := v_estimated_total + COALESCE(v_product.estimated_value, 0);
  END LOOP;

  -- Atualizar total estimado
  UPDATE purchase_lists SET estimated_total = v_estimated_total WHERE id = v_list_id;

  RETURN v_list_id;
END;
$$;


ALTER FUNCTION "public"."generate_shopping_list"("p_created_by" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_shopping_list"("p_created_by" "text") IS 'Gera lista de compras automaticamente baseada no estoque';



CREATE OR REPLACE FUNCTION "public"."generate_sora_video"("p_template_code" "text", "p_variables" "jsonb", "p_duration_seconds" integer DEFAULT NULL::integer, "p_aspect_ratio" "text" DEFAULT NULL::"text", "p_priority" integer DEFAULT 5) RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_template RECORD;
    v_prompt TEXT;
    v_project_id UUID;
    v_queue_id UUID;
    v_var TEXT;
    v_value TEXT;
BEGIN
    -- Buscar template
    SELECT * INTO v_template
    FROM sora_video_templates
    WHERE template_code = p_template_code AND is_active;

    IF v_template IS NULL THEN
        RAISE EXCEPTION 'Template % n├úo encontrado', p_template_code;
    END IF;

    -- Substituir vari├íveis no prompt
    v_prompt := v_template.base_prompt;

    FOR v_var IN SELECT unnest(v_template.variables)
    LOOP
        v_value := p_variables->>v_var;
        IF v_value IS NOT NULL THEN
            v_prompt := REPLACE(v_prompt, '{{' || v_var || '}}', v_value);
        END IF;
    END LOOP;

    -- Criar projeto
    INSERT INTO sora_video_projects (
        project_name,
        project_type,
        prompt,
        duration_seconds,
        aspect_ratio,
        style,
        status
    ) VALUES (
        v_template.template_name || ' - ' || to_char(now(), 'DD/MM HH24:MI'),
        v_template.category,
        v_prompt,
        COALESCE(p_duration_seconds, v_template.default_duration),
        COALESCE(p_aspect_ratio, v_template.default_aspect_ratio),
        v_template.default_style,
        'pending'
    )
    RETURNING id INTO v_project_id;

    -- Adicionar ├á fila
    INSERT INTO sora_generation_queue (
        project_id,
        priority,
        api_request
    ) VALUES (
        v_project_id,
        p_priority,
        jsonb_build_object(
            'model', 'sora-2',
            'prompt', v_prompt,
            'duration', COALESCE(p_duration_seconds, v_template.default_duration),
            'aspect_ratio', COALESCE(p_aspect_ratio, v_template.default_aspect_ratio),
            'style', v_template.default_style
        )
    )
    RETURNING id INTO v_queue_id;

    RETURN v_project_id;
END;
$$;


ALTER FUNCTION "public"."generate_sora_video"("p_template_code" "text", "p_variables" "jsonb", "p_duration_seconds" integer, "p_aspect_ratio" "text", "p_priority" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_statement_key"("p_bank_account_id" "uuid", "p_period_start" "date", "p_period_end" "date", "p_opening_balance" numeric, "p_closing_balance" numeric) RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    payload TEXT;
BEGIN
    payload := p_bank_account_id::TEXT || '|' || p_period_start || '|' || p_period_end || '|' || COALESCE(p_opening_balance, 0)::TEXT || '|' || COALESCE(p_closing_balance, 0)::TEXT;
    RETURN encode(digest(payload, 'sha256'), 'hex');
END;
$$;


ALTER FUNCTION "public"."generate_statement_key"("p_bank_account_id" "uuid", "p_period_start" "date", "p_period_end" "date", "p_opening_balance" numeric, "p_closing_balance" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_technical_spec"("p_feature_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_feature RECORD;
    v_spec JSONB;
BEGIN
    SELECT * INTO v_feature FROM feature_requests WHERE id = p_feature_id;

    -- Gerar especifica├º├úo b├ísica (em produ├º├úo, isso seria enriquecido pela IA)
    v_spec := jsonb_build_object(
        'title', v_feature.title,
        'description', v_feature.description,
        'generated_at', now(),
        'sections', jsonb_build_array(
            jsonb_build_object(
                'name', 'Objetivo',
                'content', v_feature.problem_description
            ),
            jsonb_build_object(
                'name', 'Benef├¡cio Esperado',
                'content', v_feature.expected_benefit
            ),
            jsonb_build_object(
                'name', 'Exemplo de Uso',
                'content', v_feature.example_scenario
            )
        ),
        'database', jsonb_build_object(
            'new_tables', ARRAY[]::text[],
            'modified_tables', ARRAY[]::text[],
            'new_columns', ARRAY[]::text[]
        ),
        'ui', jsonb_build_object(
            'new_pages', ARRAY[]::text[],
            'modified_pages', ARRAY[]::text[],
            'new_components', ARRAY[]::text[]
        ),
        'api', jsonb_build_object(
            'new_functions', ARRAY[]::text[],
            'new_endpoints', ARRAY[]::text[]
        )
    );

    -- Atualizar solicita├º├úo
    UPDATE feature_requests SET
        technical_spec = v_spec,
        status = 'approved'
    WHERE id = p_feature_id;

    RETURN jsonb_build_object(
        'success', true,
        'spec', v_spec,
        'message', 'Especifica├º├úo t├®cnica gerada!'
    );
END;
$$;


ALTER FUNCTION "public"."generate_technical_spec"("p_feature_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_termination_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  year_part TEXT;
  seq_number INTEGER;
  new_number TEXT;
BEGIN
  year_part := to_char(CURRENT_DATE, 'YYYY');

  SELECT COALESCE(MAX(
    CAST(SUBSTRING(termination_number FROM 'DST-\d{4}-(\d+)') AS INTEGER)
  ), 0) + 1
  INTO seq_number
  FROM contract_terminations
  WHERE termination_number LIKE 'DST-' || year_part || '-%';

  new_number := 'DST-' || year_part || '-' || LPAD(seq_number::TEXT, 5, '0');
  RETURN new_number;
END;
$$;


ALTER FUNCTION "public"."generate_termination_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_video_narration"("p_project_id" "uuid", "p_narration_text" "text", "p_voice" "text" DEFAULT 'alloy'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- Atualizar projeto com narra├º├úo
    UPDATE sora_video_projects
    SET
        narration_text = p_narration_text,
        audio_type = 'narration'
    WHERE id = p_project_id;

    -- Retornar configura├º├úo para Edge Function
    RETURN jsonb_build_object(
        'project_id', p_project_id,
        'model', 'gpt-4o-mini-tts',
        'input', p_narration_text,
        'voice', p_voice,
        'response_format', 'mp3'
    );
END;
$$;


ALTER FUNCTION "public"."generate_video_narration"("p_project_id" "uuid", "p_narration_text" "text", "p_voice" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_payroll_id UUID;
    v_employee RECORD;
    v_salario_base DECIMAL;
    v_complemento DECIMAL;
    v_total_proventos DECIMAL := 0;
    v_total_descontos DECIMAL := 0;
    v_base_inss DECIMAL;
    v_inss DECIMAL;
    v_irrf DECIMAL;
    v_fgts DECIMAL;
BEGIN
    -- Buscar dados do funcion├írio
    SELECT * INTO v_employee FROM employees WHERE id = p_employee_id;

    IF v_employee IS NULL THEN
        RAISE EXCEPTION 'Funcion├írio n├úo encontrado';
    END IF;

    -- Extrair valores do salary_details
    v_salario_base := COALESCE((v_employee.salary_details->>'base_oficial')::decimal, v_employee.official_salary);
    v_complemento := COALESCE(
        (v_employee.salary_details->>'complemento_por_fora')::decimal,
        v_employee.unofficial_salary
    );

    -- Criar registro da folha
    INSERT INTO payroll (employee_id, competencia, status, data_calculo)
    VALUES (p_employee_id, p_competencia, 'calculada', now())
    ON CONFLICT (employee_id, competencia) DO UPDATE SET
        status = 'calculada',
        data_calculo = now(),
        updated_at = now()
    RETURNING id INTO v_payroll_id;

    -- Limpar eventos anteriores
    DELETE FROM payroll_events WHERE payroll_id = v_payroll_id;

    -- ===== PROVENTOS OFICIAIS =====

    -- 1. Sal├írio Base
    INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
    VALUES (v_payroll_id, '1000', 'Sal├írio Base', '30 dias', v_salario_base, true, false);
    v_total_proventos := v_total_proventos + v_salario_base;

    -- 2. DSR (se horista - n├úo aplic├ível para mensalista)
    -- Para mensalistas o DSR j├í est├í incluso no sal├írio base

    -- 3. Vale Transporte (cr├®dito para desconto)
    IF COALESCE(v_employee.transport_voucher_value, 0) > 0 THEN
        INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
        VALUES (v_payroll_id, '1080', 'Vale Transporte', '22 dias', v_employee.transport_voucher_value, true, false);
    END IF;

    -- 4. Vale Refei├º├úo/Alimenta├º├úo
    IF COALESCE(v_employee.meal_voucher_value, 0) > 0 THEN
        INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
        VALUES (v_payroll_id, '1090', 'Vale Alimenta├º├úo', '22 dias', v_employee.meal_voucher_value, true, false);
    END IF;

    -- ===== DESCONTOS OFICIAIS =====
    v_base_inss := v_total_proventos;

    -- 1. INSS
    v_inss := calcular_inss(v_base_inss);
    INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
    VALUES (v_payroll_id, '2000', 'INSS', ROUND(v_inss * 100 / NULLIF(v_base_inss, 0), 2)::text || '%', v_inss, true, true);
    v_total_descontos := v_total_descontos + v_inss;

    -- 2. IRRF (CORRE├ç├âO: usar COALESCE para dependents)
    v_irrf := calcular_irrf(v_base_inss - v_inss, COALESCE(v_employee.dependents, 0));
    IF v_irrf > 0 THEN
        INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
        VALUES (v_payroll_id, '2001', 'IRRF', '', v_irrf, true, true);
        v_total_descontos := v_total_descontos + v_irrf;
    END IF;

    -- 3. Desconto Vale Transporte (6% do sal├írio, m├íx do VT)
    IF COALESCE(v_employee.transport_voucher_value, 0) > 0 THEN
        DECLARE v_desc_vt DECIMAL;
        BEGIN
            v_desc_vt := LEAST(v_salario_base * 0.06, v_employee.transport_voucher_value);
            INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
            VALUES (v_payroll_id, '2010', 'Desc. Vale Transporte', '6%', v_desc_vt, true, true);
            v_total_descontos := v_total_descontos + v_desc_vt;
        END;
    END IF;

    -- 4. Plano de Sa├║de
    IF COALESCE(v_employee.health_plan_discount, 0) > 0 THEN
        INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto)
        VALUES (v_payroll_id, '2070', 'Plano de Sa├║de', '', v_employee.health_plan_discount, true, true);
        v_total_descontos := v_total_descontos + v_employee.health_plan_discount;
    END IF;

    -- ===== PAGAMENTOS "POR FORA" =====
    IF v_complemento > 0 THEN
        INSERT INTO payroll_events (payroll_id, rubrica_codigo, descricao, referencia, valor, is_oficial, is_desconto, observacao)
        VALUES (
            v_payroll_id,
            '9000',
            'Complemento Salarial (por fora)',
            '',
            v_complemento,
            false,
            false,
            v_employee.salary_details->>'justificativa_por_fora'
        );
    END IF;

    -- ===== CALCULAR ENCARGOS =====
    v_fgts := v_base_inss * 0.08;

    -- ===== ATUALIZAR TOTAIS =====
    UPDATE payroll SET
        total_proventos_oficial = v_total_proventos,
        total_descontos_oficial = v_total_descontos,
        liquido_oficial = v_total_proventos - v_total_descontos,
        total_por_fora = v_complemento,
        liquido_total_real = (v_total_proventos - v_total_descontos) + v_complemento,
        fgts_valor = v_fgts,
        inss_empresa = v_base_inss * 0.20, -- 20% patronal
        provisao_ferias = v_base_inss / 12 * 1.3333, -- 1 m├¬s + 1/3
        provisao_13 = v_base_inss / 12,
        custo_total_empresa = v_total_proventos + v_fgts + (v_base_inss * 0.20) + (v_base_inss * 0.058) -- RAT + Terceiros
    WHERE id = v_payroll_id;

    RETURN v_payroll_id;
END;
$$;


ALTER FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") IS 'Gera folha de pagamento individual para um funcion├írio';



CREATE OR REPLACE FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") RETURNS TABLE("employee_name" "text", "payroll_id" "uuid", "liquido_oficial" numeric, "total_por_fora" numeric, "liquido_real" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_emp RECORD;
BEGIN
    -- CORRE├ç├âO: usar UPPER() para compara├º├úo case-insensitive
    FOR v_emp IN SELECT id, name FROM employees WHERE is_active AND UPPER(contract_type) = 'CLT' LOOP
        RETURN QUERY
        SELECT
            v_emp.name,
            gerar_folha_funcionario(v_emp.id, p_competencia),
            p.liquido_oficial,
            p.total_por_fora,
            p.liquido_total_real
        FROM payroll p
        WHERE p.employee_id = v_emp.id AND p.competencia = p_competencia;
    END LOOP;
END;
$$;


ALTER FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") IS 'Gera folha de pagamento mensal para todos funcion├írios CLT ativos';



CREATE OR REPLACE FUNCTION "public"."gerar_lancamento_contabil_folha"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_rubrica RECORD;
  v_entry_id UUID;
  v_payroll RECORD;
  v_employee RECORD;
BEGIN
  -- Buscar dados da rubrica
  SELECT * INTO v_rubrica FROM esocial_rubricas WHERE codigo = NEW.rubrica_codigo;

  -- Se rubrica n├úo tem vincula├º├úo cont├íbil, ignorar
  IF v_rubrica.account_debit_id IS NULL OR v_rubrica.account_credit_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Buscar dados da folha e funcion├írio
  SELECT * INTO v_payroll FROM payroll WHERE id = NEW.payroll_id;
  SELECT * INTO v_employee FROM employees WHERE id = v_payroll.employee_id;

  -- Criar lan├ºamento cont├íbil (CORRE├ç├âO: removido campo "status" que n├úo existe)
  INSERT INTO accounting_entries (
    entry_date,
    competence_date,
    description,
    reference_type,
    reference_id,
    entry_type,
    total_debit,
    total_credit
  ) VALUES (
    CURRENT_DATE,
    v_payroll.competencia,
    'Folha: ' || v_employee.name || ' - ' || NEW.descricao,
    'payroll',
    NEW.id,
    'payroll',
    NEW.valor,
    NEW.valor
  ) RETURNING id INTO v_entry_id;

  -- Criar linhas do lan├ºamento (d├®bito e cr├®dito)
  INSERT INTO accounting_entry_lines (entry_id, account_id, debit, credit, description)
  VALUES
    (v_entry_id, v_rubrica.account_debit_id, NEW.valor, 0, NEW.descricao),
    (v_entry_id, v_rubrica.account_credit_id, 0, NEW.valor, NEW.descricao);

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."gerar_lancamento_contabil_folha"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."gerar_lancamento_contabil_folha"() IS 'Gera lan├ºamento cont├íbil autom├ítico para eventos da folha de pagamento';



CREATE OR REPLACE FUNCTION "public"."get_account_balance"("p_account_id" "uuid", "p_as_of_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_balance DECIMAL;
  v_nature TEXT;
BEGIN
  SELECT nature INTO v_nature FROM chart_of_accounts WHERE id = p_account_id;

  SELECT
    CASE
      WHEN v_nature = 'debit' THEN COALESCE(SUM(jel.debit_amount), 0) - COALESCE(SUM(jel.credit_amount), 0)
      ELSE COALESCE(SUM(jel.credit_amount), 0) - COALESCE(SUM(jel.debit_amount), 0)
    END
  INTO v_balance
  FROM journal_entry_lines jel
  JOIN journal_entries je ON je.id = jel.journal_entry_id
  WHERE jel.account_id = p_account_id
    AND je.entry_date <= p_as_of_date;

  RETURN COALESCE(v_balance, 0);
END;
$$;


ALTER FUNCTION "public"."get_account_balance"("p_account_id" "uuid", "p_as_of_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_account_balances"("p_period_start" "date", "p_period_end" "date") RETURNS TABLE("account_id" "uuid", "account_code" character varying, "account_name" character varying, "account_type" character varying, "nature" character varying, "is_analytical" boolean, "opening_balance" numeric, "total_debits" numeric, "total_credits" numeric, "closing_balance" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH 
  -- Saldo de abertura: lan├ºamentos ANTES do per├¡odo + saldo_abertura DO per├¡odo
  opening AS (
    SELECT 
      ael.account_id,
      SUM(COALESCE(ael.debit, 0)) as debits,
      SUM(COALESCE(ael.credit, 0)) as credits
    FROM accounting_entry_lines ael
    JOIN accounting_entries ae ON ae.id = ael.entry_id
    WHERE (
      -- Lan├ºamentos anteriores ao per├¡odo
      ae.competence_date < p_period_start
      OR 
      -- OU lan├ºamentos saldo_abertura dentro do per├¡odo
      (ae.competence_date >= p_period_start 
       AND ae.competence_date <= p_period_end 
       AND ae.entry_type = 'saldo_abertura')
    )
    GROUP BY ael.account_id
  ),
  -- Movimenta├º├úo do per├¡odo (exceto saldo_abertura)
  movement AS (
    SELECT 
      ael.account_id,
      SUM(COALESCE(ael.debit, 0)) as debits,
      SUM(COALESCE(ael.credit, 0)) as credits
    FROM accounting_entry_lines ael
    JOIN accounting_entries ae ON ae.id = ael.entry_id
    WHERE ae.competence_date >= p_period_start 
      AND ae.competence_date <= p_period_end
      AND ae.entry_type != 'saldo_abertura'
    GROUP BY ael.account_id
  )
  SELECT 
    coa.id as account_id,
    coa.code as account_code,
    coa.name as account_name,
    coa.account_type,
    coa.nature,
    coa.is_analytical,
    -- Saldo de abertura considera natureza da conta
    CASE 
      WHEN coa.nature = 'DEVEDORA' THEN COALESCE(o.debits, 0) - COALESCE(o.credits, 0)
      ELSE COALESCE(o.credits, 0) - COALESCE(o.debits, 0)
    END as opening_balance,
    COALESCE(m.debits, 0) as total_debits,
    COALESCE(m.credits, 0) as total_credits,
    -- Saldo final
    CASE 
      WHEN coa.nature = 'DEVEDORA' THEN 
        (COALESCE(o.debits, 0) - COALESCE(o.credits, 0)) + COALESCE(m.debits, 0) - COALESCE(m.credits, 0)
      ELSE 
        (COALESCE(o.credits, 0) - COALESCE(o.debits, 0)) + COALESCE(m.credits, 0) - COALESCE(m.debits, 0)
    END as closing_balance
  FROM chart_of_accounts coa
  LEFT JOIN opening o ON o.account_id = coa.id
  LEFT JOIN movement m ON m.account_id = coa.id
  WHERE coa.is_active = true
  ORDER BY coa.code;
END;
$$;


ALTER FUNCTION "public"."get_account_balances"("p_period_start" "date", "p_period_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") RETURNS TABLE("line_id" "uuid", "entry_id" "uuid", "entry_date" "date", "competence_date" "date", "entry_number" integer, "entry_type" character varying, "document_number" character varying, "description" "text", "history" "text", "debit" numeric, "credit" numeric, "running_balance" numeric, "source_type" character varying, "is_opening_balance" boolean)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_opening_balance NUMERIC;
  v_account_nature VARCHAR(20);
BEGIN
  -- Buscar natureza da conta
  SELECT nature INTO v_account_nature
  FROM chart_of_accounts
  WHERE id = p_account_id;

  -- Calcular saldo de abertura (lan├ºamentos antes do per├¡odo + saldo_abertura do per├¡odo)
  SELECT 
    CASE 
      WHEN v_account_nature = 'DEVEDORA' THEN 
        COALESCE(SUM(ael.debit), 0) - COALESCE(SUM(ael.credit), 0)
      ELSE 
        COALESCE(SUM(ael.credit), 0) - COALESCE(SUM(ael.debit), 0)
    END
  INTO v_opening_balance
  FROM accounting_entry_lines ael
  JOIN accounting_entries ae ON ae.id = ael.entry_id
  WHERE ael.account_id = p_account_id
    AND (
      ae.competence_date < p_period_start
      OR (ae.competence_date >= p_period_start 
          AND ae.competence_date <= p_period_end 
          AND ae.entry_type = 'saldo_abertura')
    );

  v_opening_balance := COALESCE(v_opening_balance, 0);

  -- Retornar linha de saldo inicial primeiro
  RETURN QUERY
  SELECT 
    NULL::UUID as line_id,
    NULL::UUID as entry_id,
    p_period_start as entry_date,
    p_period_start as competence_date,
    0 as entry_number,
    'saldo_inicial'::VARCHAR(50) as entry_type,
    NULL::VARCHAR(100) as document_number,
    'SALDO ANTERIOR'::TEXT as description,
    'Saldo transportado do per├¡odo anterior'::TEXT as history,
    CASE WHEN v_account_nature = 'DEVEDORA' AND v_opening_balance > 0 THEN v_opening_balance ELSE 0 END as debit,
    CASE WHEN v_account_nature = 'CREDORA' AND v_opening_balance > 0 THEN v_opening_balance 
         WHEN v_account_nature = 'DEVEDORA' AND v_opening_balance < 0 THEN ABS(v_opening_balance)
         ELSE 0 END as credit,
    v_opening_balance as running_balance,
    'opening'::VARCHAR(50) as source_type,
    true as is_opening_balance;

  -- Retornar movimenta├º├Áes do per├¡odo com saldo corrente calculado
  RETURN QUERY
  WITH ordered_entries AS (
    SELECT 
      ael.id as line_id,
      ae.id as entry_id,
      ae.entry_date,
      ae.competence_date,
      ae.entry_number,
      ae.entry_type,
      ae.document_number,
      COALESCE(ae.description, ael.description) as description,
      ae.history,
      COALESCE(ael.debit, 0) as debit,
      COALESCE(ael.credit, 0) as credit,
      ae.source_type,
      ROW_NUMBER() OVER (ORDER BY ae.competence_date, ae.entry_number, ae.created_at) as rn
    FROM accounting_entry_lines ael
    JOIN accounting_entries ae ON ae.id = ael.entry_id
    WHERE ael.account_id = p_account_id
      AND ae.competence_date >= p_period_start 
      AND ae.competence_date <= p_period_end
      AND ae.entry_type != 'saldo_abertura'
    ORDER BY ae.competence_date, ae.entry_number, ae.created_at
  )
  SELECT 
    oe.line_id,
    oe.entry_id,
    oe.entry_date,
    oe.competence_date,
    oe.entry_number,
    oe.entry_type::VARCHAR(50),
    oe.document_number::VARCHAR(100),
    oe.description::TEXT,
    oe.history::TEXT,
    oe.debit,
    oe.credit,
    v_opening_balance + SUM(
      CASE 
        WHEN v_account_nature = 'DEVEDORA' THEN oe.debit - oe.credit
        ELSE oe.credit - oe.debit
      END
    ) OVER (ORDER BY oe.rn) as running_balance,
    oe.source_type::VARCHAR(50),
    false as is_opening_balance
  FROM ordered_entries oe;
END;
$$;


ALTER FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") IS 'Retorna o raz├úo cont├íbil de uma conta com saldo corrente acumulado para um per├¡odo';



CREATE OR REPLACE FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") RETURNS TABLE("account_id" "uuid", "account_code" character varying, "account_name" character varying, "account_type" character varying, "nature" character varying, "opening_balance" numeric, "total_debits" numeric, "total_credits" numeric, "closing_balance" numeric, "entry_count" bigint)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH 
  account_info AS (
    SELECT 
      coa.id,
      coa.code,
      coa.name,
      coa.account_type,
      coa.nature
    FROM chart_of_accounts coa
    WHERE coa.id = p_account_id
  ),
  opening AS (
    SELECT 
      SUM(COALESCE(ael.debit, 0)) as debits,
      SUM(COALESCE(ael.credit, 0)) as credits
    FROM accounting_entry_lines ael
    JOIN accounting_entries ae ON ae.id = ael.entry_id
    WHERE ael.account_id = p_account_id
      AND (
        ae.competence_date < p_period_start
        OR (ae.competence_date >= p_period_start 
            AND ae.competence_date <= p_period_end 
            AND ae.entry_type = 'saldo_abertura')
      )
  ),
  movement AS (
    SELECT 
      SUM(COALESCE(ael.debit, 0)) as debits,
      SUM(COALESCE(ael.credit, 0)) as credits,
      COUNT(*) as cnt
    FROM accounting_entry_lines ael
    JOIN accounting_entries ae ON ae.id = ael.entry_id
    WHERE ael.account_id = p_account_id
      AND ae.competence_date >= p_period_start 
      AND ae.competence_date <= p_period_end
      AND ae.entry_type != 'saldo_abertura'
  )
  SELECT 
    ai.id as account_id,
    ai.code as account_code,
    ai.name as account_name,
    ai.account_type,
    ai.nature,
    CASE 
      WHEN ai.nature = 'DEVEDORA' THEN COALESCE(o.debits, 0) - COALESCE(o.credits, 0)
      ELSE COALESCE(o.credits, 0) - COALESCE(o.debits, 0)
    END as opening_balance,
    COALESCE(m.debits, 0) as total_debits,
    COALESCE(m.credits, 0) as total_credits,
    CASE 
      WHEN ai.nature = 'DEVEDORA' THEN 
        (COALESCE(o.debits, 0) - COALESCE(o.credits, 0)) + COALESCE(m.debits, 0) - COALESCE(m.credits, 0)
      ELSE 
        (COALESCE(o.credits, 0) - COALESCE(o.debits, 0)) + COALESCE(m.credits, 0) - COALESCE(m.debits, 0)
    END as closing_balance,
    COALESCE(m.cnt, 0) as entry_count
  FROM account_info ai
  CROSS JOIN opening o
  CROSS JOIN movement m;
END;
$$;


ALTER FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") IS 'Retorna resumo do raz├úo cont├íbil (totais) de uma conta para um per├¡odo';



CREATE OR REPLACE FUNCTION "public"."get_account_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") RETURNS TABLE("debit_total" numeric, "credit_total" numeric, "net_movement" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_nature TEXT;
BEGIN
  SELECT nature INTO v_nature FROM chart_of_accounts WHERE id = p_account_id;

  RETURN QUERY
  SELECT
    COALESCE(SUM(jel.debit_amount), 0) AS debit_total,
    COALESCE(SUM(jel.credit_amount), 0) AS credit_total,
    CASE
      WHEN v_nature = 'debit' THEN COALESCE(SUM(jel.debit_amount), 0) - COALESCE(SUM(jel.credit_amount), 0)
      ELSE COALESCE(SUM(jel.credit_amount), 0) - COALESCE(SUM(jel.debit_amount), 0)
    END AS net_movement
  FROM journal_entry_lines jel
  JOIN journal_entries je ON je.id = jel.journal_entry_id
  WHERE jel.account_id = p_account_id
    AND je.entry_date BETWEEN p_start_date AND p_end_date;
END;
$$;


ALTER FUNCTION "public"."get_account_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") RETURNS TABLE("entry_date" "date", "document_number" "text", "description" "text", "history" "text", "debit" numeric, "credit" numeric, "running_balance" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_nature TEXT;
  v_opening_balance DECIMAL;
  v_running_balance DECIMAL;
  rec RECORD;
BEGIN
  -- Buscar natureza da conta
  SELECT coa.nature INTO v_nature FROM chart_of_accounts coa WHERE coa.id = p_account_id;
  
  -- Calcular saldo de abertura
  v_opening_balance := get_coa_opening_balance(p_account_id, p_start_date);
  v_running_balance := v_opening_balance;
  
  -- Retornar linha de saldo de abertura
  RETURN QUERY SELECT 
    p_start_date - INTERVAL '1 day',
    'ABERTURA'::TEXT,
    'Saldo Anterior'::TEXT,
    ''::TEXT,
    0::DECIMAL,
    0::DECIMAL,
    v_opening_balance;
  
  -- Retornar movimentos do per├¡odo com saldo acumulado
  FOR rec IN 
    SELECT 
      e.entry_date,
      e.document_number,
      e.description,
      i.history,
      i.debit,
      i.credit
    FROM accounting_entry_items i
    JOIN accounting_entries e ON e.id = i.entry_id
    WHERE i.account_id = p_account_id
      AND e.entry_date BETWEEN p_start_date AND p_end_date
      AND e.is_draft = FALSE
    ORDER BY e.entry_date, e.id
  LOOP
    -- Calcular saldo acumulado
    IF v_nature = 'DEVEDORA' THEN
      v_running_balance := v_running_balance + COALESCE(rec.debit, 0) - COALESCE(rec.credit, 0);
    ELSE
      v_running_balance := v_running_balance + COALESCE(rec.credit, 0) - COALESCE(rec.debit, 0);
    END IF;
    
    RETURN QUERY SELECT 
      rec.entry_date,
      rec.document_number,
      rec.description,
      rec.history,
      rec.debit,
      rec.credit,
      v_running_balance;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") IS 'Retorna extrato de conta com saldo acumulado';



CREATE TABLE IF NOT EXISTS "public"."accounting_office" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "razao_social" "text" NOT NULL,
    "nome_fantasia" "text",
    "cnpj" "text" NOT NULL,
    "crc_number" "text",
    "crc_state" "text",
    "responsavel_tecnico" "text",
    "responsavel_crc" "text",
    "responsavel_cpf" "text",
    "endereco" "text",
    "numero" "text",
    "complemento" "text",
    "bairro" "text",
    "cidade" "text",
    "estado" "text",
    "cep" "text",
    "telefone" "text",
    "celular" "text",
    "email" "text",
    "website" "text",
    "banco" "text",
    "agencia" "text",
    "conta" "text",
    "tipo_conta" "text",
    "pix_key" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "natureza_juridica" "text",
    "regime_tributario" "text",
    "porte" "text",
    "cnae_principal" "text",
    "descricao_cnae" "text",
    "capital_social" numeric(15,2),
    "data_abertura" "date",
    "situacao_cadastral" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."accounting_office" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_office" IS 'Dados do escrit├│rio cont├íbil AMPLA ASSESSORIA CONTABIL LTDA - CNPJ 23.893.032/0001-69 - CRC/GO 007640/O';



CREATE OR REPLACE FUNCTION "public"."get_accounting_office"() RETURNS "public"."accounting_office"
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT * FROM accounting_office WHERE is_active = true LIMIT 1;
$$;


ALTER FUNCTION "public"."get_accounting_office"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_accounting_office"() IS 'Retorna os dados do escrit├│rio cont├íbil ativo';



CREATE OR REPLACE FUNCTION "public"."get_balancete"("p_data_inicio" "date" DEFAULT '2025-01-01'::"date", "p_data_fim" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("codigo" character varying, "nome" character varying, "natureza" character varying, "saldo_anterior" numeric, "debitos" numeric, "creditos" numeric, "saldo_final" numeric, "qtd_lancamentos" bigint)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH 
  movimento AS (
    SELECT 
      l.account_id,
      SUM(CASE WHEN e.entry_date < p_data_inicio THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_ant,
      SUM(CASE WHEN e.entry_date < p_data_inicio THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_ant,
      SUM(CASE WHEN e.entry_date BETWEEN p_data_inicio AND p_data_fim THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_per,
      SUM(CASE WHEN e.entry_date BETWEEN p_data_inicio AND p_data_fim THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_per,
      COUNT(DISTINCT CASE WHEN e.entry_date BETWEEN p_data_inicio AND p_data_fim THEN l.entry_id END) AS qtd
    FROM accounting_entry_lines l
    JOIN accounting_entries e ON e.id = l.entry_id
    WHERE e.entry_date <= p_data_fim
    GROUP BY l.account_id
  )
  SELECT 
    c.code,
    c.name,
    c.nature,
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0)
    END::NUMERIC(15,2),
    COALESCE(m.deb_per, 0)::NUMERIC(15,2),
    COALESCE(m.cred_per, 0)::NUMERIC(15,2),
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0) + COALESCE(m.deb_per, 0) - COALESCE(m.cred_per, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0) + COALESCE(m.cred_per, 0) - COALESCE(m.deb_per, 0)
    END::NUMERIC(15,2),
    COALESCE(m.qtd, 0)
  FROM chart_of_accounts c
  LEFT JOIN movimento m ON m.account_id = c.id
  WHERE c.is_analytical = TRUE
    AND c.is_active = TRUE
    AND (
      COALESCE(m.deb_ant, 0) != 0 OR COALESCE(m.cred_ant, 0) != 0 OR
      COALESCE(m.deb_per, 0) != 0 OR COALESCE(m.cred_per, 0) != 0
    )
  ORDER BY c.code;
END;
$$;


ALTER FUNCTION "public"."get_balancete"("p_data_inicio" "date", "p_data_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_initial_balance DECIMAL;
    v_initial_date DATE;
    v_credits DECIMAL;
    v_debits DECIMAL;
BEGIN
    -- Buscar saldo inicial e data
    SELECT COALESCE(initial_balance, 0), initial_balance_date
    INTO v_initial_balance, v_initial_date
    FROM bank_accounts
    WHERE id = p_bank_account_id;

    -- Se a data solicitada ├® anterior ao saldo inicial, retornar NULL
    IF p_date < v_initial_date THEN
        RETURN NULL;
    END IF;

    -- Somar cr├®ditos at├® a data (incluindo a data)
    SELECT COALESCE(SUM(ABS(amount)), 0) INTO v_credits
    FROM bank_transactions
    WHERE bank_account_id = p_bank_account_id
      AND transaction_date <= p_date
      AND transaction_type = 'credit';

    -- Somar d├®bitos at├® a data
    SELECT COALESCE(SUM(ABS(amount)), 0) INTO v_debits
    FROM bank_transactions
    WHERE bank_account_id = p_bank_account_id
      AND transaction_date <= p_date
      AND transaction_type = 'debit';

    -- Retornar saldo: inicial + cr├®ditos - d├®bitos
    RETURN v_initial_balance + v_credits - v_debits;
END;
$$;


ALTER FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") IS 'Calcula o saldo banc├írio em uma data espec├¡fica';



CREATE OR REPLACE FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_balance DECIMAL(10,2);
BEGIN
  SELECT COALESCE(
    SUM(CASE WHEN type = 'credit' THEN amount ELSE -amount END), 0
  )
  INTO v_balance
  FROM barter_credits
  WHERE client_id = p_client_id;
  
  RETURN v_balance;
END;
$$;


ALTER FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") IS 'Calcula o saldo atual de cr├®ditos de permuta de um cliente';



CREATE OR REPLACE FUNCTION "public"."get_chart_of_accounts_with_balances"("p_year" integer DEFAULT (EXTRACT(year FROM CURRENT_DATE))::integer, "p_month" integer DEFAULT (EXTRACT(month FROM CURRENT_DATE))::integer) RETURNS TABLE("id" "uuid", "code" character varying, "name" character varying, "account_type" character varying, "nature" character varying, "level" integer, "is_analytical" boolean, "parent_id" "uuid", "is_active" boolean, "opening_balance" numeric, "total_debits" numeric, "total_credits" numeric, "closing_balance" numeric, "entry_count" bigint)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_period_start DATE;
  v_period_end DATE;
BEGIN
  v_period_start := make_date(p_year, p_month, 1);
  v_period_end := (v_period_start + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

  RETURN QUERY
  WITH 
  -- Movimento baseado em entry_date (EXTRATO BANC├üRIO = fonte da verdade)
  movimento AS (
    SELECT 
      l.account_id,
      -- Saldo anterior: tudo ANTES do per├¡odo
      SUM(CASE WHEN e.entry_date < v_period_start THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_ant,
      SUM(CASE WHEN e.entry_date < v_period_start THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_ant,
      -- Movimento do per├¡odo
      SUM(CASE WHEN e.entry_date BETWEEN v_period_start AND v_period_end THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_per,
      SUM(CASE WHEN e.entry_date BETWEEN v_period_start AND v_period_end THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_per,
      COUNT(DISTINCT CASE WHEN e.entry_date BETWEEN v_period_start AND v_period_end THEN l.entry_id END) AS qtd
    FROM accounting_entry_lines l
    JOIN accounting_entries e ON e.id = l.entry_id
    WHERE e.entry_date <= v_period_end
    GROUP BY l.account_id
  )
  SELECT 
    c.id,
    c.code,
    c.name,
    c.account_type,
    c.nature,
    c.level,
    c.is_analytical,
    c.parent_id,
    c.is_active,
    -- Saldo Abertura (tudo antes do per├¡odo)
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0)
    END AS opening_balance,
    -- D├®bitos do per├¡odo
    COALESCE(m.deb_per, 0) AS total_debits,
    -- Cr├®ditos do per├¡odo
    COALESCE(m.cred_per, 0) AS total_credits,
    -- Saldo Final
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0) + COALESCE(m.deb_per, 0) - COALESCE(m.cred_per, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0) + COALESCE(m.cred_per, 0) - COALESCE(m.deb_per, 0)
    END AS closing_balance,
    COALESCE(m.qtd, 0) AS entry_count
  FROM chart_of_accounts c
  LEFT JOIN movimento m ON m.account_id = c.id
  WHERE c.is_active = TRUE
  ORDER BY c.code;
END;
$$;


ALTER FUNCTION "public"."get_chart_of_accounts_with_balances"("p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cnpj_branch"("cnpj_value" "text") RETURNS "text"
    LANGUAGE "sql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT substring(regexp_replace(cnpj_value, '[^0-9]', '', 'g'), 9, 4);
$$;


ALTER FUNCTION "public"."get_cnpj_branch"("cnpj_value" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cnpj_root"("cnpj_value" "text") RETURNS "text"
    LANGUAGE "sql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT substring(regexp_replace(cnpj_value, '[^0-9]', '', 'g'), 1, 8);
$$;


ALTER FUNCTION "public"."get_cnpj_root"("cnpj_value" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_balance DECIMAL;
  v_nature TEXT;
BEGIN
  -- Buscar natureza da conta (DEVEDORA ou CREDORA)
  SELECT nature INTO v_nature FROM chart_of_accounts WHERE id = p_account_id;

  -- Calcular saldo baseado na natureza
  -- Contas DEVEDORAS (Ativo/Despesa): Saldo = D├®bitos - Cr├®ditos
  -- Contas CREDORAS (Passivo/Receita/PL): Saldo = Cr├®ditos - D├®bitos
  SELECT
    CASE
      WHEN v_nature = 'DEVEDORA' THEN COALESCE(SUM(i.debit), 0) - COALESCE(SUM(i.credit), 0)
      ELSE COALESCE(SUM(i.credit), 0) - COALESCE(SUM(i.debit), 0)
    END
  INTO v_balance
  FROM accounting_entry_items i
  JOIN accounting_entries e ON e.id = i.entry_id
  WHERE i.account_id = p_account_id
    AND e.entry_date <= p_as_of_date
    AND e.is_draft = FALSE;

  RETURN COALESCE(v_balance, 0);
END;
$$;


ALTER FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date") IS 'Retorna o saldo de uma conta at├® determinada data';



CREATE OR REPLACE FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") RETURNS TABLE("total_debit" numeric, "total_credit" numeric, "net_movement" numeric, "entry_count" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_nature TEXT;
BEGIN
  SELECT nature INTO v_nature FROM chart_of_accounts WHERE id = p_account_id;

  RETURN QUERY
  SELECT
    COALESCE(SUM(i.debit), 0)::DECIMAL AS total_debit,
    COALESCE(SUM(i.credit), 0)::DECIMAL AS total_credit,
    (CASE
      WHEN v_nature = 'DEVEDORA' THEN COALESCE(SUM(i.debit), 0) - COALESCE(SUM(i.credit), 0)
      ELSE COALESCE(SUM(i.credit), 0) - COALESCE(SUM(i.debit), 0)
    END)::DECIMAL AS net_movement,
    COUNT(DISTINCT i.entry_id)::INTEGER AS entry_count
  FROM accounting_entry_items i
  JOIN accounting_entries e ON e.id = i.entry_id
  WHERE i.account_id = p_account_id
    AND e.entry_date BETWEEN p_start_date AND p_end_date
    AND e.is_draft = FALSE;
END;
$$;


ALTER FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") IS 'Retorna d├®bitos, cr├®ditos e movimento l├¡quido em um per├¡odo';



CREATE OR REPLACE FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Saldo de abertura = todos os lan├ºamentos AT├ë o dia anterior ao in├¡cio do per├¡odo
  RETURN get_coa_balance(p_account_id, p_period_start - INTERVAL '1 day');
END;
$$;


ALTER FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") IS 'Retorna o saldo de abertura de uma conta';



CREATE OR REPLACE FUNCTION "public"."get_current_minimum_wage"() RETURNS TABLE("value" numeric, "effective_date" "date", "end_date" "date", "source" "text")
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    mwh.value,
    mwh.effective_date,
    mwh.end_date,
    mwh.source
  FROM minimum_wage_history mwh
  WHERE mwh.end_date IS NULL
     OR mwh.end_date >= CURRENT_DATE
  ORDER BY mwh.effective_date DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_current_minimum_wage"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_current_minimum_wage"() IS 'Retorna o sal├írio m├¡nimo atual vigente';



CREATE OR REPLACE FUNCTION "public"."get_current_tenant_id"() RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  tenant_id UUID;
BEGIN
  SELECT tu.tenant_id INTO tenant_id
  FROM tenant_users tu
  WHERE tu.user_id = auth.uid()
    AND tu.is_active = true
  LIMIT 1;

  RETURN tenant_id;
END;
$$;


ALTER FUNCTION "public"."get_current_tenant_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_economic_group_by_client"("p_client_id" "uuid") RETURNS TABLE("group_id" "uuid", "group_name" "text", "main_payer_client_id" "uuid", "total_monthly_fee" numeric, "payment_day" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT eg.id, eg.name, eg.main_payer_client_id, eg.total_monthly_fee, eg.payment_day
  FROM economic_groups eg
  JOIN economic_group_members egm ON eg.id = egm.economic_group_id
  WHERE egm.client_id = p_client_id
  AND eg.is_active = true
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_economic_group_by_client"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_economic_group_impact"("p_year" integer DEFAULT NULL::integer) RETURNS TABLE("group_key" "text", "partner_names" "text"[], "company_count" bigint, "company_names" "text"[], "company_ids" "uuid"[], "total_revenue" numeric, "percentage_of_total" numeric, "risk_level" "text")
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  total_year_revenue NUMERIC;
BEGIN
  -- Calculate total revenue for the year
  SELECT COALESCE(SUM(amount), 0)
  INTO total_year_revenue
  FROM invoices
  WHERE status = 'paid'
    AND (p_year IS NULL OR EXTRACT(YEAR FROM payment_date::date) = p_year);

  -- If no revenue, return empty result
  IF total_year_revenue = 0 THEN
    total_year_revenue := 1; -- Avoid division by zero
  END IF;

  RETURN QUERY
  WITH company_partners AS (
    SELECT
      client_id,
      ARRAY_AGG(DISTINCT COALESCE(cpf, name) ORDER BY COALESCE(cpf, name))::TEXT[] as partners_array
    FROM client_partners
    GROUP BY client_id
  ),
  grouped_companies AS (
    SELECT
      ARRAY_TO_STRING(partners_array, '|') as group_key,
      partners_array,
      ARRAY_AGG(client_id)::UUID[] as company_ids
    FROM company_partners
    GROUP BY ARRAY_TO_STRING(partners_array, '|'), partners_array
    HAVING COUNT(*) > 1
  ),
  company_revenues AS (
    SELECT
      i.client_id,
      COALESCE(SUM(i.amount), 0) as revenue
    FROM invoices i
    WHERE i.status = 'paid'
      AND (p_year IS NULL OR EXTRACT(YEAR FROM i.payment_date::date) = p_year)
    GROUP BY i.client_id
  ),
  group_analysis AS (
    SELECT
      gc.group_key,
      gc.partners_array as partner_names,
      CARDINALITY(gc.company_ids) as company_count,
      ARRAY(
        SELECT c.name
        FROM clients c
        WHERE c.id = ANY(gc.company_ids)
      )::TEXT[] as company_names,
      gc.company_ids,
      COALESCE(SUM(cr.revenue), 0) as total_revenue,
      ROUND((COALESCE(SUM(cr.revenue), 0) / NULLIF(total_year_revenue, 0)) * 100, 2) as percentage_of_total
    FROM grouped_companies gc
    LEFT JOIN company_revenues cr ON cr.client_id = ANY(gc.company_ids)
    GROUP BY gc.group_key, gc.partners_array, gc.company_ids
  )
  SELECT
    ga.group_key,
    ga.partner_names,
    ga.company_count,
    ga.company_names,
    ga.company_ids,
    ga.total_revenue,
    ga.percentage_of_total,
    CASE
      WHEN ga.percentage_of_total >= 20 THEN 'high'
      WHEN ga.percentage_of_total >= 10 THEN 'medium'
      ELSE 'low'
    END as risk_level
  FROM group_analysis ga
  WHERE ga.total_revenue > 0
  ORDER BY ga.total_revenue DESC;
END;
$$;


ALTER FUNCTION "public"."get_economic_group_impact"("p_year" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_economic_group_impact"("p_year" integer) IS 'Calcula o impacto financeiro de grupos econ├┤micos (empresas com s├│cios em comum)';



CREATE OR REPLACE FUNCTION "public"."get_expense_account_id"("p_category" "text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_id UUID;
  v_code TEXT;
BEGIN
  -- Mapear categoria para c├│digo de conta
  v_code := CASE LOWER(COALESCE(p_category, 'default'))
    WHEN 'salarios' THEN '4.1.1.01'
    WHEN 'encargos' THEN '4.1.1.02'
    WHEN 'aluguel' THEN '4.1.2.01'
    WHEN 'energia' THEN '4.1.2.02'
    WHEN 'telefone' THEN '4.1.2.03'
    WHEN 'internet' THEN '4.1.2.03'
    WHEN 'material' THEN '4.1.2.04'
    WHEN 'servicos' THEN '4.1.2.05'
    WHEN 'juros' THEN '4.1.3.01'
    WHEN 'tarifas' THEN '4.1.3.02'
    ELSE '4.1.2.99'
  END;

  -- Buscar conta
  SELECT id INTO v_account_id
  FROM chart_of_accounts
  WHERE code = v_code;

  -- Se n├úo encontrar, usar conta padr├úo
  IF v_account_id IS NULL THEN
    SELECT id INTO v_account_id
    FROM chart_of_accounts
    WHERE code = '4.1.2.99';
  END IF;

  RETURN v_account_id;
END;
$$;


ALTER FUNCTION "public"."get_expense_account_id"("p_category" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_expense_account_id"("p_category" "text") IS 'Mapeia categoria de despesa para conta cont├íbil';



CREATE OR REPLACE FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") RETURNS TABLE("account_id" "uuid", "is_adiantamento" boolean, "entry_type" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_id UUID;
  v_is_adiantamento BOOLEAN := FALSE;
  v_entry_type TEXT := 'despesa';
  v_code TEXT;
BEGIN
  -- Verificar se ├® adiantamento a s├│cios
  IF LOWER(COALESCE(p_category, '')) IN (
    'adiantamento a s├│cios',
    'adiantamento a socios',
    'adiantamento sergio',
    'adiantamento carla',
    'adiantamento victor',
    'adiantamento nayara',
    'adiantamento augusto',
    'despesas particulares',
    'gastos pessoais',
    'familia'
  ) THEN
    v_is_adiantamento := TRUE;
    v_entry_type := 'adiantamento';

    SELECT id INTO v_account_id
    FROM chart_of_accounts
    WHERE code = '1.2.3.01';  -- Adiantamento a S├│cios

  ELSE
    -- Mapear categoria para conta de DESPESA (CORRIGIDO!)
    v_code := CASE LOWER(COALESCE(p_category, 'default'))
      WHEN 'salarios' THEN '4.1.1.01'
      WHEN 'folha de pagamento' THEN '4.1.1.01'
      WHEN 'encargos' THEN '4.1.1.02'
      WHEN 'encargos de sal├írios' THEN '4.1.1.02'
      WHEN 'aluguel' THEN '4.1.2.01'
      WHEN 'energia' THEN '4.1.2.02'
      WHEN 'telefone' THEN '4.1.2.03'
      WHEN 'plano telefone' THEN '4.1.2.03'
      WHEN 'pano telefone' THEN '4.1.2.03'
      WHEN 'internet' THEN '4.1.2.03'
      WHEN 'material' THEN '4.1.2.04'
      WHEN 'materiais de papelaria' THEN '4.1.2.04'
      WHEN 'servicos' THEN '4.1.2.05'
      WHEN 'servicos terceiros' THEN '4.1.2.05'
      -- *** CORRE├ç├âO AQUI: software/sistemas vai para 4.1.2.12, N├âO 4.1.2.06 ***
      WHEN 'software/sistemas' THEN '4.1.2.12'
      WHEN 'software' THEN '4.1.2.12'
      WHEN 'sistemas' THEN '4.1.2.12'
      WHEN 'assinatura software' THEN '4.1.2.12'
      WHEN 'licencas software' THEN '4.1.2.12'
      -- G├ís vai para 4.1.2.06
      WHEN 'gas' THEN '4.1.2.06'
      WHEN 'g├ís' THEN '4.1.2.06'
      WHEN 'botijao' THEN '4.1.2.06'
      WHEN 'botij├úo' THEN '4.1.2.06'
      -- Outras categorias
      WHEN 'juros' THEN '4.1.3.01'
      WHEN 'tarifas' THEN '4.1.3.02'
      WHEN 'taxa/manutencao boleto' THEN '4.1.3.02'
      WHEN 'manutencao de conta' THEN '4.1.3.02'
      WHEN 'impostos' THEN '4.1.4.01'
      WHEN 'simples nacional' THEN '4.1.4.01'
      WHEN 'imposto iss' THEN '4.1.4.01'
      WHEN 'iptu' THEN '4.1.4.03'
      WHEN 'ipva' THEN '4.1.4.01'
      WHEN 'taxas e licen├ºas profissionais' THEN '4.1.4.02'
      WHEN 'condominio' THEN '4.1.2.10'
      WHEN 'agua funcionarios' THEN '4.1.2.09'
      WHEN 'vale alimentacao' THEN '4.1.1.03'
      WHEN 'plano de saude' THEN '4.1.1.04'
      WHEN 'obras/reforma' THEN '4.1.2.11'
      WHEN 'materiais de limpeza/higiene' THEN '4.1.2.08'
      WHEN 'suprimentos para copa/cozinha' THEN '4.1.2.09'
      ELSE '4.1.2.99'
    END;

    SELECT id INTO v_account_id
    FROM chart_of_accounts
    WHERE code = v_code;

    -- Fallback
    IF v_account_id IS NULL THEN
      SELECT id INTO v_account_id
      FROM chart_of_accounts
      WHERE code = '4.1.2.99';
    END IF;
  END IF;

  RETURN QUERY SELECT v_account_id, v_is_adiantamento, v_entry_type;
END;
$$;


ALTER FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") IS 'Retorna a conta cont├íbil correta para uma categoria de despesa. 
   CORRIGIDO em 15/12/2025: software/sistemas agora vai para 4.1.2.12 (Software e Sistemas), n├úo 4.1.2.06 (G├ís)';



CREATE OR REPLACE FUNCTION "public"."get_group_invoices_for_competence"("p_client_id" "uuid", "p_competence" "text") RETURNS TABLE("id" "uuid", "client_id" "uuid", "amount" numeric, "due_date" "date", "status" "text", "competence" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT i.id, i.client_id, i.amount, i.due_date, i.status, i.competence
  FROM invoices i
  JOIN economic_group_members egm ON i.client_id = egm.client_id
  WHERE egm.economic_group_id = (
    SELECT economic_group_id 
    FROM economic_group_members 
    WHERE client_id = p_client_id
    LIMIT 1
  )
  AND i.competence = p_competence
  AND i.status IN ('pending', 'overdue');
END;
$$;


ALTER FUNCTION "public"."get_group_invoices_for_competence"("p_client_id" "uuid", "p_competence" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_labor_solutions_for_person"("p_person_type" "text", "p_person_id" "uuid") RETURNS TABLE("solution_code" "text", "solution_name" "text", "description" "text", "implementation_steps" "jsonb", "effectiveness" integer, "complexity" "text", "time_to_implement" "text", "legal_basis" "text"[], "warnings" "text"[], "relevance_score" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_risk_type TEXT;
    v_unofficial_ratio NUMERIC;
BEGIN
    -- Determinar tipo de risco baseado na pessoa
    IF p_person_type = 'employee' THEN
        SELECT
            CASE
                WHEN unofficial_salary > 0 THEN 'pagamento_nao_registrado'
                ELSE 'vinculo_trabalhista'
            END,
            (unofficial_salary::numeric / NULLIF(official_salary + unofficial_salary, 0) * 100)
        INTO v_risk_type, v_unofficial_ratio
        FROM employees
        WHERE id = p_person_id;
    ELSE
        v_risk_type := 'terceirizacao';
    END IF;

    RETURN QUERY
    SELECT
        lss.code,
        lss.name,
        lss.description,
        lss.implementation_steps,
        lss.effectiveness_rating,
        lss.complexity,
        lss.time_to_implement,
        lss.legal_basis,
        lss.warnings,
        CASE
            WHEN lss.code = ANY(rsm.solution_codes) THEN
                10 - array_position(rsm.solution_codes, lss.code)
            ELSE 0
        END as relevance_score
    FROM labor_solution_strategies lss
    LEFT JOIN risk_solution_mapping rsm ON lss.code = ANY(rsm.solution_codes)
        AND rsm.risk_type = v_risk_type
    WHERE rsm.risk_type = v_risk_type
    ORDER BY relevance_score DESC;
END;
$$;


ALTER FUNCTION "public"."get_labor_solutions_for_person"("p_person_type" "text", "p_person_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT value
  FROM minimum_wage_history
  WHERE effective_date <= p_date
  ORDER BY effective_date DESC
  LIMIT 1;
$$;


ALTER FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date") IS 'Retorna o sal├írio m├¡nimo vigente em uma data';



CREATE OR REPLACE FUNCTION "public"."get_my_tenant_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$SELECT tenant_id FROM public.tenant_users WHERE user_id = auth.uid() LIMIT 1$$;


ALTER FUNCTION "public"."get_my_tenant_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_next_client_account_code"() RETURNS character varying
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_max_code VARCHAR;
    v_next_num INT;
BEGIN
    SELECT MAX(code) INTO v_max_code 
    FROM chart_of_accounts 
    WHERE code LIKE '1.1.2.01.%' AND code ~ '^1\.1\.2\.01\.[0-9]+$';
    
    IF v_max_code IS NULL THEN
        v_next_num := 1;
    ELSE
        v_next_num := CAST(SUBSTRING(v_max_code FROM '\.([0-9]+)$') AS INT) + 1;
    END IF;
    
    RETURN '1.1.2.01.' || LPAD(v_next_num::TEXT, 4, '0');
END;
$_$;


ALTER FUNCTION "public"."get_next_client_account_code"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_next_period"("p_year" integer, "p_month" integer) RETURNS TABLE("next_year" integer, "next_month" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF p_month = 12 THEN
    RETURN QUERY SELECT p_year + 1, 1;
  ELSE
    RETURN QUERY SELECT p_year, p_month + 1;
  END IF;
END;
$$;


ALTER FUNCTION "public"."get_next_period"("p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_next_validation_item"() RETURNS TABLE("queue_id" "uuid", "entry_id" "uuid", "entry_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH next_item AS (
    SELECT q.id, q.entry_id
    FROM ai_validation_queue q
    WHERE q.status IN ('pending', 'retry')
      AND q.attempts < q.max_attempts
    ORDER BY q.priority ASC, q.created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
  )
  UPDATE ai_validation_queue SET
    status = 'processing',
    started_at = now(),
    attempts = attempts + 1
  FROM next_item
  WHERE ai_validation_queue.id = next_item.id
  RETURNING
    next_item.id as queue_id,
    next_item.entry_id,
    (SELECT to_jsonb(e.*) || jsonb_build_object(
      'lines', (
        SELECT jsonb_agg(to_jsonb(l.*) || jsonb_build_object(
          'account_code', c.code,
          'account_name', c.name
        ))
        FROM accounting_entry_lines l
        JOIN chart_of_accounts c ON c.id = l.account_id
        WHERE l.entry_id = next_item.entry_id
      )
    ) FROM accounting_entries e WHERE e.id = next_item.entry_id) as entry_data;
END;
$$;


ALTER FUNCTION "public"."get_next_validation_item"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_next_validation_item"() IS 'Retorna o pr├│ximo item da fila para processar';



CREATE OR REPLACE FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_id UUID;
  v_next_code TEXT;
  v_last_num INTEGER;
BEGIN
  -- Buscar conta existente do cliente
  SELECT id INTO v_account_id
  FROM chart_of_accounts
  WHERE name ILIKE '%' || p_client_name || '%'
    AND code LIKE '1.1.2.01.%'
  LIMIT 1;

  IF v_account_id IS NOT NULL THEN
    RETURN v_account_id;
  END IF;

  -- Criar nova conta para o cliente
  -- Encontrar pr├│ximo c├│digo dispon├¡vel
  SELECT COALESCE(MAX(CAST(SPLIT_PART(code, '.', 5) AS INTEGER)), 0) + 1
  INTO v_last_num
  FROM chart_of_accounts
  WHERE code LIKE '1.1.2.01.%';

  v_next_code := '1.1.2.01.' || LPAD(v_last_num::TEXT, 3, '0');

  -- Garantir que a conta pai existe
  INSERT INTO chart_of_accounts (code, name, account_type, nature, level, is_analytical, is_active)
  VALUES ('1.1.2.01', 'Clientes a Receber', 'ATIVO', 'DEVEDORA', 4, false, true)
  ON CONFLICT (code) DO NOTHING;

  -- Criar conta do cliente
  INSERT INTO chart_of_accounts (code, name, account_type, nature, level, is_analytical, is_active, parent_id)
  VALUES (
    v_next_code,
    'Cliente: ' || p_client_name,
    'ATIVO',
    'DEVEDORA',
    5,
    true,
    true,
    (SELECT id FROM chart_of_accounts WHERE code = '1.1.2.01')
  )
  RETURNING id INTO v_account_id;

  RETURN v_account_id;
END;
$$;


ALTER FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") IS 'Obt├®m ou cria conta cont├íbil para um cliente espec├¡fico';



CREATE OR REPLACE FUNCTION "public"."get_overdue_summary"("p_year" integer DEFAULT NULL::integer, "p_month" integer DEFAULT NULL::integer) RETURNS TABLE("one_month_count" bigint, "one_month_amount" numeric, "two_months_count" bigint, "two_months_amount" numeric, "three_plus_months_count" bigint, "three_plus_months_amount" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY WITH overdue_categorized AS (
    SELECT i.amount, CASE
        WHEN DATE_PART('day', CURRENT_DATE - i.due_date) >= 90 THEN '3+'
        WHEN DATE_PART('day', CURRENT_DATE - i.due_date) >= 60 THEN '2'
        WHEN DATE_PART('day', CURRENT_DATE - i.due_date) >= 30 THEN '1'
        ELSE '0' END as category
    FROM invoices i
    WHERE i.status = 'overdue' AND i.tenant_id = public.get_my_tenant_id()
      AND (p_year IS NULL OR EXTRACT(YEAR FROM i.due_date) = p_year)
      AND (p_month IS NULL OR EXTRACT(MONTH FROM i.due_date) = p_month)
  )
  SELECT COUNT(*) FILTER (WHERE category = '1'), COALESCE(SUM(amount) FILTER (WHERE category = '1'), 0),
         COUNT(*) FILTER (WHERE category = '2'), COALESCE(SUM(amount) FILTER (WHERE category = '2'), 0),
         COUNT(*) FILTER (WHERE category = '3+'), COALESCE(SUM(amount) FILTER (WHERE category = '3+'), 0)
  FROM overdue_categorized;
END;
$$;


ALTER FUNCTION "public"."get_overdue_summary"("p_year" integer, "p_month" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_overdue_summary"("p_year" integer, "p_month" integer) IS 'Retorna sum├írio de inadimpl├¬ncia segmentado por per├¡odo de atraso';



CREATE OR REPLACE FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_balance DECIMAL;
BEGIN
  SELECT COALESCE(SUM(
    CASE
      WHEN ael.debit_credit = 'D' THEN ael.amount
      ELSE -ael.amount
    END
  ), 0)
  INTO v_balance
  FROM accounting_entry_lines ael
  JOIN chart_of_accounts coa ON ael.account_id = coa.id
  WHERE coa.code = CASE
    WHEN partner_code = 'SERGIO' THEN '1.1.3.04.01'
    ELSE '1.1.3.04.02'
  END;

  RETURN v_balance;
END;
$$;


ALTER FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") IS 'Retorna saldo de adiantamentos do s├│cio';



CREATE OR REPLACE FUNCTION "public"."get_plano_contas_com_saldos"("p_ano" integer DEFAULT (EXTRACT(year FROM CURRENT_DATE))::integer, "p_mes" integer DEFAULT (EXTRACT(month FROM CURRENT_DATE))::integer) RETURNS TABLE("id" "uuid", "codigo" character varying, "nome" character varying, "tipo_conta" character varying, "natureza" character varying, "nivel" integer, "analitica" boolean, "parent_id" "uuid", "ativa" boolean, "saldo_anterior" numeric, "debitos" numeric, "creditos" numeric, "saldo_final" numeric, "qtd_lancamentos" bigint)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_data_inicio DATE;
  v_data_fim DATE;
BEGIN
  v_data_inicio := make_date(p_ano, p_mes, 1);
  v_data_fim := (v_data_inicio + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  
  RETURN QUERY
  WITH 
  -- Movimento baseado em entry_date (fonte: extrato banc├írio)
  movimento AS (
    SELECT 
      l.account_id,
      -- Saldo anterior: tudo ANTES do per├¡odo
      SUM(CASE WHEN e.entry_date < v_data_inicio THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_ant,
      SUM(CASE WHEN e.entry_date < v_data_inicio THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_ant,
      -- Movimento do per├¡odo
      SUM(CASE WHEN e.entry_date BETWEEN v_data_inicio AND v_data_fim THEN COALESCE(l.debit, 0) ELSE 0 END) AS deb_per,
      SUM(CASE WHEN e.entry_date BETWEEN v_data_inicio AND v_data_fim THEN COALESCE(l.credit, 0) ELSE 0 END) AS cred_per,
      COUNT(DISTINCT CASE WHEN e.entry_date BETWEEN v_data_inicio AND v_data_fim THEN l.entry_id END) AS qtd
    FROM accounting_entry_lines l
    JOIN accounting_entries e ON e.id = l.entry_id
    WHERE e.entry_date <= v_data_fim
    GROUP BY l.account_id
  )
  SELECT 
    c.id,
    c.code,
    c.name,
    c.account_type,
    c.nature,
    c.level,
    c.is_analytical,
    c.parent_id,
    c.is_active,
    -- Saldo anterior
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0)
    END::NUMERIC(15,2),
    -- D├®bitos
    COALESCE(m.deb_per, 0)::NUMERIC(15,2),
    -- Cr├®ditos
    COALESCE(m.cred_per, 0)::NUMERIC(15,2),
    -- Saldo final
    CASE WHEN c.nature = 'DEVEDORA' 
      THEN COALESCE(m.deb_ant, 0) - COALESCE(m.cred_ant, 0) + COALESCE(m.deb_per, 0) - COALESCE(m.cred_per, 0)
      ELSE COALESCE(m.cred_ant, 0) - COALESCE(m.deb_ant, 0) + COALESCE(m.cred_per, 0) - COALESCE(m.deb_per, 0)
    END::NUMERIC(15,2),
    COALESCE(m.qtd, 0)
  FROM chart_of_accounts c
  LEFT JOIN movimento m ON m.account_id = c.id
  WHERE c.is_active = TRUE
  ORDER BY c.code;
END;
$$;


ALTER FUNCTION "public"."get_plano_contas_com_saldos"("p_ano" integer, "p_mes" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_razao_conta"("p_codigo_conta" character varying, "p_data_inicio" "date" DEFAULT '2025-01-01'::"date", "p_data_fim" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("linha_tipo" character varying, "data" "date", "documento" character varying, "historico" "text", "debito" numeric, "credito" numeric, "saldo" numeric)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_id UUID;
  v_nature VARCHAR(20);
  v_saldo_anterior NUMERIC := 0;
BEGIN
  -- Buscar dados da conta
  SELECT id, nature INTO v_account_id, v_nature
  FROM chart_of_accounts 
  WHERE code = p_codigo_conta;
  
  IF v_account_id IS NULL THEN
    RAISE EXCEPTION 'Conta % n├úo encontrada', p_codigo_conta;
  END IF;
  
  -- Calcular saldo anterior (todos os lan├ºamentos ANTES do per├¡odo)
  SELECT COALESCE(
    CASE WHEN v_nature = 'DEVEDORA' 
      THEN SUM(COALESCE(l.debit, 0)) - SUM(COALESCE(l.credit, 0))
      ELSE SUM(COALESCE(l.credit, 0)) - SUM(COALESCE(l.debit, 0))
    END, 0)
  INTO v_saldo_anterior
  FROM accounting_entry_lines l
  JOIN accounting_entries e ON e.id = l.entry_id
  WHERE l.account_id = v_account_id
    AND e.entry_date < p_data_inicio;
  
  -- Retornar raz├úo
  RETURN QUERY
  
  -- Linha 1: Saldo Anterior
  SELECT 
    'SALDO_ANTERIOR'::VARCHAR(20),
    p_data_inicio,
    'TRANSPORTE'::VARCHAR(100),
    'Saldo transportado do per├¡odo anterior'::TEXT,
    0::NUMERIC(15,2),
    0::NUMERIC(15,2),
    v_saldo_anterior::NUMERIC(15,2)
  
  UNION ALL
  
  -- Lan├ºamentos do per├¡odo
  SELECT 
    'LANCAMENTO'::VARCHAR(20),
    e.entry_date,
    COALESCE(e.document_number, SUBSTRING(e.id::TEXT, 1, 8))::VARCHAR(100),
    COALESCE(l.description, e.description)::TEXT,
    COALESCE(l.debit, 0)::NUMERIC(15,2),
    COALESCE(l.credit, 0)::NUMERIC(15,2),
    (v_saldo_anterior + SUM(
      CASE WHEN v_nature = 'DEVEDORA' 
        THEN COALESCE(l.debit, 0) - COALESCE(l.credit, 0)
        ELSE COALESCE(l.credit, 0) - COALESCE(l.debit, 0)
      END
    ) OVER (ORDER BY e.entry_date, e.created_at ROWS UNBOUNDED PRECEDING))::NUMERIC(15,2)
  FROM accounting_entry_lines l
  JOIN accounting_entries e ON e.id = l.entry_id
  WHERE l.account_id = v_account_id
    AND e.entry_date BETWEEN p_data_inicio AND p_data_fim
  
  ORDER BY 1, 2;
END;
$$;


ALTER FUNCTION "public"."get_razao_conta"("p_codigo_conta" character varying, "p_data_inicio" "date", "p_data_fim" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_resumo_manutencao_mensal"("p_ano" integer DEFAULT (EXTRACT(year FROM CURRENT_DATE))::integer) RETURNS TABLE("mes" integer, "total_gasto" numeric, "qtd_titulos" integer)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    EXTRACT(MONTH FROM e.entry_date)::INTEGER as mes,
    SUM(ABS(COALESCE(l.debit, 0)))::NUMERIC(15,2) as total,
    COUNT(DISTINCT SUBSTRING(e.description FROM 'COB\d+'))::INTEGER as qtd
  FROM accounting_entries e
  JOIN accounting_entry_lines l ON l.entry_id = e.id
  JOIN chart_of_accounts c ON c.id = l.account_id
  WHERE e.description ILIKE '%MANUTENCAO DE TITULO%'
    AND c.code LIKE '4.%'
    AND EXTRACT(YEAR FROM e.entry_date) = p_ano
    AND l.debit > 0  -- S├│ d├®bitos (despesas)
  GROUP BY EXTRACT(MONTH FROM e.entry_date)
  ORDER BY 1;
END;
$$;


ALTER FUNCTION "public"."get_resumo_manutencao_mensal"("p_ano" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_id UUID;
  v_code TEXT;
BEGIN
  -- Mapear categoria para c├│digo de conta de ATIVO
  v_code := CASE
    WHEN p_category ILIKE '%sergio%' AND p_category NOT ILIKE '%augusto%' THEN '1.1.3.04.01'  -- Sergio Carneiro Le├úo
    WHEN p_category ILIKE '%sergio augusto%' THEN '1.1.3.04.05'  -- S├®rgio Augusto
    WHEN p_category ILIKE '%victor%' THEN '1.1.3.04.03'  -- Victor Hugo
    WHEN p_category ILIKE '%nayara%' THEN '1.1.3.04.04'  -- Nayara
    ELSE '1.1.3.04.02'  -- Outros S├│cios (fallback)
  END;

  SELECT id INTO v_account_id
  FROM chart_of_accounts
  WHERE code = v_code;

  -- Fallback para conta gen├®rica se n├úo encontrar
  IF v_account_id IS NULL THEN
    SELECT id INTO v_account_id
    FROM chart_of_accounts
    WHERE code = '1.1.3.04';
  END IF;

  RETURN v_account_id;
END;
$$;


ALTER FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") IS 'Retorna conta de adiantamento do s├│cio baseado na categoria';



CREATE OR REPLACE FUNCTION "public"."get_titulos_manutencao_cara"() RETURNS TABLE("cob" character varying, "total_manutencao" numeric, "qtd_cobrancas" integer, "primeira_cobranca" "date", "ultima_cobranca" "date", "status_sugerido" "text")
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH manutencoes AS (
    SELECT 
      SUBSTRING(e.description FROM 'COB\d+') as codigo_cob,
      ABS(COALESCE(l.debit, 0) + COALESCE(l.credit, 0)) as valor,
      e.entry_date
    FROM accounting_entries e
    JOIN accounting_entry_lines l ON l.entry_id = e.id
    JOIN chart_of_accounts c ON c.id = l.account_id
    WHERE e.description ILIKE '%MANUTENCAO DE TITULO%'
      AND c.code LIKE '4.%'  -- Conta de despesa
  ),
  agrupado AS (
    SELECT 
      codigo_cob,
      SUM(valor) as total,
      COUNT(*) as qtd,
      MIN(entry_date) as primeira,
      MAX(entry_date) as ultima
    FROM manutencoes
    WHERE codigo_cob IS NOT NULL
    GROUP BY codigo_cob
  )
  SELECT 
    codigo_cob::VARCHAR(20),
    total::NUMERIC(15,2),
    qtd::INTEGER,
    primeira,
    ultima,
    CASE 
      WHEN qtd >= 3 THEN '­ƒÜ¿ CANCELAR NO BANCO - j├í pagou ' || total::TEXT || ' de manuten├º├úo!'
      WHEN qtd = 2 THEN 'ÔÜá´©Å ATEN├ç├âO - 2 meses cobrando, avaliar cancelamento'
      ELSE 'Ô£ô Normal - primeiro m├¬s'
    END as status_sugerido
  FROM agrupado
  WHERE total > 3  -- Ignorar valores zerados ou estornos
  ORDER BY total DESC;
END;
$$;


ALTER FUNCTION "public"."get_titulos_manutencao_cara"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_upcoming_payments"("p_days_ahead" integer DEFAULT 7, "p_include_personal" boolean DEFAULT false) RETURNS TABLE("id" "uuid", "name" character varying, "description" "text", "supplier_name" character varying, "due_day" integer, "due_date" "date", "amount_estimate" numeric, "category" character varying, "is_personal" boolean, "days_until" integer, "status" character varying)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_today DATE := CURRENT_DATE;
  v_current_day INTEGER := EXTRACT(DAY FROM v_today);
  v_current_month INTEGER := EXTRACT(MONTH FROM v_today);
  v_current_year INTEGER := EXTRACT(YEAR FROM v_today);
  v_days_in_month INTEGER;
BEGIN
  v_days_in_month := EXTRACT(DAY FROM (DATE_TRUNC('month', v_today) + INTERVAL '1 month - 1 day'));
  
  RETURN QUERY
  SELECT 
    rp.id,
    rp.name,
    rp.description,
    rp.supplier_name,
    rp.due_day,
    CASE 
      WHEN rp.due_day >= v_current_day THEN 
        make_date(v_current_year, v_current_month, LEAST(rp.due_day, v_days_in_month))
      ELSE 
        make_date(
          CASE WHEN v_current_month = 12 THEN v_current_year + 1 ELSE v_current_year END,
          CASE WHEN v_current_month = 12 THEN 1 ELSE v_current_month + 1 END,
          rp.due_day
        )
    END AS due_date,
    rp.amount_estimate,
    rp.category,
    rp.is_personal,
    CASE 
      WHEN rp.due_day >= v_current_day THEN rp.due_day - v_current_day
      ELSE (v_days_in_month - v_current_day) + rp.due_day
    END AS days_until,
    CASE 
      WHEN rp.due_day = v_current_day THEN 'VENCE_HOJE'
      WHEN rp.due_day < v_current_day AND rp.due_day > v_current_day - 5 THEN 'VENCIDO'
      WHEN rp.due_day - v_current_day <= 3 THEN 'URGENTE'
      WHEN rp.due_day - v_current_day <= 7 THEN 'PROXIMO'
      ELSE 'NORMAL'
    END::VARCHAR(20) AS status
  FROM recurring_payments rp
  WHERE rp.is_active = TRUE
    AND (p_include_personal = TRUE OR rp.is_personal = FALSE)
    AND (
      (rp.due_day >= v_current_day AND rp.due_day <= v_current_day + p_days_ahead)
      OR (v_current_day + p_days_ahead > v_days_in_month AND rp.due_day <= (v_current_day + p_days_ahead - v_days_in_month))
      OR (rp.due_day < v_current_day AND rp.due_day >= v_current_day - 5)
    )
  ORDER BY 
    CASE 
      WHEN rp.due_day >= v_current_day THEN rp.due_day - v_current_day
      ELSE (v_days_in_month - v_current_day) + rp.due_day
    END;
END;
$$;


ALTER FUNCTION "public"."get_upcoming_payments"("p_days_ahead" integer, "p_include_personal" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_offices"() RETURNS TABLE("office_id" "uuid", "office_name" "text", "role" "text", "is_default" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ao.id as office_id,
    COALESCE(ao.nome_fantasia, ao.razao_social) as office_name,
    uoa.role,
    uoa.is_default
  FROM user_office_access uoa
  JOIN accounting_office ao ON ao.id = uoa.office_id
  WHERE uoa.user_id = auth.uid()
  AND ao.is_active = true
  ORDER BY uoa.is_default DESC, ao.nome_fantasia;
END;
$$;


ALTER FUNCTION "public"."get_user_offices"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."guard_bank_imports_continuity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    prev_closing NUMERIC;
    prev_end DATE;
BEGIN
    IF NEW.opening_balance IS NULL OR NEW.closing_balance IS NULL THEN
        RETURN NEW; -- s├│ valida se os saldos vierem informados
    END IF;

    SELECT bi.closing_balance, COALESCE(bi.period_end, bi.end_date)
    INTO prev_closing, prev_end
    FROM public.bank_imports bi
    WHERE bi.bank_account_id = NEW.bank_account_id
      AND COALESCE(bi.period_end, bi.end_date) < COALESCE(NEW.period_start, NEW.start_date)
    ORDER BY COALESCE(bi.period_end, bi.end_date) DESC
    LIMIT 1;

    IF prev_closing IS NOT NULL THEN
        IF prev_end IS NOT NULL AND prev_end + INTERVAL '1 day' > COALESCE(NEW.period_start, NEW.start_date) THEN
            -- permite overlaps/corre├º├Áes, mas n├úo impede
            NULL;
        END IF;
        IF NEW.opening_balance IS DISTINCT FROM prev_closing THEN
            RAISE EXCEPTION 'Opening balance % does not match previous closing % for account %', NEW.opening_balance, prev_closing, NEW.bank_account_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."guard_bank_imports_continuity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."guard_bank_imports_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    IF TG_OP = 'UPDATE' AND OLD.status = 'completed' THEN
        IF NEW.opening_balance IS DISTINCT FROM OLD.opening_balance OR NEW.closing_balance IS DISTINCT FROM OLD.closing_balance THEN
            RAISE EXCEPTION 'Cannot change opening/closing balance of a completed import';
        END IF;
        IF NEW.period_start IS DISTINCT FROM OLD.period_start OR NEW.period_end IS DISTINCT FROM OLD.period_end THEN
            RAISE EXCEPTION 'Cannot change period dates of a completed import';
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."guard_bank_imports_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    new_tenant_id UUID;
    company_name text;
    user_full_name text;
BEGIN
    -- 1. Define nomes (usa metadados ou fallback para email)
    company_name := COALESCE(NEW.raw_user_meta_data->>'company_name', 'Empresa de ' || NEW.email);
    user_full_name := COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email);

    -- 2. Cria a Empresa (Tenant)
    INSERT INTO public.tenants (name, slug, created_at, updated_at)
    VALUES (
        company_name, 
        lower(regexp_replace(company_name, '[^a-zA-Z0-9]+', '-', 'g')) || '-' || floor(random() * 1000)::text,
        now(),
        now()
    )
    RETURNING id INTO new_tenant_id;

    -- 3. Vincula na tabela tenant_users (Permiss├úo SaaS)
    INSERT INTO public.tenant_users (tenant_id, user_id, role)
    VALUES (new_tenant_id, NEW.id, 'admin');

    -- 4. Cria o Perfil P├║blico
    INSERT INTO public.profiles (id, email, tenant_id)
    VALUES (NEW.id, NEW.email, new_tenant_id)
    ON CONFLICT (id) DO NOTHING;

    -- 5. Preenche user_roles (Legado/Compatibilidade)
    INSERT INTO public.user_roles (user_id, role, tenant_id, created_by)
    VALUES (NEW.id, 'admin', new_tenant_id, NEW.id)
    ON CONFLICT DO NOTHING;

    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    RAISE LOG 'Erro no cadastro: %', SQLERRM;
    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_role"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN NEW; -- Fun├º├úo neutralizada
END;
$$;


ALTER FUNCTION "public"."handle_new_user_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_tenant"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_tenant_id UUID;
  v_tenant_name TEXT;
  v_tenant_slug TEXT;
  v_email_username TEXT;
BEGIN
  -- Extrair username do email
  v_email_username := SPLIT_PART(NEW.email, '@', 1);

  -- Gerar nome e slug do tenant
  v_tenant_name := 'Organiza├º├úo de ' || v_email_username;
  v_tenant_slug := LOWER(REGEXP_REPLACE(
    v_email_username || '-' || EXTRACT(EPOCH FROM NOW())::TEXT,
    '[^a-z0-9-]',
    '-',
    'g'
  ));

  -- Criar tenant
  INSERT INTO tenants (name, slug)
  VALUES (v_tenant_name, v_tenant_slug)
  RETURNING id INTO v_tenant_id;

  -- Adicionar usu├írio ao tenant como owner
  INSERT INTO tenant_users (user_id, tenant_id, role, is_active)
  VALUES (NEW.id, v_tenant_id, 'owner', true);

  RAISE NOTICE 'Tenant % criado para usu├írio %', v_tenant_id, NEW.email;

  RETURN NEW;

EXCEPTION
  WHEN OTHERS THEN
    -- Em caso de erro, apenas logar e permitir que usu├írio seja criado
    RAISE WARNING 'Erro ao criar tenant para %: %. Usu├írio criado sem tenant.', NEW.email, SQLERRM;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_tenant"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."handle_new_user_tenant"() IS 'Cria automaticamente um tenant (organiza├º├úo) para cada novo usu├írio que se registra. O usu├írio ├® adicionado como owner do tenant.';



CREATE OR REPLACE FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id AND role = _role
  )
$$;


ALTER FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."identify_partner_prospects"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_count INTEGER := 0;
    v_client RECORD;
    v_partner RECORD;
BEGIN
    -- Para cada cliente ativo
    FOR v_client IN
        SELECT c.id, c.name, c.cnpj
        FROM clients c
        WHERE c.status = 'Ativo'
    LOOP
        -- Aqui deveria consultar API CNPJA para obter s├│cios
        -- Por enquanto, ├® um placeholder
        -- A l├│gica real seria:
        -- 1. Buscar s├│cios do cliente via API
        -- 2. Para cada CPF, buscar outras empresas
        -- 3. Verificar se j├í ├® cliente
        -- 4. Se n├úo for, inserir como prospect
        NULL;
    END LOOP;

    RETURN v_count;
END;
$$;


ALTER FUNCTION "public"."identify_partner_prospects"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  partner_record JSONB;
  inserted_count INTEGER := 0;
BEGIN
  -- Delete existing partners for this client
  DELETE FROM client_partners WHERE client_id = p_client_id;

  -- Insert new partners from JSON
  FOR partner_record IN SELECT * FROM jsonb_array_elements(p_partners_json)
  LOOP
    INSERT INTO client_partners (
      client_id,
      name,
      cpf,
      percentage,
      partner_type,
      is_administrator
    ) VALUES (
      p_client_id,
      partner_record->>'nome',
      partner_record->>'cpf',
      (partner_record->>'percentual_participacao')::DECIMAL,
      CASE
        WHEN (partner_record->>'tipo')::TEXT = 'PESSOA_FISICA' THEN 'individual'
        WHEN (partner_record->>'tipo')::TEXT = 'PESSOA_JURIDICA' THEN 'company'
        ELSE 'individual'
      END,
      COALESCE((partner_record->>'administrador')::BOOLEAN, false)
    );

    inserted_count := inserted_count + 1;
  END LOOP;

  RETURN inserted_count;
END;
$$;


ALTER FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") IS 'Importa s├│cios de um cliente a partir de dados da API Brasil';



CREATE OR REPLACE FUNCTION "public"."increment_rule_usage"("rule_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE classification_rules
  SET usage_count = COALESCE(usage_count, 0) + 1,
      last_used_at = NOW()
  WHERE id = rule_id;
END;
$$;


ALTER FUNCTION "public"."increment_rule_usage"("rule_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date" DEFAULT NULL::"date") RETURNS TABLE("success" boolean, "monthly_fee" numeric, "minimum_wage_used" numeric, "fee_in_minimum_wages" numeric, "message" "text")
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_client RECORD;
  v_min_wage NUMERIC;
  v_fee_in_mw NUMERIC;
  v_ref_date DATE;
BEGIN
  SELECT * INTO v_client FROM clients WHERE id = p_client_id;

  IF v_client IS NULL THEN
    RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Cliente n├úo encontrado'::TEXT;
    RETURN;
  END IF;

  IF v_client.monthly_fee IS NULL OR v_client.monthly_fee = 0 THEN
    RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Cliente n├úo tem honor├írio definido'::TEXT;
    RETURN;
  END IF;

  -- Usar data de refer├¬ncia ou a data de cria├º├úo do cliente
  v_ref_date := COALESCE(p_reference_date, v_client.created_at::DATE);

  -- Obter SM da ├®poca
  v_min_wage := get_minimum_wage_at_date(v_ref_date);

  IF v_min_wage IS NULL THEN
    -- Se n├úo tiver SM hist├│rico, usar o mais antigo dispon├¡vel
    SELECT value INTO v_min_wage FROM minimum_wage_history ORDER BY effective_date ASC LIMIT 1;
  END IF;

  -- Calcular quantos SM representa o honor├írio
  v_fee_in_mw := ROUND(v_client.monthly_fee / v_min_wage, 4);

  -- Atualizar cliente
  UPDATE clients SET
    fee_in_minimum_wages = v_fee_in_mw,
    last_adjustment_minimum_wage = v_min_wage,
    last_fee_adjustment_date = v_ref_date,
    updated_at = NOW()
  WHERE id = p_client_id;

  RETURN QUERY SELECT true, v_client.monthly_fee, v_min_wage, v_fee_in_mw,
    format('Honor├írio de R$ %s = %s sal├írios m├¡nimos (SM de R$ %s em %s)',
      v_client.monthly_fee, v_fee_in_mw, v_min_wage, v_ref_date)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date") IS 'Inicializa o campo fee_in_minimum_wages de um cliente';



CREATE OR REPLACE FUNCTION "public"."is_adiantamento_socio"("p_category" "text") RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN p_category ILIKE '%adiantamento%';
END;
$$;


ALTER FUNCTION "public"."is_adiantamento_socio"("p_category" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_adiantamento_socio"("p_category" "text") IS 'Verifica se categoria ├® adiantamento a s├│cio';



CREATE OR REPLACE FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text" DEFAULT NULL::"text", "p_municipality_code" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_day_of_week INTEGER;
  v_is_holiday BOOLEAN;
BEGIN
  -- Verificar se ├® fim de semana (0 = domingo, 6 = s├íbado)
  v_day_of_week := EXTRACT(DOW FROM p_date);
  IF v_day_of_week IN (0, 6) THEN
    RETURN false;
  END IF;

  -- Verificar se ├® feriado
  SELECT EXISTS (
    SELECT 1 FROM holidays
    WHERE (
      -- Feriado na data exata
      date = p_date
      OR
      -- Feriado recorrente
      (is_recurring = true AND recurring_month = EXTRACT(MONTH FROM p_date) AND recurring_day = EXTRACT(DAY FROM p_date))
    )
    AND (
      -- Feriado nacional
      type = 'national'
      OR
      -- Feriado estadual do estado do cliente
      (type = 'state' AND state_code = p_state_code)
      OR
      -- Feriado municipal da cidade do cliente
      (type = 'municipal' AND municipality_code = p_municipality_code)
    )
  ) INTO v_is_holiday;

  RETURN NOT v_is_holiday;
END;
$$;


ALTER FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text", "p_municipality_code" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text", "p_municipality_code" "text") IS 'Verifica se uma data ├® dia ├║til considerando feriados nacionais, estaduais e municipais';



CREATE OR REPLACE FUNCTION "public"."is_in_economic_group"("p_client_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM economic_group_members 
    WHERE client_id = p_client_id
  );
END;
$$;


ALTER FUNCTION "public"."is_in_economic_group"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_status TEXT;
BEGIN
  SELECT status INTO v_status
  FROM monthly_closings
  WHERE year = p_year AND month = p_month;

  RETURN COALESCE(v_status = 'closed', false);
END;
$$;


ALTER FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) IS 'Verifica se um per├¡odo (ano/m├¬s) est├í fechado';



CREATE OR REPLACE FUNCTION "public"."is_period_open"("p_year" integer, "p_month" integer) RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_status TEXT;
BEGIN
  SELECT status INTO v_status
  FROM accounting_periods
  WHERE year = p_year AND month = p_month;

  -- Se n├úo existe, est├í aberto por padr├úo
  IF v_status IS NULL THEN
    RETURN TRUE;
  END IF;

  RETURN v_status = 'open';
END;
$$;


ALTER FUNCTION "public"."is_period_open"("p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_transaction_reconciled_on_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Se o lan├ºamento tem transaction_id, marcar como reconciliada
  IF NEW.transaction_id IS NOT NULL THEN
    UPDATE bank_transactions
    SET
      is_reconciled = true,
      matched = true
    WHERE id = NEW.transaction_id;
  END IF;

  -- Se o lan├ºamento tem reference_type = 'bank_transaction', marcar tamb├®m
  IF NEW.reference_type = 'bank_transaction' AND NEW.reference_id IS NOT NULL THEN
    UPDATE bank_transactions
    SET
      is_reconciled = true,
      matched = true
    WHERE id = NEW.reference_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."mark_transaction_reconciled_on_entry"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."mark_transaction_reconciled_on_entry"() IS 'Marca automaticamente a transa├º├úo banc├íria como reconciliada quando um lan├ºamento cont├íbil ├® criado.';



CREATE OR REPLACE FUNCTION "public"."normalize_for_matching"("input_text" "text") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN UPPER(
    TRIM(
      REGEXP_REPLACE(
        REGEXP_REPLACE(input_text, '[^A-Za-z0-9\s]', '', 'g'),
        '\s+', ' ', 'g'
      )
    )
  );
END;
$$;


ALTER FUNCTION "public"."normalize_for_matching"("input_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid" DEFAULT NULL::"uuid", "p_paid_by" "uuid" DEFAULT NULL::"uuid") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_termination RECORD;
BEGIN
    -- Buscar rescis├úo
    SELECT * INTO v_termination FROM employee_terminations WHERE id = p_termination_id;

    IF v_termination IS NULL THEN
        RAISE EXCEPTION 'Rescis├úo n├úo encontrada';
    END IF;

    IF v_termination.status NOT IN ('aprovada', 'homologada') THEN
        RAISE EXCEPTION 'Rescis├úo precisa estar aprovada ou homologada';
    END IF;

    -- Atualizar rescis├úo
    UPDATE employee_terminations SET
        status = 'paga',
        paid_at = now(),
        paid_by = p_paid_by,
        updated_at = now()
    WHERE id = p_termination_id;

    RETURN true;
END;
$$;


ALTER FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid", "p_paid_by" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid", "p_paid_by" "uuid") IS 'Registra pagamento da rescis├úo';



CREATE OR REPLACE FUNCTION "public"."prepare_content_generation"("p_template_code" "text", "p_variables" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_template RECORD;
    v_prompt TEXT;
    v_var TEXT;
    v_value TEXT;
BEGIN
    -- Buscar template
    SELECT * INTO v_template
    FROM content_templates
    WHERE template_code = p_template_code AND is_active;

    IF v_template IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Template n├úo encontrado');
    END IF;

    -- Substituir vari├íveis no prompt
    v_prompt := v_template.user_prompt_template;

    FOR v_var IN SELECT unnest(v_template.variables)
    LOOP
        v_value := p_variables->>v_var;
        IF v_value IS NOT NULL THEN
            v_prompt := REPLACE(v_prompt, '{{' || v_var || '}}', v_value);
        END IF;
    END LOOP;

    RETURN jsonb_build_object(
        'success', true,
        'template_id', v_template.id,
        'provider', v_template.preferred_provider,
        'system_prompt', v_template.system_prompt,
        'user_prompt', v_prompt,
        'max_tokens', v_template.max_tokens,
        'content_type', v_template.content_type,
        'target_platform', v_template.target_platform
    );
END;
$$;


ALTER FUNCTION "public"."prepare_content_generation"("p_template_code" "text", "p_variables" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_invoices_without_accounting"() RETURNS TABLE("processed" integer, "skipped" integer, "errors" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_invoice RECORD;
  v_entry_id UUID;
  v_client_account_id UUID;
  v_revenue_account_id UUID;
  v_competence_date DATE;
  v_processed INT := 0;
  v_skipped INT := 0;
  v_errors INT := 0;
BEGIN
  -- Get revenue account
  SELECT id INTO v_revenue_account_id FROM chart_of_accounts WHERE code = '3.1.1.01';

  IF v_revenue_account_id IS NULL THEN
    RAISE EXCEPTION 'Revenue account 3.1.1.01 not found';
  END IF;

  FOR v_invoice IN
    SELECT i.*, c.name as client_name
    FROM invoices i
    JOIN clients c ON i.client_id = c.id
    LEFT JOIN accounting_entries ae ON ae.reference_id = i.id AND ae.reference_type = 'invoice'
    WHERE ae.id IS NULL
    LIMIT 500
  LOOP
    BEGIN
      -- Get client account
      SELECT id INTO v_client_account_id FROM chart_of_accounts
      WHERE code LIKE '1.1.2.01.%' AND name ILIKE '%' || v_invoice.client_name || '%' LIMIT 1;

      IF v_client_account_id IS NULL THEN
        v_skipped := v_skipped + 1;
        CONTINUE;
      END IF;

      -- Parse competence date
      IF v_invoice.competence ~ '^\d{2}/\d{4}$' THEN
        v_competence_date := (SPLIT_PART(v_invoice.competence, '/', 2) || '-' || SPLIT_PART(v_invoice.competence, '/', 1) || '-01')::DATE;
      ELSE
        v_competence_date := COALESCE(v_invoice.due_date, CURRENT_DATE);
      END IF;

      -- Create entry
      INSERT INTO accounting_entries (entry_date, competence_date, entry_type, description, reference_type, reference_id, total_debit, total_credit, balanced, created_by)
      VALUES (COALESCE(v_invoice.due_date, CURRENT_DATE), v_competence_date, 'receita_honorarios',
              'Honor├írios: ' || v_invoice.client_name || ' - ' || v_invoice.competence,
              'invoice', v_invoice.id, v_invoice.amount, v_invoice.amount, true, v_invoice.created_by)
      RETURNING id INTO v_entry_id;

      -- Create lines
      INSERT INTO accounting_entry_lines (entry_id, account_id, description, debit, credit)
      VALUES
        (v_entry_id, v_client_account_id, 'D - ' || v_invoice.client_name, v_invoice.amount, 0),
        (v_entry_id, v_revenue_account_id, 'C - Receita Honor├írios', 0, v_invoice.amount);

      v_processed := v_processed + 1;
    EXCEPTION WHEN OTHERS THEN
      v_errors := v_errors + 1;
      RAISE WARNING 'Error processing invoice %: %', v_invoice.id, SQLERRM;
    END;
  END LOOP;

  RETURN QUERY SELECT v_processed, v_skipped, v_errors;
END;
$_$;


ALTER FUNCTION "public"."process_invoices_without_accounting"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_invoices_without_accounting"() IS 'Batch process existing invoices without accounting entries (max 500 per call)';



CREATE OR REPLACE FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
    v_solutions JSONB := '[]'::jsonb;
    v_template RECORD;
    v_priority INTEGER := 1;
BEGIN
    -- Buscar templates de solu├º├úo ordenados por impacto esperado
    FOR v_template IN
        SELECT * FROM solution_templates
        WHERE gap_type = p_gap_type AND is_active
        ORDER BY expected_impact_percent DESC
    LOOP
        v_solutions := v_solutions || jsonb_build_array(
            jsonb_build_object(
                'priority', v_priority,
                'code', v_template.solution_code,
                'name', v_template.solution_name,
                'description', v_template.description,
                'expected_recovery', ROUND(p_gap_amount * v_template.expected_impact_percent / 100, 2),
                'expected_percent', v_template.expected_impact_percent,
                'time_to_implement', v_template.time_to_implement,
                'complexity', v_template.complexity,
                'steps', v_template.implementation_steps,
                'scripts', v_template.scripts,
                'agent_recommendation', CASE
                    WHEN v_template.expected_impact_percent >= 20 THEN
                        'Sr. Vendedor RECOMENDA: Esta estrat├®gia tem alto potencial de retorno!'
                    WHEN v_template.expected_impact_percent >= 10 THEN
                        'Sr. Vendedor sugere: Boa op├º├úo complementar.'
                    ELSE
                        'Sr. Vendedor informa: Considerar como ├║ltima alternativa.'
                END
            )
        );
        v_priority := v_priority + 1;
    END LOOP;

    RETURN jsonb_build_object(
        'gap_type', p_gap_type,
        'gap_amount', p_gap_amount,
        'total_solutions', v_priority - 1,
        'total_potential_recovery', (
            SELECT ROUND(SUM((sol->>'expected_recovery')::decimal), 2)
            FROM jsonb_array_elements(v_solutions) sol
        ),
        'solutions', v_solutions,
        'agent_message', 'Sr. Vendedor analisou o rombo de R$ ' || p_gap_amount ||
            ' e identificou ' || (v_priority - 1) || ' estrat├®gias para recupera├º├úo. ' ||
            'Recomendo come├ºar pela primeira op├º├úo que tem maior potencial de retorno.'
    );
END;
$_$;


ALTER FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) IS 'Fun├º├úo que analisa o gap e prop├Áe solu├º├Áes priorizadas';



CREATE OR REPLACE FUNCTION "public"."protect_accounting_entry_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_year INTEGER;
    v_month INTEGER;
    v_check_date DATE;
BEGIN
    -- Determine the date to check
    IF TG_OP = 'DELETE' THEN
        v_check_date := OLD.entry_date;
    ELSE
        v_check_date := NEW.entry_date;
    END IF;

    v_year := EXTRACT(YEAR FROM v_check_date);
    v_month := EXTRACT(MONTH FROM v_check_date);

    -- Check if period is closed
    IF is_period_closed(v_year, v_month) THEN
        RAISE EXCEPTION 'Nao e possivel modificar lancamentos contabeis no periodo fechado (%/%)', v_month, v_year;
    END IF;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."protect_accounting_entry_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."protect_accounting_entry_line_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_year INTEGER;
    v_month INTEGER;
    v_entry_date DATE;
BEGIN
    -- Get the entry date from parent entry
    IF TG_OP = 'DELETE' THEN
        SELECT entry_date INTO v_entry_date
        FROM accounting_entries WHERE id = OLD.entry_id;
    ELSE
        SELECT entry_date INTO v_entry_date
        FROM accounting_entries WHERE id = NEW.entry_id;
    END IF;

    IF v_entry_date IS NULL THEN
        -- Entry not found, allow operation (will fail on FK anyway)
        IF TG_OP = 'DELETE' THEN
            RETURN OLD;
        END IF;
        RETURN NEW;
    END IF;

    v_year := EXTRACT(YEAR FROM v_entry_date);
    v_month := EXTRACT(MONTH FROM v_entry_date);

    -- Check if period is closed
    IF is_period_closed(v_year, v_month) THEN
        RAISE EXCEPTION 'Nao e possivel modificar linhas de lancamentos contabeis no periodo fechado (%/%)', v_month, v_year;
    END IF;

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."protect_accounting_entry_line_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."protect_bank_transaction_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_year INTEGER;
  v_month INTEGER;
  v_check_date DATE;
BEGIN
  -- Determinar a data relevante
  IF TG_OP = 'DELETE' THEN
    v_check_date := OLD.transaction_date;
  ELSE
    v_check_date := NEW.transaction_date;
  END IF;

  v_year := EXTRACT(YEAR FROM v_check_date);
  v_month := EXTRACT(MONTH FROM v_check_date);

  -- Verificar se o per├¡odo est├í fechado
  IF is_period_closed(v_year, v_month) THEN
    RAISE EXCEPTION 'N├úo ├® poss├¡vel modificar transa├º├Áes banc├írias no per├¡odo fechado (%/%)', v_month, v_year;
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."protect_bank_transaction_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."protect_expense_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_year INTEGER;
  v_month INTEGER;
  v_check_date DATE;
BEGIN
  -- Determinar a data relevante
  IF TG_OP = 'DELETE' THEN
    v_check_date := OLD.due_date;
  ELSE
    v_check_date := COALESCE(NEW.due_date, NEW.created_at::DATE);
  END IF;

  v_year := EXTRACT(YEAR FROM v_check_date);
  v_month := EXTRACT(MONTH FROM v_check_date);

  -- Verificar se o per├¡odo est├í fechado
  IF is_period_closed(v_year, v_month) THEN
    RAISE EXCEPTION 'N├úo ├® poss├¡vel modificar despesas no per├¡odo fechado (%/%)', v_month, v_year;
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."protect_expense_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."protect_invoice_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_year INTEGER;
  v_month INTEGER;
  v_check_date DATE;
BEGIN
  -- Determinar a data relevante
  IF TG_OP = 'DELETE' THEN
    v_check_date := OLD.due_date;
  ELSE
    v_check_date := COALESCE(NEW.due_date, NEW.created_at::DATE);
  END IF;

  v_year := EXTRACT(YEAR FROM v_check_date);
  v_month := EXTRACT(MONTH FROM v_check_date);

  -- Verificar se o per├¡odo est├í fechado
  IF is_period_closed(v_year, v_month) THEN
    RAISE EXCEPTION 'N├úo ├® poss├¡vel modificar faturas no per├¡odo fechado (%/%)', v_month, v_year;
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."protect_invoice_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."proximo_numero_rps"("p_prestador_cnpj" character varying) RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_numero INTEGER;
BEGIN
    UPDATE nfse_config
    SET ultimo_numero_rps = ultimo_numero_rps + 1
    WHERE prestador_cnpj = p_prestador_cnpj
    RETURNING ultimo_numero_rps INTO v_numero;

    IF v_numero IS NULL THEN
        -- Se n├úo encontrou config, buscar m├íximo da tabela nfse
        SELECT COALESCE(MAX(numero_rps::INTEGER), 0) + 1 INTO v_numero
        FROM nfse
        WHERE prestador_cnpj = p_prestador_cnpj;
    END IF;

    RETURN v_numero;
END;
$$;


ALTER FUNCTION "public"."proximo_numero_rps"("p_prestador_cnpj" character varying) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."qry_client_dashboard"("p_client_id" "uuid") RETURNS TABLE("client_name" "text", "total_debits" numeric, "total_credits" numeric, "balance" numeric, "overdue_count" bigint, "overdue_amount" numeric, "pending_count" bigint, "pending_amount" numeric, "paid_count" bigint, "paid_amount" numeric, "last_entry_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    cb.client_name,
    cb.total_debits,
    cb.total_credits,
    cb.balance,
    COALESCE(ds.overdue_count, 0),
    COALESCE(ds.overdue_amount, 0),
    COALESCE(ds.pending_count, 0),
    COALESCE(ds.pending_amount, 0),
    COALESCE(ds.paid_count, 0),
    COALESCE(ds.paid_amount, 0),
    cb.last_entry_at
  FROM public.mv_client_balances cb -- Agora l├¬ da View normal
  JOIN public.clients c ON c.id = cb.client_id
  LEFT JOIN public.mv_default_summary ds ON ds.client_id = cb.client_id -- Agora l├¬ da View normal
  WHERE cb.client_id = p_client_id
  AND c.tenant_id = public.get_my_tenant_id(); -- Garante seguran├ºa
END;
$$;


ALTER FUNCTION "public"."qry_client_dashboard"("p_client_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."qry_executive_summary"("p_start_date" "date", "p_end_date" "date") RETURNS TABLE("total_revenue" numeric, "total_expenses" numeric, "net_profit" numeric, "total_receivables" numeric, "total_payables" numeric, "cash_position" numeric, "client_count" bigint, "default_rate" numeric)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  WITH revenue AS (
    SELECT COALESCE(SUM(amount), 0) AS total
    FROM invoices
    WHERE status = 'paid'
      AND payment_date BETWEEN p_start_date AND p_end_date
  ),
  expenses AS (
    SELECT COALESCE(SUM(amount), 0) AS total
    FROM expenses
    WHERE status = 'paid'
      AND payment_date BETWEEN p_start_date AND p_end_date
  ),
  receivables AS (
    SELECT COALESCE(SUM(amount), 0) AS total
    FROM invoices
    WHERE status = 'pending'
  ),
  payables AS (
    SELECT COALESCE(SUM(amount), 0) AS total
    FROM expenses
    WHERE status = 'pending'
  ),
  cash AS (
    SELECT COALESCE(SUM(net_flow), 0) AS total
    FROM mv_cash_flow
    WHERE date IS NOT NULL AND date BETWEEN p_start_date AND p_end_date
  ),
  clients AS (
    SELECT COUNT(*) AS total FROM clients WHERE is_active = true
  ),
  defaults AS (
    SELECT
      COUNT(CASE WHEN overdue_count > 0 THEN 1 END)::NUMERIC /
      NULLIF(COUNT(*), 0) * 100 AS rate
    FROM mv_default_summary
  )
  SELECT
    r.total,
    e.total,
    r.total - e.total,
    rec.total,
    pay.total,
    c.total,
    cl.total,
    COALESCE(d.rate, 0)
  FROM revenue r, expenses e, receivables rec, payables pay,
       cash c, clients cl, defaults d;
END;
$$;


ALTER FUNCTION "public"."qry_executive_summary"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer DEFAULT 5) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_queue_id UUID;
BEGIN
  -- Inserir ou atualizar na fila
  INSERT INTO ai_validation_queue (entry_id, priority)
  VALUES (p_entry_id, p_priority)
  ON CONFLICT (entry_id) DO UPDATE SET
    status = 'pending',
    priority = EXCLUDED.priority,
    attempts = 0,
    last_error = NULL
  RETURNING id INTO v_queue_id;

  RETURN v_queue_id;
END;
$$;


ALTER FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer) IS 'Adiciona um lan├ºamento na fila de valida├º├úo IA';



CREATE OR REPLACE FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_initial_balance DECIMAL;
    v_credits DECIMAL;
    v_debits DECIMAL;
    v_calculated_balance DECIMAL;
BEGIN
    -- Buscar saldo inicial
    SELECT COALESCE(initial_balance, 0) INTO v_initial_balance
    FROM bank_accounts WHERE id = p_bank_account_id;

    -- Somar cr├®ditos (valores positivos)
    SELECT COALESCE(SUM(ABS(amount)), 0) INTO v_credits
    FROM bank_transactions
    WHERE bank_account_id = p_bank_account_id
      AND transaction_type = 'credit';

    -- Somar d├®bitos (valores positivos)
    SELECT COALESCE(SUM(ABS(amount)), 0) INTO v_debits
    FROM bank_transactions
    WHERE bank_account_id = p_bank_account_id
      AND transaction_type = 'debit';

    -- Calcular saldo: inicial + cr├®ditos - d├®bitos
    v_calculated_balance := v_initial_balance + v_credits - v_debits;

    RETURN v_calculated_balance;
END;
$$;


ALTER FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") IS 'Recalcula o saldo banc├írio baseado no saldo inicial + transa├º├Áes';



CREATE OR REPLACE FUNCTION "public"."refresh_account_ledger"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY account_ledger;
END;
$$;


ALTER FUNCTION "public"."refresh_account_ledger"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_all_materialized_views"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_client_balances;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_default_summary;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_dre_monthly;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_cash_flow;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_trial_balance;
END;
$$;


ALTER FUNCTION "public"."refresh_all_materialized_views"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."refresh_all_materialized_views"() IS 'Deve ser executada periodicamente (sugest├úo: a cada 5 minutos) para manter views atualizadas';



CREATE OR REPLACE FUNCTION "public"."refresh_coa_balances"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_coa_balances;
END;
$$;


ALTER FUNCTION "public"."refresh_coa_balances"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."refresh_dashboard_kpis"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_dashboard_kpis;
END;
$$;


ALTER FUNCTION "public"."refresh_dashboard_kpis"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."refresh_dashboard_kpis"() IS 'Atualiza cache de KPIs do dashboard para melhor performance';



CREATE OR REPLACE FUNCTION "public"."refresh_materialized_view"("view_name" "text", "trigger_source" "text" DEFAULT 'manual'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  start_time TIMESTAMPTZ;
  end_time TIMESTAMPTZ;
  duration INTEGER;
BEGIN
  start_time := clock_timestamp();

  EXECUTE format('REFRESH MATERIALIZED VIEW CONCURRENTLY %I', view_name);

  end_time := clock_timestamp();
  duration := EXTRACT(MILLISECONDS FROM (end_time - start_time))::INTEGER;

  INSERT INTO materialized_view_refresh_log (view_name, duration_ms, triggered_by)
  VALUES (view_name, duration, trigger_source);
END;
$$;


ALTER FUNCTION "public"."refresh_materialized_view"("view_name" "text", "trigger_source" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."register_consumption"("p_product_id" "uuid", "p_quantity" numeric, "p_consumed_by" "text" DEFAULT 'Lilian'::"text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_product RECORD;
    v_new_stock DECIMAL;
BEGIN
    -- Buscar produto
    SELECT * INTO v_product FROM office_products WHERE id = p_product_id;

    IF v_product IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Produto n├úo encontrado');
    END IF;

    IF v_product.current_stock < p_quantity THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Estoque insuficiente. Dispon├¡vel: ' || v_product.current_stock
        );
    END IF;

    v_new_stock := v_product.current_stock - p_quantity;

    -- Registrar movimento de sa├¡da
    INSERT INTO inventory_movements (
        product_id, movement_type, quantity, unit_cost, total_cost,
        reference_type, previous_stock, new_stock, notes, created_by
    ) VALUES (
        p_product_id,
        'saida',
        p_quantity,
        v_product.last_purchase_price,
        v_product.last_purchase_price * p_quantity,
        'consumption',
        v_product.current_stock,
        v_new_stock,
        COALESCE(p_notes, 'Consumo regular'),
        p_consumed_by
    );

    -- Atualizar estoque
    UPDATE office_products SET
        current_stock = v_new_stock,
        updated_at = now()
    WHERE id = p_product_id;

    -- Registrar na tabela de consumo
    INSERT INTO product_consumption (product_id, quantity, consumed_by, notes)
    VALUES (p_product_id, p_quantity, p_consumed_by, p_notes);

    RETURN jsonb_build_object(
        'success', true,
        'product', v_product.name,
        'consumed', p_quantity,
        'remaining', v_new_stock,
        'alert', CASE
            WHEN v_new_stock <= v_product.minimum_stock THEN 'ATEN├ç├âO: Estoque abaixo do m├¡nimo!'
            WHEN v_new_stock <= v_product.minimum_stock * 1.5 THEN 'Estoque baixo, considere repor em breve.'
            ELSE NULL
        END
    );
END;
$$;


ALTER FUNCTION "public"."register_consumption"("p_product_id" "uuid", "p_quantity" numeric, "p_consumed_by" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric DEFAULT 0, "p_interest_amount" numeric DEFAULT 0, "p_discount_amount" numeric DEFAULT 0, "p_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "message" "text", "invoice_amount" numeric, "fine" numeric, "interest" numeric, "discount" numeric, "total" numeric)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_invoice RECORD;
  v_expected_total NUMERIC;
BEGIN
  -- Obter invoice
  SELECT * INTO v_invoice FROM invoices WHERE id = p_invoice_id;

  IF v_invoice IS NULL THEN
    RETURN QUERY SELECT false, 'Fatura n├úo encontrada'::TEXT,
      0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC;
    RETURN;
  END IF;

  IF v_invoice.status = 'paid' THEN
    RETURN QUERY SELECT false, 'Fatura j├í est├í paga'::TEXT,
      v_invoice.amount, v_invoice.fine_amount, v_invoice.interest_amount,
      v_invoice.discount_amount, v_invoice.total_received;
    RETURN;
  END IF;

  -- Calcular total esperado
  v_expected_total := v_invoice.amount + p_fine_amount + p_interest_amount - p_discount_amount;

  -- Se total_received n├úo foi informado, usar o calculado
  IF p_total_received IS NULL OR p_total_received = 0 THEN
    p_total_received := v_expected_total;
  END IF;

  -- Atualizar invoice
  UPDATE invoices SET
    status = 'paid',
    payment_date = p_payment_date,
    fine_amount = p_fine_amount,
    interest_amount = p_interest_amount,
    discount_amount = p_discount_amount,
    total_received = p_total_received,
    description = COALESCE(description, '') ||
      CASE WHEN p_notes IS NOT NULL THEN ' | ' || p_notes ELSE '' END,
    updated_at = NOW()
  WHERE id = p_invoice_id;

  RETURN QUERY SELECT true,
    format('Pagamento registrado: R$ %s (honor├írio) + R$ %s (multa) + R$ %s (juros) - R$ %s (desconto) = R$ %s',
      v_invoice.amount, p_fine_amount, p_interest_amount, p_discount_amount, p_total_received)::TEXT,
    v_invoice.amount, p_fine_amount, p_interest_amount, p_discount_amount, p_total_received;
END;
$_$;


ALTER FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric, "p_interest_amount" numeric, "p_discount_amount" numeric, "p_notes" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric, "p_interest_amount" numeric, "p_discount_amount" numeric, "p_notes" "text") IS 'Registra pagamento de fatura com multa, juros e desconto';



CREATE OR REPLACE FUNCTION "public"."register_purchase_and_stock"("p_list_id" "uuid", "p_invoice_number" "text", "p_total_actual" numeric, "p_purchase_date" "date" DEFAULT CURRENT_DATE) RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_item RECORD;
    v_product RECORD;
    v_movement_id UUID;
    v_entry_count INTEGER := 0;
BEGIN
    -- Atualizar lista de compras
    UPDATE purchase_lists SET
        status = 'completed',
        approval_status = 'purchased',
        invoice_number = p_invoice_number,
        total_actual = p_total_actual,
        purchase_date = p_purchase_date
    WHERE id = p_list_id;

    -- Dar entrada em cada item
    FOR v_item IN
        SELECT pli.*, op.name as product_name, op.current_stock
        FROM purchase_list_items pli
        JOIN office_products op ON op.id = pli.product_id
        WHERE pli.list_id = p_list_id
    LOOP
        -- Criar movimento de entrada
        INSERT INTO inventory_movements (
            product_id, movement_type, quantity, unit_cost, total_cost,
            reference_type, reference_id, previous_stock, new_stock,
            notes, created_by
        ) VALUES (
            v_item.product_id,
            'entrada',
            v_item.quantity,
            v_item.actual_price,
            v_item.actual_price * v_item.quantity,
            'purchase',
            p_list_id,
            v_item.current_stock,
            v_item.current_stock + v_item.quantity,
            'Compra NF ' || p_invoice_number,
            'helena' -- Dra. Helena registra entrada
        )
        RETURNING id INTO v_movement_id;

        -- Atualizar estoque do produto
        UPDATE office_products SET
            current_stock = current_stock + v_item.quantity,
            last_purchase_price = v_item.actual_price,
            last_purchase_date = p_purchase_date,
            updated_at = now()
        WHERE id = v_item.product_id;

        v_entry_count := v_entry_count + 1;
    END LOOP;

    -- TODO: Gerar lan├ºamento cont├íbil
    -- D - 1.1.5.01 Estoque de Materiais
    -- C - 2.1.1.01 Fornecedores ou 1.1.1.XX Banco

    RETURN jsonb_build_object(
        'success', true,
        'items_stocked', v_entry_count,
        'invoice', p_invoice_number,
        'total', p_total_actual,
        'message', 'Dra. Helena: Compra registrada e ' || v_entry_count || ' itens entraram no estoque.'
    );
END;
$$;


ALTER FUNCTION "public"."register_purchase_and_stock"("p_list_id" "uuid", "p_invoice_number" "text", "p_total_actual" numeric, "p_purchase_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_next_year INTEGER;
  v_next_month INTEGER;
BEGIN
  -- Verificar se est├í fechado
  IF NOT is_period_closed(p_year, p_month) THEN
    RAISE EXCEPTION 'O per├¡odo %/% n├úo est├í fechado', p_month, p_year;
  END IF;

  -- Obter pr├│ximo per├¡odo
  SELECT * INTO v_next_year, v_next_month FROM get_next_period(p_year, p_month);

  -- Verificar se o pr├│ximo m├¬s n├úo est├í fechado
  IF is_period_closed(v_next_year, v_next_month) THEN
    RAISE EXCEPTION 'N├úo ├® poss├¡vel reabrir %/% porque o per├¡odo seguinte (%/%) j├í est├í fechado',
      p_month, p_year, v_next_month, v_next_year;
  END IF;

  -- Reabrir o per├¡odo
  UPDATE monthly_closings
  SET
    status = 'reopened',
    reopened_at = now(),
    reopened_by = p_user_id,
    reopened_reason = p_reason,
    updated_at = now()
  WHERE year = p_year AND month = p_month;

  RETURN true;
END;
$$;


ALTER FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") IS 'Reabre um m├¬s fechado (somente se o pr├│ximo m├¬s n├úo estiver fechado)';



CREATE OR REPLACE FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text" DEFAULT NULL::"text", "p_benefit" "text" DEFAULT NULL::"text", "p_example" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_feature_id UUID;
    v_analysis JSONB;
BEGIN
    -- Criar solicita├º├úo
    INSERT INTO feature_requests (
        requested_by,
        department,
        title,
        description,
        problem_description,
        expected_benefit,
        example_scenario
    ) VALUES (
        p_requested_by,
        p_department,
        p_title,
        p_description,
        p_problem,
        p_benefit,
        p_example
    )
    RETURNING id INTO v_feature_id;

    -- Analisar automaticamente
    v_analysis := analyze_feature_request(v_feature_id);

    RETURN jsonb_build_object(
        'success', true,
        'feature_id', v_feature_id,
        'analysis', v_analysis,
        'message', 'Sua solicita├º├úo foi registrada e j├í est├í sendo analisada pela equipe de IA!'
    );
END;
$$;


ALTER FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text", "p_benefit" "text", "p_example" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text", "p_benefit" "text", "p_example" "text") IS 'Fun├º├úo principal para funcion├írios solicitarem melhorias';



CREATE OR REPLACE FUNCTION "public"."reset_user_password"("p_user_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_password TEXT;
BEGIN
  -- Gerar nova senha tempor├íria
  v_password := generate_random_password(8);

  -- Atualizar usu├írio
  UPDATE system_users
  SET temp_password = v_password,
      must_change_password = true,
      login_attempts = 0,
      locked_until = NULL,
      updated_at = now()
  WHERE id = p_user_id;

  RETURN v_password;
END;
$$;


ALTER FUNCTION "public"."reset_user_password"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reset_user_password"("p_user_id" "uuid") IS 'Redefine senha do usu├írio gerando nova senha tempor├íria';



CREATE OR REPLACE FUNCTION "public"."safe_create_entry"("p_entry_date" "date", "p_competence_date" "date", "p_description" character varying, "p_entry_type" character varying, "p_total_debit" numeric, "p_total_credit" numeric, "p_source_type" character varying DEFAULT NULL::character varying, "p_source_id" "uuid" DEFAULT NULL::"uuid", "p_reference_type" character varying DEFAULT NULL::character varying, "p_reference_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("entry_id" "uuid", "internal_code" character varying, "is_new" boolean, "message" character varying)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_existing_id UUID;
    v_existing_code VARCHAR;
    v_new_id UUID;
    v_new_code VARCHAR;
    v_source VARCHAR;
    v_source_uuid UUID;
BEGIN
    -- Determine source
    v_source := COALESCE(p_source_type, p_reference_type, p_entry_type);
    v_source_uuid := COALESCE(p_source_id, p_reference_id);

    -- Check if already exists
    SELECT ae.id, ae.internal_code INTO v_existing_id, v_existing_code
    FROM accounting_entries ae
    WHERE (v_source_uuid IS NOT NULL AND (ae.source_id = v_source_uuid OR ae.reference_id = v_source_uuid))
    LIMIT 1;

    IF v_existing_id IS NOT NULL THEN
        -- Return existing entry
        RETURN QUERY SELECT v_existing_id, v_existing_code, FALSE, 'Entry already exists'::VARCHAR;
        RETURN;
    END IF;

    -- Create new entry
    INSERT INTO accounting_entries (
        entry_date,
        competence_date,
        description,
        entry_type,
        total_debit,
        total_credit,
        balanced,
        source_type,
        source_id,
        reference_type,
        reference_id
    ) VALUES (
        p_entry_date,
        p_competence_date,
        p_description,
        p_entry_type,
        p_total_debit,
        p_total_credit,
        TRUE,
        v_source,
        v_source_uuid,
        p_reference_type,
        p_reference_id
    )
    RETURNING id, accounting_entries.internal_code INTO v_new_id, v_new_code;

    RETURN QUERY SELECT v_new_id, v_new_code, TRUE, 'Entry created successfully'::VARCHAR;
END;
$$;


ALTER FUNCTION "public"."safe_create_entry"("p_entry_date" "date", "p_competence_date" "date", "p_description" character varying, "p_entry_type" character varying, "p_total_debit" numeric, "p_total_credit" numeric, "p_source_type" character varying, "p_source_id" "uuid", "p_reference_type" character varying, "p_reference_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."save_generated_content"("p_template_code" "text", "p_variables" "jsonb", "p_content" "text", "p_provider" "text", "p_model" "text", "p_tokens" integer DEFAULT NULL::integer, "p_time_ms" integer DEFAULT NULL::integer) RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_template_id UUID;
    v_content_id UUID;
BEGIN
    -- Buscar template
    SELECT id INTO v_template_id
    FROM content_templates
    WHERE template_code = p_template_code;

    -- Inserir conte├║do
    INSERT INTO generated_content (
        template_id, template_code, variables_used,
        provider_used, model_used, content_generated,
        tokens_used, generation_time_ms
    ) VALUES (
        v_template_id, p_template_code, p_variables,
        p_provider, p_model, p_content,
        p_tokens, p_time_ms
    )
    RETURNING id INTO v_content_id;

    RETURN v_content_id;
END;
$$;


ALTER FUNCTION "public"."save_generated_content"("p_template_code" "text", "p_variables" "jsonb", "p_content" "text", "p_provider" "text", "p_model" "text", "p_tokens" integer, "p_time_ms" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."schedule_monthly_meeting"() RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_meeting_id UUID;
    v_next_date TIMESTAMPTZ;
BEGIN
    -- Agendar para primeira segunda-feira do pr├│ximo m├¬s ├ás 10h
    v_next_date := date_trunc('month', CURRENT_DATE + INTERVAL '1 month') +
                   (7 - EXTRACT(DOW FROM date_trunc('month', CURRENT_DATE + INTERVAL '1 month'))::int + 1) % 7 * INTERVAL '1 day' +
                   INTERVAL '10 hours';

    INSERT INTO ai_meetings (
        meeting_type, title, scheduled_date, duration_minutes,
        participants, ai_facilitator, ai_participants
    ) VALUES (
        'mensal',
        'Reuni├úo Mensal de Resultados - ' || to_char(v_next_date, 'MM/YYYY'),
        v_next_date,
        90,
        (SELECT jsonb_agg(jsonb_build_object(
            'nome', participant_name,
            'cargo', participant_role,
            'obrigatorio', is_mandatory
        )) FROM meeting_default_participants WHERE meeting_type = 'mensal'),
        'helena',
        ARRAY['milton', 'cicero', 'advocato', 'empresario']
    )
    RETURNING id INTO v_meeting_id;

    -- Gerar pauta
    PERFORM generate_meeting_agenda(v_meeting_id);

    -- Gerar apresenta├º├úo
    PERFORM generate_meeting_presentation(v_meeting_id);

    RETURN v_meeting_id;
END;
$$;


ALTER FUNCTION "public"."schedule_monthly_meeting"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_jurisprudence"("p_keywords" "text"[], "p_outcome" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 5) RETURNS TABLE("court" "text", "case_number" "text", "decision_date" "date", "summary" "text", "outcome" "text", "key_arguments" "text"[], "relevance_score" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        lj.court,
        lj.case_number,
        lj.decision_date,
        lj.summary,
        lj.outcome,
        lj.key_arguments,
        lj.relevance_score
    FROM labor_jurisprudence lj
    WHERE
        (p_keywords IS NULL OR lj.keywords && p_keywords)
        AND (p_outcome IS NULL OR lj.outcome = p_outcome)
    ORDER BY lj.relevance_score DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."search_jurisprudence"("p_keywords" "text"[], "p_outcome" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_addendum_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.addendum_number IS NULL THEN
    NEW.addendum_number := generate_addendum_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_addendum_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_bank_tx_internal_code"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    IF NEW.internal_code IS NULL THEN
        NEW.internal_code := public.generate_bank_tx_code(
            NEW.bank_reference,
            NEW.transaction_date,
            NEW.amount,
            NEW.description,
            NEW.id -- Passando o UUID da transa├º├úo
        );
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_bank_tx_internal_code"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_cash_flow_projection_tenant_id"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Preencher tenant_id se n├úo foi fornecido
  IF NEW.tenant_id IS NULL THEN
    NEW.tenant_id := get_current_tenant_id();
  END IF;

  -- Preencher created_by se n├úo foi fornecido
  IF NEW.created_by IS NULL THEN
    NEW.created_by := auth.uid();
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_cash_flow_projection_tenant_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_confession_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.confession_number IS NULL THEN
    NEW.confession_number := generate_confession_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_confession_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_contract_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.contract_number IS NULL THEN
    NEW.contract_number := generate_contract_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_contract_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_internal_code"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- Only set if not already provided
    IF NEW.internal_code IS NULL THEN
        NEW.internal_code := generate_internal_code(
            COALESCE(NEW.source_type, NEW.reference_type, 'manual'),
            COALESCE(NEW.source_id, NEW.reference_id),
            NEW.entry_date,
            NEW.total_debit
        );
    END IF;

    -- Also set source tracking if using reference fields
    IF NEW.source_type IS NULL AND NEW.reference_type IS NOT NULL THEN
        NEW.source_type := NEW.reference_type;
    END IF;
    IF NEW.source_id IS NULL AND NEW.reference_id IS NOT NULL THEN
        NEW.source_id := NEW.reference_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_internal_code"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_letter_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.letter_number IS NULL THEN
    NEW.letter_number := generate_letter_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_letter_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_proposal_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.proposal_number IS NULL THEN
    NEW.proposal_number := generate_proposal_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_proposal_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_termination_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.termination_number IS NULL THEN
    NEW.termination_number := generate_termination_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_termination_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_all_accounting_entries"("p_start_date" "date" DEFAULT '2025-01-01'::"date", "p_end_date" "date" DEFAULT '2025-12-31'::"date") RETURNS TABLE("source_type" character varying, "processed" integer, "created" integer, "skipped" integer)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_bt RECORD;
    v_inv RECORD;
    v_processed_bt INT := 0;
    v_created_bt INT := 0;
    v_processed_inv INT := 0;
    v_created_inv INT := 0;
    v_entry_id UUID;
BEGIN
    -- Process bank transactions
    FOR v_bt IN
        SELECT id FROM bank_transactions
        WHERE transaction_date >= p_start_date
          AND transaction_date <= p_end_date
          AND is_opening_balance IS NOT TRUE
          AND journal_entry_id IS NULL
    LOOP
        v_processed_bt := v_processed_bt + 1;
        v_entry_id := create_entry_from_bank_transaction(v_bt.id);
        IF v_entry_id IS NOT NULL THEN
            v_created_bt := v_created_bt + 1;
        END IF;
    END LOOP;

    -- Return bank transaction results
    source_type := 'bank_transaction';
    processed := v_processed_bt;
    created := v_created_bt;
    skipped := v_processed_bt - v_created_bt;
    RETURN NEXT;

    -- Process invoices
    FOR v_inv IN
        SELECT id FROM invoices
        WHERE competence LIKE '%/2025'
          AND journal_entry_id IS NULL
    LOOP
        v_processed_inv := v_processed_inv + 1;
        v_entry_id := create_entry_from_invoice(v_inv.id);
        IF v_entry_id IS NOT NULL THEN
            v_created_inv := v_created_inv + 1;
        END IF;
    END LOOP;

    -- Return invoice results
    source_type := 'invoice';
    processed := v_processed_inv;
    created := v_created_inv;
    skipped := v_processed_inv - v_created_inv;
    RETURN NEXT;
END;
$$;


ALTER FUNCTION "public"."sync_all_accounting_entries"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_bank_balance_from_accounting"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_balance DECIMAL(15,2);
BEGIN
    -- Calculate balance from accounting entries
    SELECT COALESCE(SUM(ael.debit) - SUM(ael.credit), 0)
    INTO v_balance
    FROM accounting_entry_lines ael
    JOIN chart_of_accounts coa ON coa.id = ael.account_id
    WHERE coa.code = '1.1.1.05';  -- Sicredi

    -- Update bank_accounts
    UPDATE bank_accounts
    SET current_balance = v_balance,
        updated_at = NOW()
    WHERE name LIKE '%Sicredi%';
END;
$$;


ALTER FUNCTION "public"."sync_bank_balance_from_accounting"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_category_name_to_expenses"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Se o nome da categoria foi alterado
  IF OLD.name <> NEW.name THEN
    -- Atualizar todas as despesas vinculadas com o novo nome
    UPDATE expenses
    SET category = NEW.name
    WHERE category_id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_category_name_to_expenses"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."tr_payroll_generate_entries"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    IF NEW.status = 'fechada' AND OLD.status != 'fechada' THEN
        PERFORM generate_payroll_journal_entries(NEW.id);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."tr_payroll_generate_entries"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_expense_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Deletar lan├ºamentos de provisionamento
  PERFORM delete_journal_entries_by_reference('expenses', OLD.id);

  -- Deletar lan├ºamentos de pagamento
  PERFORM delete_journal_entries_by_reference('expenses_payment', OLD.id);

  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."trg_expense_delete"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_expense_delete"() IS 'Trigger: Remove lan├ºamentos ao deletar despesa';



CREATE OR REPLACE FUNCTION "public"."trg_expense_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_info RECORD;
  v_payable_account_id UUID;
  v_bank_account_id UUID;
  v_competence_date DATE;
BEGIN
  -- Obter conta baseada na categoria (pode ser despesa ou adiantamento)
  SELECT * INTO v_account_info
  FROM get_expense_or_adiantamento_account(NEW.category);

  -- Data de compet├¬ncia (usa due_date, n├úo expense_date)
  v_competence_date := COALESCE(NEW.due_date, CURRENT_DATE);

  IF v_account_info.is_adiantamento THEN
    -- ADIANTAMENTO: D: Adiantamento a S├│cio / C: Banco
    -- S├│ registra quando PAGO (n├úo provisiona)
    IF NEW.status = 'paid' THEN
      SELECT id INTO v_bank_account_id
      FROM chart_of_accounts
      WHERE code = '1.1.1.02';

      IF v_bank_account_id IS NULL THEN
        SELECT id INTO v_bank_account_id
        FROM chart_of_accounts
        WHERE code = '1.1.1.01';
      END IF;

      PERFORM create_journal_entry(
        COALESCE(NEW.payment_date, NEW.due_date, CURRENT_DATE),
        v_competence_date,
        'adiantamento_socio',
        'Adiantamento: ' || NEW.description,
        'expenses',
        NEW.id,
        v_account_info.account_id,  -- D├®bito: Adiantamento a S├│cio
        v_bank_account_id,          -- Cr├®dito: Banco
        NEW.amount,
        NEW.created_by
      );
    END IF;
  ELSE
    -- DESPESA: D: Conta de Despesa / C: Fornecedores a Pagar
    SELECT id INTO v_payable_account_id
    FROM chart_of_accounts
    WHERE code = '2.1.1.01';

    IF v_payable_account_id IS NULL THEN
      RAISE EXCEPTION 'Conta de fornecedores 2.1.1.01 n├úo encontrada';
    END IF;

    -- Criar lan├ºamento de provisionamento
    PERFORM create_journal_entry(
      COALESCE(NEW.due_date, NEW.created_at::DATE, CURRENT_DATE),
      v_competence_date,
      'despesa',
      'Despesa: ' || NEW.description,
      'expenses',
      NEW.id,
      v_account_info.account_id,  -- D├®bito: Conta de Despesa
      v_payable_account_id,       -- Cr├®dito: Fornecedores a Pagar
      NEW.amount,
      NEW.created_by
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_expense_insert"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_expense_insert"() IS 'Trigger: Cria lan├ºamento cont├íbil ao inserir despesa (usa due_date)';



CREATE OR REPLACE FUNCTION "public"."trg_expense_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_account_info RECORD;
  v_payable_account_id UUID;
  v_bank_account_id UUID;
BEGIN
  -- Obter informa├º├Áes da conta
  SELECT * INTO v_account_info
  FROM get_expense_or_adiantamento_account(NEW.category);

  -- Se status mudou para PAGO
  IF OLD.status != 'paid' AND NEW.status = 'paid' THEN
    IF v_account_info.is_adiantamento THEN
      -- ADIANTAMENTO: Criar lan├ºamento apenas agora (quando pago)
      -- Verificar se j├í n├úo existe
      IF NOT EXISTS (
        SELECT 1 FROM accounting_entries
        WHERE reference_type = 'expenses'
          AND reference_id = NEW.id
          AND entry_type = 'adiantamento_socio'
      ) THEN
        SELECT id INTO v_bank_account_id
        FROM chart_of_accounts
        WHERE code = '1.1.1.02';

        IF v_bank_account_id IS NULL THEN
          SELECT id INTO v_bank_account_id
          FROM chart_of_accounts
          WHERE code = '1.1.1.01';
        END IF;

        PERFORM create_journal_entry(
          COALESCE(NEW.payment_date, CURRENT_DATE),
          COALESCE(NEW.payment_date, CURRENT_DATE),
          'adiantamento_socio',
          'Adiantamento: ' || NEW.description,
          'expenses',
          NEW.id,
          v_account_info.account_id,
          v_bank_account_id,
          NEW.amount,
          NEW.created_by
        );
      END IF;
    ELSE
      -- DESPESA: Criar lan├ºamento de pagamento (baixa de fornecedor)
      SELECT id INTO v_payable_account_id
      FROM chart_of_accounts
      WHERE code = '2.1.1.01';

      SELECT id INTO v_bank_account_id
      FROM chart_of_accounts
      WHERE code = '1.1.1.02';

      IF v_bank_account_id IS NULL THEN
        SELECT id INTO v_bank_account_id
        FROM chart_of_accounts
        WHERE code = '1.1.1.01';
      END IF;

      PERFORM create_journal_entry(
        COALESCE(NEW.payment_date, CURRENT_DATE),
        COALESCE(NEW.payment_date, CURRENT_DATE),
        'pagamento_despesa',
        'Pagamento: ' || NEW.description,
        'expenses_payment',
        NEW.id,
        v_payable_account_id,   -- D├®bito: Fornecedores (baixa)
        v_bank_account_id,      -- Cr├®dito: Banco
        NEW.amount,
        NEW.created_by
      );
    END IF;
  END IF;

  -- Se valor mudou e N├âO ├® adiantamento, atualizar lan├ºamentos
  IF OLD.amount != NEW.amount AND NOT v_account_info.is_adiantamento THEN
    UPDATE accounting_entries
    SET total_debit = NEW.amount, total_credit = NEW.amount
    WHERE reference_type = 'expenses' AND reference_id = NEW.id;

    UPDATE accounting_entry_lines
    SET debit = CASE WHEN debit > 0 THEN NEW.amount ELSE 0 END,
        credit = CASE WHEN credit > 0 THEN NEW.amount ELSE 0 END
    WHERE entry_id IN (
      SELECT id FROM accounting_entries
      WHERE reference_type = 'expenses' AND reference_id = NEW.id
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_expense_update"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_expense_update"() IS 'Trigger: Atualiza contabilidade ao modificar despesa (usa due_date)';



CREATE OR REPLACE FUNCTION "public"."trg_invoice_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Deletar lan├ºamentos de compet├¬ncia
  PERFORM delete_journal_entries_by_reference('invoices', OLD.id);

  -- Deletar lan├ºamentos de pagamento
  PERFORM delete_journal_entries_by_reference('invoices_payment', OLD.id);

  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."trg_invoice_delete"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_invoice_delete"() IS 'Trigger: Remove lan├ºamentos ao deletar honor├írio';



CREATE OR REPLACE FUNCTION "public"."trg_invoice_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $_$
DECLARE
  v_client_name TEXT;
  v_client_account_id UUID;
  v_revenue_account_id UUID;
  v_competence_date DATE;
BEGIN
  -- Buscar nome do cliente
  SELECT name INTO v_client_name
  FROM clients
  WHERE id = NEW.client_id;

  IF v_client_name IS NULL THEN
    v_client_name := 'Cliente n├úo identificado';
  END IF;

  -- Buscar conta de receita de honor├írios
  SELECT id INTO v_revenue_account_id
  FROM chart_of_accounts
  WHERE code = '3.1.1.01';

  IF v_revenue_account_id IS NULL THEN
    -- Apenas avisa, n├úo bloqueia a opera├º├úo
    RAISE WARNING 'Conta de receita 3.1.1.01 n├úo encontrada. Lan├ºamento cont├íbil n├úo criado para invoice %', NEW.id;
    RETURN NEW;
  END IF;

  -- Tentar obter/criar conta do cliente
  BEGIN
    v_client_account_id := get_or_create_client_account(NEW.client_id, v_client_name);
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Erro ao criar conta do cliente %: %. Lan├ºamento cont├íbil n├úo criado.', v_client_name, SQLERRM;
    RETURN NEW;
  END;

  IF v_client_account_id IS NULL THEN
    RAISE WARNING 'N├úo foi poss├¡vel criar conta para cliente %. Lan├ºamento cont├íbil n├úo criado.', v_client_name;
    RETURN NEW;
  END IF;

  -- Calcular data de compet├¬ncia baseada no campo competence (MM/YYYY)
  IF NEW.competence IS NOT NULL AND NEW.competence ~ '^\d{2}/\d{4}$' THEN
    v_competence_date := TO_DATE('01/' || NEW.competence, 'DD/MM/YYYY');
    -- Usar ├║ltimo dia do m├¬s
    v_competence_date := (DATE_TRUNC('MONTH', v_competence_date) + INTERVAL '1 MONTH - 1 day')::DATE;
  ELSE
    v_competence_date := COALESCE(NEW.due_date, CURRENT_DATE);
  END IF;

  -- Tentar criar lan├ºamento no di├írio
  BEGIN
    PERFORM create_journal_entry(
      COALESCE(NEW.due_date, NEW.created_at::DATE, CURRENT_DATE),
      v_competence_date,
      'receita_honorarios',
      'Honor├írios ' || COALESCE(NEW.competence, '') || ' - ' || v_client_name,
      'invoices',
      NEW.id,
      v_client_account_id,      -- D├®bito: Cliente a Receber
      v_revenue_account_id,     -- Cr├®dito: Receita de Honor├írios
      NEW.amount,
      NEW.created_by
    );
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Erro ao criar lan├ºamento cont├íbil para invoice %: %', NEW.id, SQLERRM;
    -- Continua mesmo com erro no lan├ºamento
  END;

  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."trg_invoice_insert"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_invoice_insert"() IS 'Trigger: Cria lan├ºamento cont├íbil ao inserir honor├írio (tolerante a erros)';



CREATE OR REPLACE FUNCTION "public"."trg_invoice_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client_name TEXT;
  v_client_account_id UUID;
  v_revenue_account_id UUID;
  v_bank_account_id UUID;
  v_competence_date DATE;
BEGIN
  -- Buscar nome do cliente
  SELECT name INTO v_client_name
  FROM clients
  WHERE id = NEW.client_id;

  IF v_client_name IS NULL THEN
    v_client_name := 'Cliente n├úo identificado';
  END IF;

  -- Se status mudou para PAGO
  IF OLD.status != 'paid' AND NEW.status = 'paid' THEN
    -- Obter conta do cliente
    v_client_account_id := get_or_create_client_account(NEW.client_id, v_client_name);

    -- Buscar conta banc├íria SICREDI
    SELECT id INTO v_bank_account_id
    FROM chart_of_accounts
    WHERE code = '1.1.1.02';

    IF v_bank_account_id IS NULL THEN
      -- Criar conta se n├úo existir
      INSERT INTO chart_of_accounts (code, name, account_type, nature, level, is_analytical, is_active)
      VALUES ('1.1.1.02', 'Banco Sicredi C/C', 'ATIVO', 'DEVEDORA', 4, true, true)
      RETURNING id INTO v_bank_account_id;
    END IF;

    -- Criar lan├ºamento de recebimento no di├írio
    PERFORM create_journal_entry(
      COALESCE(NEW.paid_date, CURRENT_DATE),
      COALESCE(NEW.paid_date, CURRENT_DATE),
      'recebimento',
      'Recebimento ' || v_client_name || ' - Honor├írios ' || NEW.competence,
      'invoices_payment',
      NEW.id,
      v_bank_account_id,        -- D├®bito: Banco SICREDI
      v_client_account_id,      -- Cr├®dito: Cliente a Receber (baixa)
      NEW.amount,
      NEW.created_by
    );
  END IF;

  -- Se valor mudou, atualizar lan├ºamentos existentes
  IF OLD.amount != NEW.amount THEN
    -- Atualizar valores nos lan├ºamentos de compet├¬ncia
    UPDATE accounting_entries
    SET total_debit = NEW.amount, total_credit = NEW.amount
    WHERE reference_type = 'invoices' AND reference_id = NEW.id;

    UPDATE accounting_entry_lines
    SET debit = CASE WHEN debit > 0 THEN NEW.amount ELSE 0 END,
        credit = CASE WHEN credit > 0 THEN NEW.amount ELSE 0 END
    WHERE entry_id IN (
      SELECT id FROM accounting_entries
      WHERE reference_type = 'invoices' AND reference_id = NEW.id
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_invoice_update"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_invoice_update"() IS 'Trigger: Atualiza contabilidade ao modificar honor├írio';



CREATE OR REPLACE FUNCTION "public"."trigger_bank_transaction_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    -- Only create entry for new transactions (not opening balance)
    IF NEW.is_opening_balance IS NOT TRUE THEN
        PERFORM create_entry_from_bank_transaction(NEW.id);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_bank_transaction_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_create_accounting_on_invoice"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Ignorar saldos de abertura
  IF NEW.source = 'opening_balance' THEN
    RETURN NEW;
  END IF;

  -- Criar lan├ºamento cont├íbil de forma ass├¡ncrona (n├úo bloqueia o insert)
  BEGIN
    PERFORM create_accounting_entry_for_invoice(NEW.id);
  EXCEPTION WHEN OTHERS THEN
    -- Log do erro mas n├úo falha a transa├º├úo
    RAISE WARNING 'Erro ao criar contabilidade para fatura %: %', NEW.id, SQLERRM;
  END;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_create_accounting_on_invoice"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_generate_contract_on_client"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_template_id UUID;
  v_contract_number TEXT;
BEGIN
  -- S├│ gera para clientes pagantes (n├úo pro-bono, n├úo permuta)
  IF NEW.is_pro_bono = true OR NEW.is_barter = true THEN
    RETURN NEW;
  END IF;

  -- Buscar template padr├úo de contrato
  SELECT id INTO v_template_id
  FROM document_templates
  WHERE type = 'contract' AND is_default = true AND is_active = true
  LIMIT 1;

  -- Gerar n├║mero do contrato
  v_contract_number := 'CTR-' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(NEXTVAL('contract_number_seq')::TEXT, 5, '0');

  -- Criar registro do contrato (conte├║do ser├í gerado pela IA)
  INSERT INTO client_contracts (
    client_id,
    template_id,
    contract_number,
    type,
    status,
    start_date,
    end_date,
    monthly_fee,
    payment_day,
    created_by
  ) VALUES (
    NEW.id,
    v_template_id,
    v_contract_number,
    'service',
    'draft', -- IA vai processar e mudar para 'active'
    COALESCE(NEW.data_abertura, CURRENT_DATE),
    NULL, -- Prazo indeterminado
    NEW.monthly_fee,
    NEW.payment_day,
    NEW.created_by
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_generate_contract_on_client"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_generate_distract_on_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_contract_id UUID;
  v_distract_number TEXT;
  v_reason TEXT;
BEGIN
  -- Verificar se mudou para suspensa ou inativa
  IF NEW.situacao_cadastral IN ('SUSPENSA', 'INAPTA', 'BAIXADA', 'NULA')
     AND (OLD.situacao_cadastral IS NULL OR OLD.situacao_cadastral NOT IN ('SUSPENSA', 'INAPTA', 'BAIXADA', 'NULA')) THEN

    -- Buscar contrato ativo
    SELECT id INTO v_contract_id
    FROM client_contracts
    WHERE client_id = NEW.id AND status = 'active'
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_contract_id IS NOT NULL THEN
      -- Determinar motivo
      v_reason := CASE
        WHEN NEW.situacao_cadastral = 'SUSPENSA' THEN 'company_suspended'
        ELSE 'company_inactive'
      END;

      -- Gerar n├║mero do distrato
      v_distract_number := 'DST-' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(NEXTVAL('distract_number_seq')::TEXT, 5, '0');

      -- Criar distrato
      INSERT INTO client_distracts (
        client_id,
        contract_id,
        distract_number,
        reason,
        reason_details,
        termination_date,
        notification_date,
        status
      ) VALUES (
        NEW.id,
        v_contract_id,
        v_distract_number,
        v_reason,
        'Empresa com situa├º├úo cadastral: ' || NEW.situacao_cadastral,
        CURRENT_DATE,
        CURRENT_DATE,
        'draft' -- IA vai processar
      );

      -- Atualizar contrato para terminated
      UPDATE client_contracts
      SET status = 'terminated', updated_at = NOW()
      WHERE id = v_contract_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_generate_distract_on_status_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_invoice_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    PERFORM create_entry_from_invoice(NEW.id);
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_invoice_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_queue_new_entry_for_validation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Enfileirar para valida├º├úo (prioridade normal)
  PERFORM queue_entry_for_ai_validation(NEW.id, 5);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_queue_new_entry_for_validation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_recalc_journal_totals"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE journal_entries
  SET
    total_debit = (SELECT COALESCE(SUM(debit_amount), 0) FROM journal_entry_lines WHERE journal_entry_id = COALESCE(NEW.journal_entry_id, OLD.journal_entry_id)),
    total_credit = (SELECT COALESCE(SUM(credit_amount), 0) FROM journal_entry_lines WHERE journal_entry_id = COALESCE(NEW.journal_entry_id, OLD.journal_entry_id)),
    updated_at = NOW()
  WHERE id = COALESCE(NEW.journal_entry_id, OLD.journal_entry_id);

  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."trigger_recalc_journal_totals"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_update_bank_balance"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM update_bank_account_balance(OLD.bank_account_id);
    RETURN OLD;
  ELSE
    PERFORM update_bank_account_balance(NEW.bank_account_id);
    RETURN NEW;
  END IF;
END;
$$;


ALTER FUNCTION "public"."trigger_update_bank_balance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_update_ledger_after_journal"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Atualizar view materializada de forma ass├¡ncrona
  PERFORM pg_notify('refresh_ledger', '');
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_update_ledger_after_journal"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_account_balances"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Atualizar saldos quando um lan├ºamento ├® criado ou modificado
  -- Implementa├º├úo simplificada - pode ser expandida
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_account_balances"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_ai_learned_patterns_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_ai_learned_patterns_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_balance DECIMAL(10,2);
BEGIN
  -- Calculate balance from transactions
  SELECT COALESCE(
    SUM(CASE
      WHEN type = 'credit' THEN amount
      WHEN type = 'debit' THEN -amount
      ELSE 0
    END),
    0
  ) INTO v_balance
  FROM bank_transactions
  WHERE bank_account_id = p_account_id;

  -- Update bank account balance
  UPDATE bank_accounts
  SET 
    current_balance = initial_balance + v_balance,
    updated_at = now()
  WHERE id = p_account_id;
END;
$$;


ALTER FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") IS 'Atualiza o saldo atual de uma conta banc├íria baseado nas transa├º├Áes';



CREATE OR REPLACE FUNCTION "public"."update_bank_balance_on_transaction"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
    v_old_amount DECIMAL := 0;
    v_new_amount DECIMAL := 0;
    v_balance_change DECIMAL := 0;
BEGIN
    IF TG_OP = 'DELETE' THEN
        -- Reverter a transa├º├úo deletada
        IF OLD.transaction_type = 'credit' THEN
            v_balance_change := -ABS(OLD.amount);
        ELSE
            v_balance_change := ABS(OLD.amount);
        END IF;

        UPDATE bank_accounts
        SET current_balance = current_balance + v_balance_change
        WHERE id = OLD.bank_account_id;

        RETURN OLD;
    END IF;

    IF TG_OP = 'INSERT' THEN
        -- Aplicar nova transa├º├úo
        IF NEW.transaction_type = 'credit' THEN
            v_balance_change := ABS(NEW.amount);
        ELSE
            v_balance_change := -ABS(NEW.amount);
        END IF;

        UPDATE bank_accounts
        SET current_balance = current_balance + v_balance_change
        WHERE id = NEW.bank_account_id;

        RETURN NEW;
    END IF;

    IF TG_OP = 'UPDATE' THEN
        -- Reverter antiga e aplicar nova se mudou
        IF OLD.bank_account_id = NEW.bank_account_id THEN
            -- Mesma conta, calcular diferen├ºa
            IF OLD.transaction_type = 'credit' THEN
                v_old_amount := ABS(OLD.amount);
            ELSE
                v_old_amount := -ABS(OLD.amount);
            END IF;

            IF NEW.transaction_type = 'credit' THEN
                v_new_amount := ABS(NEW.amount);
            ELSE
                v_new_amount := -ABS(NEW.amount);
            END IF;

            v_balance_change := v_new_amount - v_old_amount;

            UPDATE bank_accounts
            SET current_balance = current_balance + v_balance_change
            WHERE id = NEW.bank_account_id;
        ELSE
            -- Mudou de conta, reverter na antiga e aplicar na nova
            IF OLD.transaction_type = 'credit' THEN
                UPDATE bank_accounts SET current_balance = current_balance - ABS(OLD.amount) WHERE id = OLD.bank_account_id;
            ELSE
                UPDATE bank_accounts SET current_balance = current_balance + ABS(OLD.amount) WHERE id = OLD.bank_account_id;
            END IF;

            IF NEW.transaction_type = 'credit' THEN
                UPDATE bank_accounts SET current_balance = current_balance + ABS(NEW.amount) WHERE id = NEW.bank_account_id;
            ELSE
                UPDATE bank_accounts SET current_balance = current_balance - ABS(NEW.amount) WHERE id = NEW.bank_account_id;
            END IF;
        END IF;

        RETURN NEW;
    END IF;

    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."update_bank_balance_on_transaction"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_bank_balance_on_transaction"() IS 'Atualiza saldo da conta banc├íria quando transa├º├Áes s├úo inseridas/atualizadas/deletadas';



CREATE OR REPLACE FUNCTION "public"."update_cash_entries_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_cash_entries_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_cash_flow_projections_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_cash_flow_projections_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_client_opening_balance"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client_id UUID;
BEGIN
  -- Determine which client_id to update
  IF (TG_OP = 'DELETE') THEN
    v_client_id := OLD.client_id;
  ELSE
    v_client_id := NEW.client_id;
  END IF;

  -- Update the client's opening_balance field
  UPDATE clients
  SET opening_balance = (
    SELECT COALESCE(SUM(amount - paid_amount), 0)
    FROM client_opening_balance
    WHERE client_id = v_client_id
    AND status != 'paid'
  )
  WHERE id = v_client_id;

  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$;


ALTER FUNCTION "public"."update_client_opening_balance"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_client_opening_balance"() IS 'Automatically updates client.opening_balance when opening balance entries change';



CREATE OR REPLACE FUNCTION "public"."update_economic_groups_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_economic_groups_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_entity_usage"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF NEW.entity_id IS NOT NULL THEN
    UPDATE ai_known_entities
    SET usage_count = usage_count + 1,
        last_used_at = NOW()
    WHERE id = NEW.entity_id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_entity_usage"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_nfse_tomadas_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_nfse_tomadas_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_nfse_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_nfse_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_opening_balance_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_opening_balance_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_overdue_confession_installments"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE debt_confession_installments
  SET status = 'overdue'
  WHERE status = 'pending'
    AND due_date < CURRENT_DATE;

  -- Marcar confiss├Áes como inadimplentes se tiver parcela vencida h├í mais de 30 dias
  UPDATE debt_confessions dc
  SET status = 'defaulted',
      defaulted_at = CURRENT_DATE,
      defaulted_reason = 'Parcela vencida h├í mais de 30 dias'
  FROM debt_confession_installments dci
  WHERE dc.id = dci.confession_id
    AND dc.status = 'active'
    AND dci.status = 'overdue'
    AND dci.due_date < CURRENT_DATE - INTERVAL '30 days';
END;
$$;


ALTER FUNCTION "public"."update_overdue_confession_installments"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_overdue_invoices"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Atualizar invoices pendentes que j├í venceram
  UPDATE invoices
  SET
    status = 'overdue',
    updated_at = now()
  WHERE status = 'pending'
    AND due_date < CURRENT_DATE;

  -- Log da atualiza├º├úo
  RAISE NOTICE 'Updated % invoices to overdue status',
    (SELECT count(*) FROM invoices WHERE status = 'overdue' AND updated_at::date = CURRENT_DATE);
END;
$$;


ALTER FUNCTION "public"."update_overdue_invoices"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_overdue_invoices"() IS 'Atualiza automaticamente invoices pendentes que j├í venceram para status overdue';



CREATE OR REPLACE FUNCTION "public"."update_pattern_usage"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Buscar padr├úo que foi usado
  UPDATE ai_classification_patterns
  SET usage_count = usage_count + 1,
      last_used_at = NOW()
  WHERE id IN (
    SELECT p.id
    FROM ai_classification_patterns p
    WHERE p.debit_account_code = NEW.final_debit_account
      AND p.credit_account_code = NEW.final_credit_account
      AND p.category = NEW.final_category
    LIMIT 1
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_pattern_usage"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_payroll_totals"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE payrolls
  SET
    total_bruto = COALESCE(
      (SELECT SUM(salary_bruto) FROM payroll_details WHERE payroll_id = COALESCE(NEW.payroll_id, OLD.payroll_id)),
      0
    ),
    total_inss = COALESCE(
      (SELECT SUM(inss_retido) FROM payroll_details WHERE payroll_id = COALESCE(NEW.payroll_id, OLD.payroll_id)),
      0
    ),
    total_irrf = COALESCE(
      (SELECT SUM(irrf_retido) FROM payroll_details WHERE payroll_id = COALESCE(NEW.payroll_id, OLD.payroll_id)),
      0
    ),
    total_liquido = COALESCE(
      (SELECT SUM(salary_liquido) FROM payroll_details WHERE payroll_id = COALESCE(NEW.payroll_id, OLD.payroll_id)),
      0
    )
  WHERE id = COALESCE(NEW.payroll_id, OLD.payroll_id);
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_payroll_totals"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_payrolls_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_payrolls_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_service_total_costs"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE company_services
  SET total_costs = (
    SELECT COALESCE(SUM(amount), 0)
    FROM company_service_costs
    WHERE service_id = COALESCE(NEW.service_id, OLD.service_id)
  ),
  updated_at = NOW()
  WHERE id = COALESCE(NEW.service_id, OLD.service_id);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_service_total_costs"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_stock_after_consumption"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE office_products
  SET
    current_stock = GREATEST(0, current_stock - NEW.quantity),
    updated_at = now()
  WHERE id = NEW.product_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_stock_after_consumption"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_stock_after_purchase"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Atualizar estoque atual
  UPDATE office_products
  SET
    current_stock = current_stock + NEW.quantity,
    last_price = NEW.unit_price,
    last_price_date = NEW.purchase_date,
    updated_at = now()
  WHERE id = NEW.product_id;

  -- Recalcular pre├ºo m├®dio
  UPDATE office_products
  SET average_price = (
    SELECT ROUND(AVG(unit_price), 2)
    FROM product_purchases
    WHERE product_id = NEW.product_id
  )
  WHERE id = NEW.product_id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_stock_after_purchase"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_work_order_status_on_log"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  UPDATE collection_work_orders
  SET 
    status = CASE 
      WHEN status = 'pending' THEN 'in_progress'
      ELSE status
    END,
    updated_at = now()
  WHERE id = NEW.work_order_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_work_order_status_on_log"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."user_has_office_access"("p_office_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_office_access
    WHERE user_id = auth.uid()
    AND office_id = p_office_id
  );
END;
$$;


ALTER FUNCTION "public"."user_has_office_access"("p_office_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."user_has_permission"("required_permission" "text") RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  user_permissions JSONB;
  user_role TEXT;
BEGIN
  SELECT tu.permissions, tu.role INTO user_permissions, user_role
  FROM tenant_users tu
  WHERE tu.user_id = auth.uid()
    AND tu.tenant_id = get_current_tenant_id()
    AND tu.is_active = true
  LIMIT 1;

  -- Admin e owner t├¬m todas as permiss├Áes
  IF user_role IN ('owner', 'admin') THEN
    RETURN true;
  END IF;

  -- Verificar permiss├úo espec├¡fica
  RETURN user_permissions ? required_permission;
END;
$$;


ALTER FUNCTION "public"."user_has_permission"("required_permission" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_client_before_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  normalized_cnpj TEXT;
  normalized_cpf  TEXT;
  existing_id     UUID;
BEGIN
  IF (NEW.cnpj IS NULL OR btrim(NEW.cnpj) = '')
     AND (NEW.cpf IS NULL OR btrim(NEW.cpf) = '') THEN
    RAISE EXCEPTION 'Cliente precisa ter CNPJ ou CPF para ser cadastrado.';
  END IF;
  
  IF NEW.cnpj IS NOT NULL AND btrim(NEW.cnpj) <> '' THEN
    normalized_cnpj := regexp_replace(NEW.cnpj, '[^0-9]', '', 'g');
    
    IF length(normalized_cnpj) <> 14 THEN
      RAISE EXCEPTION 'CNPJ inv├ílido (deve conter 14 d├¡gitos).';
    END IF;
    
    SELECT id INTO existing_id
    FROM public.clients
    WHERE status = 'active'
      AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
      AND regexp_replace(cnpj, '[^0-9]', '', 'g') = normalized_cnpj
    LIMIT 1;
    
    IF existing_id IS NOT NULL THEN
      RAISE EXCEPTION 'J├í existe cliente ativo com este CNPJ exato (ID: %). Filiais diferentes da mesma empresa s├úo permitidas.', existing_id;
    END IF;
  END IF;
  
  IF NEW.cpf IS NOT NULL AND btrim(NEW.cpf) <> '' THEN
    normalized_cpf := regexp_replace(NEW.cpf, '[^0-9]', '', 'g');
    
    IF length(normalized_cpf) <> 11 THEN
      RAISE EXCEPTION 'CPF inv├ílido (deve conter 11 d├¡gitos).';
    END IF;
    
    SELECT id INTO existing_id
    FROM public.clients
    WHERE status = 'active'
      AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
      AND regexp_replace(cpf, '[^0-9]', '', 'g') = normalized_cpf
    LIMIT 1;
    
    IF existing_id IS NOT NULL THEN
      RAISE EXCEPTION 'J├í existe cliente ativo com este CPF (ID: %).', existing_id;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_client_before_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_client_document"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  normalized_cnpj TEXT;
  normalized_cpf TEXT;
  existing_id UUID;
  cnpj_root TEXT;
BEGIN
  IF (NEW.cnpj IS NULL OR btrim(NEW.cnpj) = '')
     AND (NEW.cpf IS NULL OR btrim(NEW.cpf) = '') THEN
    RAISE EXCEPTION 'Cliente precisa ter CNPJ ou CPF para ser cadastrado.';
  END IF;
  
  IF NEW.cnpj IS NOT NULL AND btrim(NEW.cnpj) <> '' THEN
    normalized_cnpj := regexp_replace(NEW.cnpj, '[^0-9]', '', 'g');
    
    IF length(normalized_cnpj) = 11 THEN
      NEW.cpf := normalized_cnpj;
      NEW.cnpj := NULL;
      normalized_cnpj := NULL;
    ELSIF length(normalized_cnpj) <> 14 THEN
      RAISE EXCEPTION 'CNPJ inv├ílido (deve conter 14 d├¡gitos). Se for CPF, o campo deve conter 11 d├¡gitos.';
    END IF;
    
    IF normalized_cnpj IS NOT NULL THEN
      SELECT id INTO existing_id
      FROM public.clients
      WHERE status = 'active'
        AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
        AND regexp_replace(cnpj, '[^0-9]', '', 'g') = normalized_cnpj
      LIMIT 1;
      
      IF existing_id IS NOT NULL THEN
        RAISE EXCEPTION 'CNPJ j├í cadastrado para outro cliente ativo.';
      END IF;
      
      cnpj_root := substring(normalized_cnpj from 1 for 8);
    END IF;
  END IF;
  
  IF NEW.cpf IS NOT NULL AND btrim(NEW.cpf) <> '' THEN
    normalized_cpf := regexp_replace(NEW.cpf, '[^0-9]', '', 'g');
    
    IF length(normalized_cpf) <> 11 THEN
      RAISE EXCEPTION 'CPF inv├ílido (deve conter 11 d├¡gitos).';
    END IF;
    
    SELECT id INTO existing_id
    FROM public.clients
    WHERE status = 'active'
      AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
      AND regexp_replace(cpf, '[^0-9]', '', 'g') = normalized_cpf
    LIMIT 1;
    
    IF existing_id IS NOT NULL THEN
      RAISE EXCEPTION 'CPF j├í cadastrado para outro cliente ativo.';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_client_document"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_due_date"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.due_date < CURRENT_DATE THEN
    -- Avisar mas permitir (pode ser importa├º├úo de dados hist├│ricos)
    RAISE WARNING 'Due date % is in the past for invoice %', NEW.due_date, COALESCE(NEW.competence, NEW.id::text);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_due_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_invoice_competence"("p_client_id" "uuid", "p_competence" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
DECLARE
  v_client RECORD;
  v_opening_date DATE;
  v_competence_date DATE;
  v_result JSONB;
BEGIN
  -- Buscar cliente
  SELECT * INTO v_client FROM clients WHERE id = p_client_id;

  IF v_client IS NULL THEN
    RETURN jsonb_build_object('valid', false, 'reason', 'Cliente n├úo encontrado');
  END IF;

  -- Data de abertura
  v_opening_date := v_client.data_abertura;

  IF v_opening_date IS NULL THEN
    -- Se n├úo tem data de abertura, permitir
    RETURN jsonb_build_object('valid', true, 'reason', 'Data de abertura n├úo informada');
  END IF;

  -- Converter compet├¬ncia para data (primeiro dia do m├¬s)
  v_competence_date := (p_competence || '-01')::DATE;

  -- Verificar se compet├¬ncia ├® anterior ├á abertura
  IF v_competence_date < DATE_TRUNC('month', v_opening_date) THEN
    RETURN jsonb_build_object(
      'valid', false,
      'reason', 'Compet├¬ncia anterior ├á data de abertura da empresa',
      'opening_date', v_opening_date,
      'first_valid_competence', TO_CHAR(DATE_TRUNC('month', v_opening_date), 'YYYY-MM')
    );
  END IF;

  -- Verificar situa├º├úo cadastral
  IF v_client.situacao_cadastral IN ('SUSPENSA', 'INAPTA', 'BAIXADA', 'NULA') THEN
    RETURN jsonb_build_object(
      'valid', false,
      'reason', 'Empresa com situa├º├úo cadastral irregular: ' || v_client.situacao_cadastral
    );
  END IF;

  RETURN jsonb_build_object('valid', true);
END;
$$;


ALTER FUNCTION "public"."validate_invoice_competence"("p_client_id" "uuid", "p_competence" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_payroll_details"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'extensions', 'pg_temp'
    AS $$
BEGIN
  -- Validar que sal├írio l├¡quido = bruto - descontos
  IF ABS(
    (NEW.salary_bruto - NEW.inss_retido - NEW.irrf_retido - NEW.outros_descontos) 
    - NEW.salary_liquido
  ) > 0.01 THEN
    NEW.validation_status = 'invalid';
    NEW.validation_message = 'C├ílculo de sal├írio l├¡quido incorreto';
  END IF;
  
  -- Validar INSS
  IF ABS(
    (NEW.salary_bruto * NEW.inss_aliquota / 100) - NEW.inss_retido
  ) > 0.01 THEN
    NEW.validation_status = 'warning';
    NEW.validation_message = COALESCE(
      NEW.validation_message || ' | ',
      ''
    ) || 'INSS pode estar incorreto';
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_payroll_details"() OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."account_balances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_id" "uuid" NOT NULL,
    "period_year" integer NOT NULL,
    "period_month" integer NOT NULL,
    "opening_balance" numeric(15,2) DEFAULT 0,
    "total_debit" numeric(15,2) DEFAULT 0,
    "total_credit" numeric(15,2) DEFAULT 0,
    "closing_balance" numeric(15,2) DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."account_balances" OWNER TO "postgres";


COMMENT ON TABLE "public"."account_balances" IS 'Cache de saldos cont├íbeis por conta e per├¡odo para performance';



CREATE TABLE IF NOT EXISTS "public"."chart_of_accounts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" character varying(20) NOT NULL,
    "name" character varying(200) NOT NULL,
    "account_type" character varying(50) NOT NULL,
    "nature" character varying(10) NOT NULL,
    "parent_id" "uuid",
    "level" integer NOT NULL,
    "is_analytical" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "type" "text",
    "is_synthetic" boolean DEFAULT false NOT NULL,
    "accepts_entries" boolean DEFAULT true,
    "is_result_account" boolean DEFAULT false,
    "sped_referencial_code" character varying(50),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "chart_of_accounts_type_check" CHECK (("type" = ANY (ARRAY['ativo'::"text", 'passivo'::"text", 'receita'::"text", 'despesa'::"text"])))
);


ALTER TABLE "public"."chart_of_accounts" OWNER TO "postgres";


COMMENT ON TABLE "public"."chart_of_accounts" IS 'Plano de Contas atualizado em 11/12/2025.
- Contas de Caixa desativadas (empresa n├úo trabalha com dinheiro f├¡sico)
- Todas as disponibilidades devem ir para 1.1.1.02 Bancos Conta Movimento';



COMMENT ON COLUMN "public"."chart_of_accounts"."code" IS 'C├│digo da conta cont├íbil seguindo estrutura:
1 - ATIVO
2 - PASSIVO
3 - RECEITAS
4 - DESPESAS (inclui 4.5 CSV - Custo dos Servi├ºos Vendidos)
5 - PATRIM├öNIO L├ìQUIDO';



COMMENT ON COLUMN "public"."chart_of_accounts"."is_synthetic" IS 'Contas sint├®ticas recebem somat├│rios, anal├¡ticas recebem lan├ºamentos diretos';



COMMENT ON COLUMN "public"."chart_of_accounts"."sped_referencial_code" IS 'C├│digo da conta no Plano Referencial da Receita Federal (SPED ECD/ECF)';



CREATE TABLE IF NOT EXISTS "public"."journal_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_number" integer NOT NULL,
    "entry_date" "date" NOT NULL,
    "competence" "text" NOT NULL,
    "description" "text" NOT NULL,
    "document_type" "text",
    "document_number" "text",
    "document_id" "uuid",
    "total_debit" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_credit" numeric(15,2) DEFAULT 0 NOT NULL,
    "is_balanced" boolean GENERATED ALWAYS AS (("total_debit" = "total_credit")) STORED,
    "is_closing_entry" boolean DEFAULT false,
    "fiscal_year" integer NOT NULL,
    "ai_generated" boolean DEFAULT false,
    "ai_model" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."journal_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."journal_entry_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "journal_entry_id" "uuid" NOT NULL,
    "line_number" integer NOT NULL,
    "account_id" "uuid" NOT NULL,
    "account_code" "text" NOT NULL,
    "account_name" "text" NOT NULL,
    "debit_amount" numeric(15,2) DEFAULT 0,
    "credit_amount" numeric(15,2) DEFAULT 0,
    "description" "text",
    "client_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "check_debit_or_credit" CHECK (((("debit_amount" > (0)::numeric) AND ("credit_amount" = (0)::numeric)) OR (("credit_amount" > (0)::numeric) AND ("debit_amount" = (0)::numeric)) OR (("debit_amount" = (0)::numeric) AND ("credit_amount" = (0)::numeric)))),
    CONSTRAINT "journal_entry_lines_credit_amount_check" CHECK (("credit_amount" >= (0)::numeric)),
    CONSTRAINT "journal_entry_lines_debit_amount_check" CHECK (("debit_amount" >= (0)::numeric))
);


ALTER TABLE "public"."journal_entry_lines" OWNER TO "postgres";



-- ============================================================================
-- SECAO 5: VIEWS E MATERIALIZED VIEWS
-- ============================================================================
-- 93 views para consultas e relatorios:
--
-- CONTABEIS:
--   - v_balancete: Balancete de verificacao
--   - v_dre_mensal/v_dre_summary: Demonstrativo de Resultado
--   - v_balanco_patrimonial: Balanco Patrimonial
--   - v_trial_balance: Trial Balance
--   - v_livro_diario/v_livro_razao: Livros contabeis
--
-- FINANCEIRAS:
--   - v_accounts_receivable/v_contas_a_receber: Contas a receber
--   - v_cash_flow_daily/v_cash_flow_summary: Fluxo de caixa
--   - v_saldo_banco: Saldo bancario
--
-- MATERIALIZADAS (Performance):
--   - mv_cash_flow: Cache do fluxo de caixa
--   - mv_coa_balances: Saldos do plano de contas
--   - mv_dashboard_kpis: KPIs do dashboard
--   - mv_client_balances: Saldos de clientes
--   - mv_trial_balance: Balancete materializado
-- ============================================================================

CREATE MATERIALIZED VIEW "public"."account_ledger" AS
 SELECT "a"."id" AS "account_id",
    "a"."code" AS "account_code",
    "a"."name" AS "account_name",
    "a"."type" AS "account_type",
    "a"."nature",
    COALESCE("sum"("jel"."debit_amount"), (0)::numeric) AS "total_debit",
    COALESCE("sum"("jel"."credit_amount"), (0)::numeric) AS "total_credit",
        CASE
            WHEN (("a"."nature")::"text" = 'debit'::"text") THEN (COALESCE("sum"("jel"."debit_amount"), (0)::numeric) - COALESCE("sum"("jel"."credit_amount"), (0)::numeric))
            ELSE (COALESCE("sum"("jel"."credit_amount"), (0)::numeric) - COALESCE("sum"("jel"."debit_amount"), (0)::numeric))
        END AS "balance",
    "count"(DISTINCT "jel"."journal_entry_id") AS "movement_count"
   FROM (("public"."chart_of_accounts" "a"
     LEFT JOIN "public"."journal_entry_lines" "jel" ON (("jel"."account_id" = "a"."id")))
     LEFT JOIN "public"."journal_entries" "je" ON (("je"."id" = "jel"."journal_entry_id")))
  GROUP BY "a"."id", "a"."code", "a"."name", "a"."type", "a"."nature"
  ORDER BY "a"."code"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."account_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "cnpj" "text",
    "email" "text",
    "phone" "text",
    "monthly_fee" numeric(15,2) DEFAULT 0,
    "fee_due_day" integer DEFAULT 10,
    "is_active" boolean DEFAULT true,
    "opening_balance" numeric(15,2) DEFAULT 0,
    "opening_balance_details" "jsonb",
    "opening_balance_date" "date" DEFAULT '2024-12-31'::"date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_pro_bono" boolean DEFAULT false,
    "pro_bono_start_date" "date",
    "pro_bono_end_date" "date",
    "pro_bono_reason" "text",
    "cpf" character varying(14),
    "qsa" "jsonb",
    "status" "text" DEFAULT 'active'::"text",
    "opcao_pelo_simples" boolean DEFAULT false,
    "data_opcao_simples" "date",
    "opcao_pelo_mei" boolean DEFAULT false,
    "motivo_situacao_cadastral" "text",
    "data_situacao_cadastral" "date",
    "telefone_secundario" character varying(20),
    "fax" character varying(20),
    "created_by" "uuid",
    "razao_social" "text",
    "nome_fantasia" "text",
    "porte" "text",
    "natureza_juridica" "text",
    "situacao_cadastral" "text",
    "data_abertura" "date",
    "capital_social" numeric,
    "logradouro" "text",
    "numero" "text",
    "complemento" "text",
    "bairro" "text",
    "municipio" "text",
    "uf" "text",
    "cep" "text",
    "atividade_principal" "jsonb",
    "atividades_secundarias" "jsonb",
    "is_barter" boolean DEFAULT false NOT NULL,
    "barter_monthly_credit" numeric(10,2) DEFAULT 0,
    "barter_description" "text",
    "barter_start_date" "date",
    "is_internal" boolean DEFAULT false NOT NULL,
    "notes" "text",
    "payment_day" integer,
    "fee_in_minimum_wages" numeric(10,4),
    "last_fee_adjustment_date" "date",
    "last_adjustment_minimum_wage" numeric(10,2),
    "auto_adjust_by_minimum_wage" boolean DEFAULT true,
    "has_13th_fee" boolean DEFAULT true,
    "thirteenth_fee_day" integer DEFAULT 20,
    "thirteenth_fee_amount" numeric(10,2),
    "regime_tributario" character varying(20) DEFAULT 'lucro_presumido'::character varying,
    "account_id" "uuid",
    "economic_group" "text",
    "movement_status" "text",
    "business_object" "text",
    "municipal_registration" "text",
    "state_registration" "text",
    "city_hall_password" "text",
    "access_code" "text",
    "accounting_account_id" "uuid",
    "contract_start_date" "date",
    "contract_end_date" "date",
    "inactivation_reason" "text",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "chk_cpf_or_cnpj" CHECK ((("cnpj" IS NOT NULL) OR ("cpf" IS NOT NULL))),
    CONSTRAINT "clients_payment_day_check" CHECK ((("payment_day" >= 1) AND ("payment_day" <= 31))),
    CONSTRAINT "clients_thirteenth_fee_day_check" CHECK ((("thirteenth_fee_day" >= 1) AND ("thirteenth_fee_day" <= 31)))
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


COMMENT ON TABLE "public"."clients" IS 'Clientes da contabilidade';



COMMENT ON COLUMN "public"."clients"."opening_balance" IS 'Total opening balance amount (auto-calculated from client_opening_balance)';



COMMENT ON COLUMN "public"."clients"."opening_balance_details" IS 'Additional JSON details about opening balance';



COMMENT ON COLUMN "public"."clients"."opening_balance_date" IS 'Reference date for opening balance (default: 2024-12-31)';



COMMENT ON COLUMN "public"."clients"."is_pro_bono" IS 'Indica se o cliente ├® atendido gratuitamente (pro bono)';



COMMENT ON COLUMN "public"."clients"."pro_bono_start_date" IS 'Data de in├¡cio do atendimento Pro-Bono';



COMMENT ON COLUMN "public"."clients"."pro_bono_end_date" IS 'Data de t├®rmino do atendimento Pro-Bono (NULL = indefinido)';



COMMENT ON COLUMN "public"."clients"."pro_bono_reason" IS 'Justificativa para o atendimento Pro-Bono';



COMMENT ON COLUMN "public"."clients"."cpf" IS 'CPF do cliente (pessoa f├¡sica)';



COMMENT ON COLUMN "public"."clients"."qsa" IS 'Quadro de S├│cios e Administradores (JSON)';



COMMENT ON COLUMN "public"."clients"."opcao_pelo_simples" IS 'Se a empresa ├® optante do Simples Nacional';



COMMENT ON COLUMN "public"."clients"."opcao_pelo_mei" IS 'Se a empresa ├® MEI (Microempreendedor Individual)';



COMMENT ON COLUMN "public"."clients"."motivo_situacao_cadastral" IS 'Motivo da situa├º├úo cadastral atual';



COMMENT ON COLUMN "public"."clients"."data_situacao_cadastral" IS 'Data da ├║ltima altera├º├úo na situa├º├úo cadastral';



COMMENT ON COLUMN "public"."clients"."is_barter" IS 'Indica se o cliente est├í em regime de permuta/escambo';



COMMENT ON COLUMN "public"."clients"."barter_monthly_credit" IS 'Valor mensal de cr├®dito gerado pela permuta (ex: 1 sal├írio m├¡nimo)';



COMMENT ON COLUMN "public"."clients"."barter_description" IS 'Descri├º├úo dos servi├ºos permutados (ex: Servi├ºos de sal├úo de beleza)';



COMMENT ON COLUMN "public"."clients"."barter_start_date" IS 'Data de in├¡cio do acordo de permuta';



COMMENT ON COLUMN "public"."clients"."is_internal" IS 'Indica se o cliente ├® uma empresa interna';



COMMENT ON COLUMN "public"."clients"."notes" IS 'Observa├º├Áes do cliente (texto livre)';



COMMENT ON COLUMN "public"."clients"."payment_day" IS 'Dia do vencimento (1-31) do honor├írio mensal';



COMMENT ON COLUMN "public"."clients"."fee_in_minimum_wages" IS 'Honor├írio convertido em quantidade de sal├írios m├¡nimos';



COMMENT ON COLUMN "public"."clients"."last_fee_adjustment_date" IS 'Data do ├║ltimo reajuste de honor├írio aplicado';



COMMENT ON COLUMN "public"."clients"."last_adjustment_minimum_wage" IS 'Valor do SM usado no ├║ltimo reajuste';



COMMENT ON COLUMN "public"."clients"."auto_adjust_by_minimum_wage" IS 'Se true, reajusta automaticamente pelo SM';



COMMENT ON COLUMN "public"."clients"."has_13th_fee" IS 'Se cobra 13┬║ honor├írio (parcela extra em dezembro)';



COMMENT ON COLUMN "public"."clients"."thirteenth_fee_day" IS 'Dia de vencimento do 13┬║ honor├írio (padr├úo: 20 de dezembro)';



COMMENT ON COLUMN "public"."clients"."thirteenth_fee_amount" IS 'Valor do 13┬║ honor├írio (se NULL, usa monthly_fee)';



COMMENT ON COLUMN "public"."clients"."regime_tributario" IS 'Regime tribut├írio do cliente: simples_nacional, lucro_presumido, lucro_real, mei';



COMMENT ON COLUMN "public"."clients"."account_id" IS 'ID da conta cont├íbil anal├¡tica espec├¡fica deste cliente (Ex: 1.1.2.01.0001)';



COMMENT ON COLUMN "public"."clients"."accounting_account_id" IS 'ID da conta cont├íbil do cliente em Clientes a Receber (1.1.2.01.XXXX)';



COMMENT ON COLUMN "public"."clients"."contract_start_date" IS 'Data de in├¡cio do contrato com a Ampla Contabilidade';



COMMENT ON COLUMN "public"."clients"."contract_end_date" IS 'Data de fim do contrato (quando cliente encerra)';



COMMENT ON COLUMN "public"."clients"."inactivation_reason" IS 'Motivo da inativa├º├úo do cliente';



CREATE OR REPLACE VIEW "public"."account_ledger_detail" WITH ("security_invoker"='true') AS
 SELECT "a"."id" AS "account_id",
    "a"."code" AS "account_code",
    "a"."name" AS "account_name",
    "a"."type" AS "account_type",
    "a"."nature",
    "je"."id" AS "journal_entry_id",
    "je"."entry_number",
    "je"."entry_date",
    "je"."competence",
    "je"."description" AS "entry_description",
    "jel"."description" AS "line_description",
    "jel"."debit_amount",
    "jel"."credit_amount",
    "jel"."client_id",
    "c"."name" AS "client_name",
    "sum"(
        CASE
            WHEN (("a"."nature")::"text" = 'debit'::"text") THEN ("jel"."debit_amount" - "jel"."credit_amount")
            ELSE ("jel"."credit_amount" - "jel"."debit_amount")
        END) OVER (PARTITION BY "a"."id" ORDER BY "je"."entry_date", "je"."entry_number" ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
   FROM ((("public"."chart_of_accounts" "a"
     JOIN "public"."journal_entry_lines" "jel" ON (("jel"."account_id" = "a"."id")))
     JOIN "public"."journal_entries" "je" ON (("je"."id" = "jel"."journal_entry_id")))
     LEFT JOIN "public"."clients" "c" ON (("c"."id" = "jel"."client_id")))
  ORDER BY "a"."code", "je"."entry_date", "je"."entry_number";


ALTER VIEW "public"."account_ledger_detail" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contract_number" "text" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "proposal_id" "uuid",
    "contract_type" "text" DEFAULT 'service'::"text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date",
    "signature_date" "date",
    "monthly_fee" numeric(12,2) NOT NULL,
    "setup_fee" numeric(12,2) DEFAULT 0,
    "payment_day" integer DEFAULT 10,
    "payment_method" "text" DEFAULT 'boleto'::"text",
    "adjustment_index" "text" DEFAULT 'IGPM'::"text",
    "last_adjustment_date" "date",
    "services" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "client_obligations" "jsonb" DEFAULT '[]'::"jsonb",
    "special_clauses" "text",
    "coaf_clause_accepted" boolean DEFAULT true,
    "coaf_acceptance_date" "date",
    "requires_responsibility_letter" boolean DEFAULT true,
    "last_responsibility_letter_date" "date",
    "content" "text",
    "ai_generated" boolean DEFAULT false,
    "document_url" "text",
    "signed_document_url" "text",
    "signature_provider" "text",
    "signature_request_id" "text",
    "signature_status" "text" DEFAULT 'pending'::"text",
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "suspension_reason" "text",
    "termination_reason" "text",
    "termination_date" "date",
    "notes" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounting_contracts_contract_type_check" CHECK (("contract_type" = ANY (ARRAY['service'::"text", 'consulting'::"text", 'partnership'::"text", 'opening'::"text", 'irpf'::"text", 'special'::"text"]))),
    CONSTRAINT "accounting_contracts_payment_day_check" CHECK ((("payment_day" >= 1) AND ("payment_day" <= 31))),
    CONSTRAINT "accounting_contracts_signature_status_check" CHECK (("signature_status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'viewed'::"text", 'signed'::"text", 'refused'::"text", 'expired'::"text"]))),
    CONSTRAINT "accounting_contracts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_signature'::"text", 'active'::"text", 'suspended'::"text", 'terminated'::"text", 'expired'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."accounting_contracts" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_contracts" IS 'Contratos de presta├º├úo de servi├ºos cont├íbeis - Resolu├º├úo CFC 1.590/2020';



CREATE TABLE IF NOT EXISTS "public"."accounting_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_number" integer NOT NULL,
    "entry_date" "date" NOT NULL,
    "competence_date" "date" NOT NULL,
    "description" "text" NOT NULL,
    "history" "text",
    "entry_type" character varying(50) NOT NULL,
    "document_type" character varying(50),
    "document_number" character varying(100),
    "invoice_id" "uuid",
    "transaction_id" "uuid",
    "total_debit" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_credit" numeric(15,2) DEFAULT 0 NOT NULL,
    "is_draft" boolean DEFAULT false,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "reference_type" "text",
    "reference_id" "uuid",
    "balanced" boolean DEFAULT true,
    "notes" "text",
    "ai_validated" boolean DEFAULT false,
    "ai_validated_at" timestamp with time zone,
    "ai_validation_result" "text",
    "ai_validation_message" "text",
    "ai_confidence" numeric(3,2),
    "ai_generated" boolean DEFAULT false,
    "ai_model" "text",
    "cost_center_id" "uuid",
    "internal_code" character varying(100),
    "source_type" character varying(50),
    "source_id" "uuid",
    "source_hash" character varying(64),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounting_entries_ai_validation_result_check" CHECK (("ai_validation_result" = ANY (ARRAY['valid'::"text", 'invalid'::"text", 'warning'::"text", 'pending'::"text"]))),
    CONSTRAINT "check_balanced" CHECK (("total_debit" = "total_credit"))
);


ALTER TABLE "public"."accounting_entries" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_entries" IS 'Lancamentos Jan/2025 - Duplicados SALDO_ABERTURA removidos.';



COMMENT ON COLUMN "public"."accounting_entries"."competence_date" IS 'Data de compet├¬ncia - crucial para regime de compet├¬ncia';



COMMENT ON COLUMN "public"."accounting_entries"."entry_type" IS 'PROVISAO_RECEITA: quando emitido boleto | BAIXA_RECEITA: quando recebido';



COMMENT ON COLUMN "public"."accounting_entries"."ai_validated" IS 'Indica se o lan├ºamento foi validado pela IA';



COMMENT ON COLUMN "public"."accounting_entries"."ai_validation_result" IS 'Resultado da valida├º├úo: valid, invalid, warning, pending';



COMMENT ON COLUMN "public"."accounting_entries"."ai_confidence" IS 'N├¡vel de confian├ºa da IA (0.0 a 1.0)';



COMMENT ON COLUMN "public"."accounting_entries"."ai_generated" IS 'True se o lan├ºamento foi gerado automaticamente pela IA';



COMMENT ON COLUMN "public"."accounting_entries"."cost_center_id" IS 'Centro de custo/departamento do lan├ºamento (DP, Fiscal, Contabil, Legalizacao, Administrativo, Financeiro)';



COMMENT ON COLUMN "public"."accounting_entries"."internal_code" IS 'Unique internal identifier for the entry. Format: {source_type}:{YYYYMMDD}:{hash}. Prevents duplicates and enables traceability.';



COMMENT ON COLUMN "public"."accounting_entries"."source_type" IS 'Origin type: bank_transaction, invoice, expense, manual, etc.';



COMMENT ON COLUMN "public"."accounting_entries"."source_id" IS 'UUID of the source record that generated this entry.';



COMMENT ON CONSTRAINT "check_balanced" ON "public"."accounting_entries" IS 'Garante que d├®bito = cr├®dito (partidas dobradas)';



CREATE SEQUENCE IF NOT EXISTS "public"."accounting_entries_entry_number_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."accounting_entries_entry_number_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."accounting_entries_entry_number_seq" OWNED BY "public"."accounting_entries"."entry_number";



CREATE TABLE IF NOT EXISTS "public"."accounting_entry_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_id" "uuid" NOT NULL,
    "account_id" "uuid" NOT NULL,
    "debit" numeric(15,2) DEFAULT 0,
    "credit" numeric(15,2) DEFAULT 0,
    "history" "text",
    "client_id" "uuid",
    "cost_center" character varying(100),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "check_debit_or_credit" CHECK (((("debit" > (0)::numeric) AND ("credit" = (0)::numeric)) OR (("credit" > (0)::numeric) AND ("debit" = (0)::numeric))))
);


ALTER TABLE "public"."accounting_entry_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_entry_items" IS 'Itens dos lan├ºamentos cont├íbeis (d├®bito e cr├®dito)';



CREATE TABLE IF NOT EXISTS "public"."accounting_entry_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "entry_id" "uuid" NOT NULL,
    "account_id" "uuid" NOT NULL,
    "debit" numeric DEFAULT 0 NOT NULL,
    "credit" numeric DEFAULT 0 NOT NULL,
    "description" "text",
    "cost_center_id" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."accounting_entry_lines" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_entry_lines" IS 'Linhas de lan├ºamentos - Corrigido: adiantamentos agora em conta 1.1.3.04';



CREATE TABLE IF NOT EXISTS "public"."accounting_entry_tracking" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "codigo_rastreamento" character varying(50) NOT NULL,
    "tipo" character varying(20) NOT NULL,
    "competencia_ano" integer NOT NULL,
    "competencia_mes" integer NOT NULL,
    "sequencial" integer NOT NULL,
    "hash_validacao" character varying(6) NOT NULL,
    "entry_id" "uuid" NOT NULL,
    "payroll_id" "uuid",
    "reference_id" character varying(100),
    "dados_originais" "jsonb",
    "original_codigo_rastreamento" character varying(50),
    "foi_duplicado" boolean DEFAULT false,
    "data_criacao" timestamp with time zone DEFAULT "now"(),
    "data_duplicacao" timestamp with time zone,
    "created_by" "uuid",
    "deleted_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounting_entry_tracking_tipo_check" CHECK ((("tipo")::"text" = ANY (ARRAY[('FOLD'::character varying)::"text", ('PAGTO_SAL'::character varying)::"text", ('RECOLH_INSS'::character varying)::"text", ('RECOLH_IRRF'::character varying)::"text"])))
);


ALTER TABLE "public"."accounting_entry_tracking" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_periods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "closed_at" timestamp with time zone,
    "closed_by" "uuid",
    "locked_at" timestamp with time zone,
    "locked_by" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounting_periods_month_check" CHECK ((("month" >= 1) AND ("month" <= 12))),
    CONSTRAINT "accounting_periods_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'closed'::"text", 'locked'::"text"])))
);


ALTER TABLE "public"."accounting_periods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_provisions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provision_type" "text" NOT NULL,
    "client_id" "uuid",
    "competence" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "journal_entry_id" "uuid",
    "status" "text" DEFAULT 'provisioned'::"text",
    "realization_date" "date",
    "realization_entry_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounting_provisions_provision_type_check" CHECK (("provision_type" = ANY (ARRAY['monthly_fee'::"text", 'thirteenth_fee'::"text", 'vacation'::"text", 'tax'::"text", 'other'::"text"]))),
    CONSTRAINT "accounting_provisions_status_check" CHECK (("status" = ANY (ARRAY['provisioned'::"text", 'realized'::"text", 'reversed'::"text"])))
);


ALTER TABLE "public"."accounting_provisions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounts_payable" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_name" "text" NOT NULL,
    "supplier_document" "text",
    "description" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "due_date" "date" NOT NULL,
    "payment_date" "date",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "category" "text" NOT NULL,
    "payment_method" "text",
    "bank_account" "text",
    "document_number" "text",
    "notes" "text",
    "ai_analysis" "jsonb",
    "ai_fraud_score" numeric,
    "ai_fraud_reasons" "text"[],
    "ai_recommendations" "text"[],
    "approval_status" "text" DEFAULT 'pending_review'::"text",
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_recurring" boolean DEFAULT false,
    "recurrence_frequency" "text" DEFAULT 'monthly'::"text",
    "recurrence_day" integer,
    "parent_expense_id" "uuid",
    "is_suspended" boolean DEFAULT false,
    "suspended_reason" "text",
    "suspended_at" timestamp with time zone,
    "cost_center" "text",
    "nfse_tomada_id" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "accounts_payable_ai_fraud_score_check" CHECK ((("ai_fraud_score" >= (0)::numeric) AND ("ai_fraud_score" <= (100)::numeric))),
    CONSTRAINT "accounts_payable_amount_check" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "accounts_payable_approval_status_check" CHECK (("approval_status" = ANY (ARRAY['pending_review'::"text", 'approved'::"text", 'rejected'::"text", 'flagged'::"text"]))),
    CONSTRAINT "accounts_payable_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'paid'::"text", 'rejected'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."accounts_payable" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."agent_commissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "uuid" NOT NULL,
    "client_id" "uuid",
    "source_type" character varying(50) NOT NULL,
    "source_id" "uuid",
    "source_description" "text",
    "client_payment_amount" numeric(15,2) NOT NULL,
    "agent_percentage" numeric(5,2) NOT NULL,
    "commission_amount" numeric(15,2) NOT NULL,
    "competence" character varying(7),
    "payment_date" "date",
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "paid_date" "date",
    "paid_amount" numeric(15,2),
    "payment_method" character varying(50),
    "payment_reference" character varying(200),
    "accounting_entry_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."agent_commissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_agents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" DEFAULT 'specialist'::"text",
    "description" "text",
    "model" "text" DEFAULT 'gemini-2.5-flash'::"text",
    "prompt_template" "text" DEFAULT ''::"text",
    "configuration" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "execution_count" integer DEFAULT 0,
    "avg_execution_time_ms" integer,
    "last_execution_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "agent_id" "text",
    "role" "text",
    "specialty" "text",
    "knowledge_sources" "text"[],
    "system_prompt" "text",
    "icon" "text",
    "color" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_agents" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_agents" IS 'Agentes IA especializados do sistema - Dr. Advocato para quest├Áes trabalhistas e Sr. Empres├írio para estrutura├º├úo';



CREATE TABLE IF NOT EXISTS "public"."ai_automation_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "automation_type" "text" NOT NULL,
    "entity_type" "text",
    "entity_id" "uuid",
    "client_id" "uuid",
    "status" "text" NOT NULL,
    "message" "text",
    "details" "jsonb" DEFAULT '{}'::"jsonb",
    "ai_model" "text",
    "ai_tokens_used" integer,
    "ai_response_time_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "ai_automation_logs_automation_type_check" CHECK (("automation_type" = ANY (ARRAY['recurring_expense'::"text", 'invoice_generation'::"text", 'contract_generation'::"text", 'distract_generation'::"text", 'installment_creation'::"text", 'status_check'::"text"]))),
    CONSTRAINT "ai_automation_logs_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'failed'::"text", 'skipped'::"text", 'pending_review'::"text"])))
);


ALTER TABLE "public"."ai_automation_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_classification_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_transaction_id" "uuid",
    "original_description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "transaction_type" "text" NOT NULL,
    "transaction_date" "date" NOT NULL,
    "ai_category" "text",
    "ai_debit_account" "text",
    "ai_credit_account" "text",
    "ai_confidence" numeric(3,2),
    "ai_reasoning" "text",
    "final_category" "text" NOT NULL,
    "final_debit_account" "text" NOT NULL,
    "final_credit_account" "text" NOT NULL,
    "entity_id" "uuid",
    "entity_relationship" "text",
    "was_corrected" boolean DEFAULT false,
    "human_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_classification_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_classification_history" IS 'Hist├│rico de todas as classifica├º├Áes para treinamento da IA';



CREATE TABLE IF NOT EXISTS "public"."ai_classification_patterns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transaction_pattern" "text" NOT NULL,
    "pattern_type" "text" NOT NULL,
    "category" "text" NOT NULL,
    "subcategory" "text",
    "debit_account_code" "text" NOT NULL,
    "credit_account_code" "text" NOT NULL,
    "entity_id" "uuid",
    "transaction_type" "text",
    "min_amount" numeric(15,2),
    "max_amount" numeric(15,2),
    "confidence" numeric(3,2) DEFAULT 1.0,
    "source" "text" DEFAULT 'human'::"text",
    "priority" integer DEFAULT 100,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "last_used_at" timestamp with time zone DEFAULT "now"(),
    "usage_count" integer DEFAULT 0,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "ai_classification_patterns_pattern_type_check" CHECK (("pattern_type" = ANY (ARRAY['literal'::"text", 'regex'::"text", 'contains'::"text"]))),
    CONSTRAINT "ai_classification_patterns_source_check" CHECK (("source" = ANY (ARRAY['human'::"text", 'ai_confirmed'::"text", 'ai_suggested'::"text"]))),
    CONSTRAINT "ai_classification_patterns_transaction_type_check" CHECK (("transaction_type" = ANY (ARRAY['CREDIT'::"text", 'DEBIT'::"text", 'ANY'::"text"])))
);


ALTER TABLE "public"."ai_classification_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_classification_patterns" IS 'Padr├Áes de classifica├º├úo aprendidos da intera├º├úo humano-IA';



CREATE TABLE IF NOT EXISTS "public"."ai_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "agent_id" "uuid",
    "client_id" "uuid",
    "input_data" "jsonb",
    "output_data" "jsonb",
    "status" "text" DEFAULT 'running'::"text" NOT NULL,
    "execution_time_ms" integer,
    "tokens_used" integer,
    "cost" numeric(10,4),
    "error_message" "text",
    "executed_by" "uuid",
    "executed_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_executions" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_executions" IS 'Hist├│rico de execu├º├Áes de agentes IA';



CREATE TABLE IF NOT EXISTS "public"."ai_known_entities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name_pattern" "text" NOT NULL,
    "normalized_pattern" "text" NOT NULL,
    "entity_type" "text" NOT NULL,
    "display_name" "text" NOT NULL,
    "document" "text",
    "relationship" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "last_used_at" timestamp with time zone DEFAULT "now"(),
    "usage_count" integer DEFAULT 1,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "ai_known_entities_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['person'::"text", 'company'::"text", 'supplier'::"text", 'partner'::"text", 'employee'::"text", 'client'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."ai_known_entities" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_known_entities" IS 'Entidades conhecidas (pessoas, empresas) para classifica├º├úo autom├ítica';



CREATE TABLE IF NOT EXISTS "public"."ai_labor_consultations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "person_type" "text",
    "person_id" "uuid",
    "person_name" "text",
    "risk_identified" "text",
    "risk_severity" "text",
    "solutions_suggested" "text"[],
    "ai_recommendation" "text",
    "jurisprudence_cited" "text"[],
    "user_decision" "text",
    "implementation_status" "text" DEFAULT 'pending'::"text",
    "consultation_date" timestamp with time zone DEFAULT "now"(),
    "decision_date" timestamp with time zone,
    "created_by" "uuid",
    "notes" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_labor_consultations" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_labor_consultations" IS 'Hist├│rico de consultas e recomenda├º├Áes da IA para cada pessoa';



CREATE TABLE IF NOT EXISTS "public"."ai_learned_patterns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description_pattern" "text" NOT NULL,
    "entry_type" "text" NOT NULL,
    "debit_account" "text" NOT NULL,
    "debit_account_name" "text",
    "credit_account" "text" NOT NULL,
    "credit_account_name" "text",
    "entry_description" "text",
    "confidence" numeric(3,2) DEFAULT 0.9,
    "usage_count" integer DEFAULT 1,
    "last_used_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_learned_patterns" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_learned_patterns" IS 'Padr├Áes aprendidos pelo Dr. C├¡cero (Contador IA) para classifica├º├úo autom├ítica de transa├º├Áes';



CREATE TABLE IF NOT EXISTS "public"."ai_meetings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "scheduled_date" timestamp with time zone NOT NULL,
    "duration_minutes" integer DEFAULT 60,
    "participants" "jsonb" DEFAULT '[]'::"jsonb",
    "ai_facilitator" "text" DEFAULT 'helena'::"text",
    "ai_participants" "text"[] DEFAULT ARRAY['milton'::"text", 'cicero'::"text", 'advocato'::"text", 'empresario'::"text"],
    "agenda" "jsonb" DEFAULT '[]'::"jsonb",
    "ai_generated_topics" "jsonb",
    "status" "text" DEFAULT 'scheduled'::"text",
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "decisions" "jsonb" DEFAULT '[]'::"jsonb",
    "action_items" "jsonb" DEFAULT '[]'::"jsonb",
    "notes" "text",
    "ai_summary" "text",
    "presentation_id" "uuid",
    "presentation_url" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_meetings" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_meetings" IS 'Reuni├Áes peri├│dicas com IA facilitando';



CREATE TABLE IF NOT EXISTS "public"."ai_page_agents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "page_path" "text" NOT NULL,
    "page_name" "text" NOT NULL,
    "primary_agent_id" "text" NOT NULL,
    "secondary_agents" "text"[],
    "agent_role" "text" NOT NULL,
    "auto_actions" "text"[],
    "requires_approval" boolean DEFAULT false,
    "approval_threshold" numeric(15,2),
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_page_agents" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_page_agents" IS 'Mapeamento de qual agente IA ├® respons├ível por cada tela - NADA SEM AGENTE';



CREATE TABLE IF NOT EXISTS "public"."ai_pending_questions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_transaction_id" "uuid",
    "import_id" "uuid",
    "description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "transaction_type" "text" NOT NULL,
    "transaction_date" "date" NOT NULL,
    "question_type" "text" NOT NULL,
    "question_text" "text" NOT NULL,
    "ai_suggestion" "text",
    "ai_confidence" numeric(3,2),
    "options" "jsonb",
    "status" "text" DEFAULT 'pending'::"text",
    "answer" "text",
    "answer_details" "jsonb",
    "answered_by" "uuid",
    "answered_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "priority" integer DEFAULT 50,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "ai_pending_questions_question_type_check" CHECK (("question_type" = ANY (ARRAY['who_is'::"text", 'what_is'::"text", 'category'::"text", 'account'::"text", 'confirm'::"text"]))),
    CONSTRAINT "ai_pending_questions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'answered'::"text", 'skipped'::"text"])))
);


ALTER TABLE "public"."ai_pending_questions" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_pending_questions" IS 'Perguntas da IA aguardando resposta do humano';



CREATE TABLE IF NOT EXISTS "public"."ai_presentations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "title" "text" NOT NULL,
    "presentation_type" "text" NOT NULL,
    "purpose" "text",
    "slides" "jsonb" DEFAULT '[]'::"jsonb",
    "data_sources" "jsonb",
    "charts" "jsonb",
    "highlights" "jsonb",
    "display_mode" "text" DEFAULT 'fullscreen'::"text",
    "auto_advance" boolean DEFAULT true,
    "slide_duration_seconds" integer DEFAULT 30,
    "background_music" boolean DEFAULT false,
    "status" "text" DEFAULT 'draft'::"text",
    "generated_by" "text" NOT NULL,
    "generated_at" timestamp with time zone DEFAULT "now"(),
    "file_url" "text",
    "file_format" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."ai_presentations" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_presentations" IS 'Apresenta├º├Áes/slides gerados pela IA para reuni├Áes';



CREATE TABLE IF NOT EXISTS "public"."ai_providers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider_code" "text" NOT NULL,
    "provider_name" "text" NOT NULL,
    "description" "text",
    "api_endpoint" "text",
    "api_key_secret_name" "text",
    "model_default" "text",
    "models_available" "text"[],
    "can_generate_text" boolean DEFAULT true,
    "can_generate_images" boolean DEFAULT false,
    "can_generate_video" boolean DEFAULT false,
    "can_generate_audio" boolean DEFAULT false,
    "cost_per_1k_tokens" numeric(10,4),
    "cost_per_image" numeric(10,4),
    "cost_per_minute_video" numeric(10,4),
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ai_providers" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_providers" IS 'Provedores de IA dispon├¡veis (OpenAI, Claude, Gemini, etc)';



CREATE TABLE IF NOT EXISTS "public"."ai_validation_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_id" "uuid" NOT NULL,
    "priority" integer DEFAULT 5,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "attempts" integer DEFAULT 0,
    "max_attempts" integer DEFAULT 3,
    "last_error" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "ai_validation_queue_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 10))),
    CONSTRAINT "ai_validation_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text", 'retry'::"text"])))
);


ALTER TABLE "public"."ai_validation_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_validation_queue" IS 'Fila de lan├ºamentos aguardando valida├º├úo pela IA';



CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "action" "text" NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "uuid",
    "old_values" "jsonb",
    "new_values" "jsonb",
    "ip_address" "inet",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "audit_type" "text",
    "severity" "text" DEFAULT 'info'::"text",
    "entity_type" "text",
    "entity_id" "uuid",
    "title" "text",
    "description" "text",
    "metadata" "jsonb",
    "resolved" boolean DEFAULT false NOT NULL,
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    "resolution_notes" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."audit_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."audit_logs" IS 'Registro de auditoria para eventos importantes do sistema';



COMMENT ON COLUMN "public"."audit_logs"."audit_type" IS 'Tipo de auditoria: boleto_baixado, payment_mismatch, etc';



COMMENT ON COLUMN "public"."audit_logs"."severity" IS 'Severidade: info, warning, error, critical';



COMMENT ON COLUMN "public"."audit_logs"."entity_type" IS 'Tipo de entidade: invoice, expense, client, etc';



COMMENT ON COLUMN "public"."audit_logs"."resolved" IS 'Se o alerta foi resolvido ou n├úo';



CREATE TABLE IF NOT EXISTS "public"."auditoria_achados" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid",
    "execucao_id" "uuid",
    "codigo_verificacao" character varying(50) NOT NULL,
    "tipo_achado" character varying(50) NOT NULL,
    "nivel_risco" character varying(20) DEFAULT 'MEDIO'::character varying,
    "titulo" character varying(255) NOT NULL,
    "descricao" "text",
    "valor_divergencia" numeric(15,2),
    "periodo_referencia" character varying(20),
    "dados_comparacao" "jsonb" DEFAULT '{}'::"jsonb",
    "status" character varying(30) DEFAULT 'PENDENTE'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."auditoria_achados" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."auditoria_execucoes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tipo" character varying(50) DEFAULT 'COMPLETA'::character varying,
    "status" character varying(30) DEFAULT 'PENDENTE'::character varying,
    "total_empresas" integer DEFAULT 0,
    "empresas_processadas" integer DEFAULT 0,
    "achados_encontrados" integer DEFAULT 0,
    "iniciado_em" timestamp with time zone,
    "finalizado_em" timestamp with time zone,
    "parametros" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."auditoria_execucoes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."automation_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tasks_executed" integer,
    "tasks_succeeded" integer,
    "tasks_failed" integer,
    "details" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."automation_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."balance_sheet_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "balance_sheet_id" "uuid" NOT NULL,
    "account_id" "uuid",
    "account_code" "text" NOT NULL,
    "account_name" "text" NOT NULL,
    "account_type" "text" NOT NULL,
    "group_type" "text" NOT NULL,
    "balance" numeric(15,2) DEFAULT 0 NOT NULL,
    "display_order" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "balance_sheet_lines_group_type_check" CHECK (("group_type" = ANY (ARRAY['current_asset'::"text", 'non_current_asset'::"text", 'current_liability'::"text", 'non_current_liability'::"text", 'equity'::"text"])))
);


ALTER TABLE "public"."balance_sheet_lines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."balance_sheets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reference_date" "date" NOT NULL,
    "fiscal_year" integer NOT NULL,
    "total_current_assets" numeric(15,2) DEFAULT 0,
    "total_non_current_assets" numeric(15,2) DEFAULT 0,
    "total_assets" numeric(15,2) GENERATED ALWAYS AS (("total_current_assets" + "total_non_current_assets")) STORED,
    "total_current_liabilities" numeric(15,2) DEFAULT 0,
    "total_non_current_liabilities" numeric(15,2) DEFAULT 0,
    "total_liabilities" numeric(15,2) GENERATED ALWAYS AS (("total_current_liabilities" + "total_non_current_liabilities")) STORED,
    "share_capital" numeric(15,2) DEFAULT 0,
    "capital_reserves" numeric(15,2) DEFAULT 0,
    "profit_reserves" numeric(15,2) DEFAULT 0,
    "accumulated_profits" numeric(15,2) DEFAULT 0,
    "accumulated_losses" numeric(15,2) DEFAULT 0,
    "current_year_result" numeric(15,2) DEFAULT 0,
    "total_equity" numeric(15,2) GENERATED ALWAYS AS (((((("share_capital" + "capital_reserves") + "profit_reserves") + "accumulated_profits") - "accumulated_losses") + "current_year_result")) STORED,
    "is_balanced" boolean GENERATED ALWAYS AS (("abs"((("total_current_assets" + "total_non_current_assets") - ((((((("total_current_liabilities" + "total_non_current_liabilities") + "share_capital") + "capital_reserves") + "profit_reserves") + "accumulated_profits") - "accumulated_losses") + "current_year_result"))) < 0.01)) STORED,
    "status" "text" DEFAULT 'draft'::"text",
    "ai_generated" boolean DEFAULT false,
    "fiscal_year_closing_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "balance_sheets_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'reviewed'::"text", 'approved'::"text", 'published'::"text"])))
);


ALTER TABLE "public"."balance_sheets" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bank_accounts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_code" "text" NOT NULL,
    "bank_name" "text" NOT NULL,
    "agency" "text",
    "account_number" "text" NOT NULL,
    "account_digit" "text",
    "account_type" "text" DEFAULT 'checking'::"text",
    "is_active" boolean DEFAULT true,
    "balance" numeric(15,2) DEFAULT 0,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "pluggy_item_id" "text",
    "pluggy_account_id" "text",
    "cora_account_id" "text",
    "sync_enabled" boolean DEFAULT true,
    "last_sync_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_by" "uuid",
    "name" "text",
    "current_balance" numeric(15,2) DEFAULT 0,
    "initial_balance" numeric(15,2) DEFAULT 0,
    "initial_balance_date" "date",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."bank_accounts" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_accounts" IS 'Bank accounts for the accounting firm';



COMMENT ON COLUMN "public"."bank_accounts"."initial_balance" IS 'Saldo inicial/abertura da conta';



COMMENT ON COLUMN "public"."bank_accounts"."initial_balance_date" IS 'Data do saldo inicial';



CREATE TABLE IF NOT EXISTS "public"."bank_balance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "account_name" "text" NOT NULL,
    "account_number" "text",
    "bank_name" "text",
    "balance" numeric DEFAULT 0 NOT NULL,
    "balance_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "account_type" "text" DEFAULT 'checking'::"text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "notes" "text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "bank_balance_account_type_check" CHECK (("account_type" = ANY (ARRAY['checking'::"text", 'savings'::"text", 'investment'::"text"])))
);


ALTER TABLE "public"."bank_balance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bank_imports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_account_id" "uuid" NOT NULL,
    "file_name" "text" NOT NULL,
    "import_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "period_start" "date",
    "period_end" "date",
    "total_transactions" integer DEFAULT 0,
    "status" "text" DEFAULT 'pending'::"text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "duplicated_transactions" integer DEFAULT 0,
    "new_transactions" integer DEFAULT 0,
    "total_debits" numeric(10,2) DEFAULT 0 NOT NULL,
    "total_credits" numeric(10,2) DEFAULT 0 NOT NULL,
    "error_message" "text",
    "file_size" integer,
    "start_date" "date",
    "end_date" "date",
    "opening_balance" numeric,
    "closing_balance" numeric,
    "statement_hash" "text",
    "statement_key" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."bank_imports" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_imports" IS 'Hist├│rico de importa├º├Áes banc├írias - Importa├º├Áes travadas limpas em 31/12/2024';



COMMENT ON COLUMN "public"."bank_imports"."duplicated_transactions" IS 'N├║mero de transa├º├Áes que j├í existiam';



COMMENT ON COLUMN "public"."bank_imports"."new_transactions" IS 'N├║mero de transa├º├Áes novas importadas';



COMMENT ON COLUMN "public"."bank_imports"."total_debits" IS 'Total de d├®bitos importados';



COMMENT ON COLUMN "public"."bank_imports"."total_credits" IS 'Total de cr├®ditos importados';



COMMENT ON COLUMN "public"."bank_imports"."error_message" IS 'Mensagem de erro durante importa├º├úo';



CREATE TABLE IF NOT EXISTS "public"."bank_opening_balances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_account_id" "uuid" NOT NULL,
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "opening_balance" numeric(15,2) DEFAULT 0 NOT NULL,
    "closing_balance" numeric(15,2),
    "source_closing_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "bank_opening_balances_month_check" CHECK ((("month" >= 1) AND ("month" <= 12)))
);


ALTER TABLE "public"."bank_opening_balances" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_opening_balances" IS 'Saldos de abertura de contas banc├írias por per├¡odo';



CREATE TABLE IF NOT EXISTS "public"."bank_reconciliation" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transaction_id" "uuid" NOT NULL,
    "invoice_id" "uuid",
    "boleto_item_id" "uuid",
    "accounting_entry_id" "uuid",
    "reconciliation_date" timestamp with time zone DEFAULT "now"(),
    "reconciliation_method" character varying(50),
    "confidence_score" numeric(5,2),
    "match_criteria" "jsonb",
    "notes" "text",
    "reconciled_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."bank_reconciliation" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_reconciliation" IS 'Hist├│rico de concilia├º├Áes banc├írias autom├íticas e manuais';



CREATE TABLE IF NOT EXISTS "public"."bank_statement_imports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_account_id" "uuid" NOT NULL,
    "file_name" "text" NOT NULL,
    "file_hash" "text" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "opening_balance" numeric(15,2) NOT NULL,
    "closing_balance" numeric(15,2) NOT NULL,
    "transaction_count" integer NOT NULL,
    "total_credits" numeric(15,2) DEFAULT 0,
    "total_debits" numeric(15,2) DEFAULT 0,
    "imported_at" timestamp with time zone DEFAULT "now"(),
    "is_locked" boolean DEFAULT true NOT NULL,
    "notes" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."bank_statement_imports" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_statement_imports" IS 'Registro de importa├º├Áes de extratos OFX com SALDOS REAIS';



COMMENT ON COLUMN "public"."bank_statement_imports"."opening_balance" IS 'Saldo de abertura REAL do extrato OFX';



COMMENT ON COLUMN "public"."bank_statement_imports"."closing_balance" IS 'Saldo de fechamento REAL do extrato OFX (LEDGERBAL)';



CREATE TABLE IF NOT EXISTS "public"."bank_transaction_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_transaction_id" "uuid" NOT NULL,
    "invoice_id" "uuid",
    "expense_id" "uuid",
    "client_id" "uuid",
    "amount" numeric NOT NULL,
    "description" "text",
    "confidence" numeric,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."bank_transaction_matches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bank_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_account_id" "uuid",
    "transaction_date" "date" NOT NULL,
    "description" "text",
    "amount" numeric(15,2) NOT NULL,
    "type" character varying(20),
    "balance_after" numeric(15,2),
    "document_number" "text",
    "reconciled" boolean DEFAULT false,
    "invoice_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "matched" boolean DEFAULT false,
    "has_multiple_matches" boolean DEFAULT false NOT NULL,
    "fitid" "text",
    "is_reconciled" boolean DEFAULT false,
    "journal_entry_id" "uuid",
    "cost_center_id" "uuid",
    "category" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "expense_id" "uuid",
    "accounts_payable_id" "uuid",
    "transaction_type" "text",
    "bank_reference" "text",
    "imported_from" "text",
    "ai_suggestion" "text",
    "is_opening_balance" boolean DEFAULT false,
    "opening_balance_note" "text",
    "internal_code" character varying(100),
    "chart_account_id" "uuid",
    "is_locked" boolean DEFAULT false,
    "import_id" "uuid",
    "original_amount" numeric(15,2),
    "original_description" "text",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "bank_transactions_transaction_type_check" CHECK (("transaction_type" = ANY (ARRAY['debit'::"text", 'credit'::"text"])))
);


ALTER TABLE "public"."bank_transactions" OWNER TO "postgres";


COMMENT ON TABLE "public"."bank_transactions" IS 'Transa├º├Áes banc├írias - Tabela legada. O novo fluxo importa direto para accounting_entries. Limpa em 31/12/2024.';



COMMENT ON COLUMN "public"."bank_transactions"."invoice_id" IS 'Refer├¬ncia ao honor├írio/fatura conciliado';



COMMENT ON COLUMN "public"."bank_transactions"."fitid" IS 'ID ├║nico da transa├º├úo no banco (para evitar duplicatas)';



COMMENT ON COLUMN "public"."bank_transactions"."is_reconciled" IS 'Indica se a transa├º├úo foi conciliada com lan├ºamentos cont├íbeis';



COMMENT ON COLUMN "public"."bank_transactions"."expense_id" IS 'Refer├¬ncia ├á despesa conciliada';



COMMENT ON COLUMN "public"."bank_transactions"."accounts_payable_id" IS 'Refer├¬ncia ├á conta a pagar conciliada';



COMMENT ON COLUMN "public"."bank_transactions"."is_opening_balance" IS 'Indica se a transa├º├úo faz parte do saldo de abertura (compet├¬ncia anterior)';



COMMENT ON COLUMN "public"."bank_transactions"."opening_balance_note" IS 'Nota explicativa sobre a origem da transa├º├úo de saldo de abertura';



COMMENT ON COLUMN "public"."bank_transactions"."internal_code" IS 'Identificador interno ├║nico do extrato (bank_tx:YYYYMMDD:hash8).';



CREATE TABLE IF NOT EXISTS "public"."banking_credentials" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_name" "text" NOT NULL,
    "integration_type" "text" NOT NULL,
    "client_id" "text",
    "client_secret_encrypted" "text",
    "access_token_encrypted" "text",
    "refresh_token_encrypted" "text",
    "expires_at" timestamp with time zone,
    "certificate_path" "text",
    "webhook_secret" "text",
    "is_active" boolean DEFAULT true,
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."banking_credentials" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."barter_credits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "amount" numeric(10,2) NOT NULL,
    "description" "text" NOT NULL,
    "reference_date" "date" NOT NULL,
    "competence" "text",
    "balance_before" numeric(10,2) DEFAULT 0 NOT NULL,
    "balance_after" numeric(10,2) DEFAULT 0 NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "barter_credits_type_check" CHECK (("type" = ANY (ARRAY['credit'::"text", 'debit'::"text"])))
);


ALTER TABLE "public"."barter_credits" OWNER TO "postgres";


COMMENT ON TABLE "public"."barter_credits" IS 'Movimenta├º├Áes de cr├®ditos de permuta dos clientes';



COMMENT ON COLUMN "public"."barter_credits"."type" IS 'Tipo de movimenta├º├úo: credit (cr├®dito mensal) ou debit (consumo de servi├ºos)';



COMMENT ON COLUMN "public"."barter_credits"."amount" IS 'Valor da movimenta├º├úo';



COMMENT ON COLUMN "public"."barter_credits"."description" IS 'Descri├º├úo da movimenta├º├úo';



COMMENT ON COLUMN "public"."barter_credits"."reference_date" IS 'Data de refer├¬ncia da movimenta├º├úo';



COMMENT ON COLUMN "public"."barter_credits"."competence" IS 'Compet├¬ncia da movimenta├º├úo (MM/YYYY)';



COMMENT ON COLUMN "public"."barter_credits"."balance_before" IS 'Saldo antes da movimenta├º├úo';



COMMENT ON COLUMN "public"."barter_credits"."balance_after" IS 'Saldo ap├│s a movimenta├º├úo';



CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_accounting_entries" (
    "id" "uuid",
    "entry_number" integer,
    "entry_date" "date",
    "competence_date" "date",
    "description" "text",
    "history" "text",
    "entry_type" character varying(50),
    "document_type" character varying(50),
    "document_number" character varying(100),
    "invoice_id" "uuid",
    "transaction_id" "uuid",
    "total_debit" numeric(15,2),
    "total_credit" numeric(15,2),
    "is_draft" boolean,
    "created_by" "uuid",
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "reference_type" "text",
    "reference_id" "uuid",
    "balanced" boolean,
    "notes" "text",
    "ai_validated" boolean,
    "ai_validated_at" timestamp with time zone,
    "ai_validation_result" "text",
    "ai_validation_message" "text",
    "ai_confidence" numeric(3,2),
    "ai_generated" boolean,
    "ai_model" "text",
    "cost_center_id" "uuid",
    "internal_code" character varying(100),
    "source_type" character varying(50),
    "source_id" "uuid",
    "source_hash" character varying(64)
);


ALTER TABLE "public"."bkp_20260106_accounting_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_accounting_entry_items" (
    "id" "uuid",
    "entry_id" "uuid",
    "account_id" "uuid",
    "debit" numeric(15,2),
    "credit" numeric(15,2),
    "history" "text",
    "client_id" "uuid",
    "cost_center" character varying(100),
    "created_at" timestamp with time zone
);


ALTER TABLE "public"."bkp_20260106_accounting_entry_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_bank_transactions" (
    "id" "uuid",
    "bank_account_id" "uuid",
    "transaction_date" "date",
    "description" "text",
    "amount" numeric(15,2),
    "type" character varying(20),
    "balance_after" numeric(15,2),
    "document_number" "text",
    "reconciled" boolean,
    "invoice_id" "uuid",
    "created_at" timestamp with time zone,
    "created_by" "uuid",
    "matched" boolean,
    "has_multiple_matches" boolean,
    "fitid" "text",
    "is_reconciled" boolean,
    "journal_entry_id" "uuid",
    "cost_center_id" "uuid",
    "category" "text",
    "status" "text",
    "expense_id" "uuid",
    "accounts_payable_id" "uuid",
    "transaction_type" "text",
    "bank_reference" "text",
    "imported_from" "text",
    "ai_suggestion" "text",
    "is_opening_balance" boolean,
    "opening_balance_note" "text",
    "internal_code" character varying(100)
);


ALTER TABLE "public"."bkp_20260106_bank_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_chart_of_accounts" (
    "id" "uuid",
    "code" character varying(20),
    "name" character varying(200),
    "account_type" character varying(50),
    "nature" character varying(10),
    "parent_id" "uuid",
    "level" integer,
    "is_analytical" boolean,
    "is_active" boolean,
    "description" "text",
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "created_by" "uuid",
    "type" "text",
    "is_synthetic" boolean,
    "accepts_entries" boolean,
    "is_result_account" boolean
);


ALTER TABLE "public"."bkp_20260106_chart_of_accounts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_clients" (
    "id" "uuid",
    "name" "text",
    "cnpj" "text",
    "email" "text",
    "phone" "text",
    "monthly_fee" numeric(15,2),
    "fee_due_day" integer,
    "is_active" boolean,
    "opening_balance" numeric(15,2),
    "opening_balance_details" "jsonb",
    "opening_balance_date" "date",
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "is_pro_bono" boolean,
    "pro_bono_start_date" "date",
    "pro_bono_end_date" "date",
    "pro_bono_reason" "text",
    "cpf" character varying(14),
    "qsa" "jsonb",
    "status" "text",
    "opcao_pelo_simples" boolean,
    "data_opcao_simples" "date",
    "opcao_pelo_mei" boolean,
    "motivo_situacao_cadastral" "text",
    "data_situacao_cadastral" "date",
    "telefone_secundario" character varying(20),
    "fax" character varying(20),
    "created_by" "uuid",
    "razao_social" "text",
    "nome_fantasia" "text",
    "porte" "text",
    "natureza_juridica" "text",
    "situacao_cadastral" "text",
    "data_abertura" "date",
    "capital_social" numeric,
    "logradouro" "text",
    "numero" "text",
    "complemento" "text",
    "bairro" "text",
    "municipio" "text",
    "uf" "text",
    "cep" "text",
    "atividade_principal" "jsonb",
    "atividades_secundarias" "jsonb",
    "is_barter" boolean,
    "barter_monthly_credit" numeric(10,2),
    "barter_description" "text",
    "barter_start_date" "date",
    "is_internal" boolean,
    "notes" "text",
    "payment_day" integer,
    "fee_in_minimum_wages" numeric(10,4),
    "last_fee_adjustment_date" "date",
    "last_adjustment_minimum_wage" numeric(10,2),
    "auto_adjust_by_minimum_wage" boolean,
    "has_13th_fee" boolean,
    "thirteenth_fee_day" integer,
    "thirteenth_fee_amount" numeric(10,2),
    "regime_tributario" character varying(20)
);


ALTER TABLE "public"."bkp_20260106_clients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_invoices" (
    "id" "uuid",
    "client_id" "uuid",
    "competence" character varying(7),
    "amount" numeric(15,2),
    "due_date" "date",
    "status" character varying(20),
    "paid_date" "date",
    "paid_amount" numeric(15,2),
    "boleto_digitable_line" "text",
    "external_charge_id" "text",
    "notes" "text",
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "boleto_url" "text",
    "boleto_barcode" "text",
    "pix_qrcode" "text",
    "pix_copy_paste" "text",
    "pix_txid" "text",
    "payment_method" "text",
    "payment_link" "text",
    "created_by" "uuid",
    "revenue_type_id" "uuid",
    "calculation_base" numeric,
    "calculated_amount" numeric,
    "fine_amount" numeric(10,2),
    "interest_amount" numeric(10,2),
    "total_received" numeric(10,2),
    "discount_amount" numeric(10,2),
    "journal_entry_id" "uuid",
    "cnab_reference" "text",
    "reconciled_at" timestamp with time zone
);


ALTER TABLE "public"."bkp_20260106_invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bkp_20260106_suppliers" (
    "id" "uuid",
    "name" "text",
    "trading_name" "text",
    "cnpj" "text",
    "phone" "text",
    "email" "text",
    "contact_person" "text",
    "address" "text",
    "city" "text",
    "categories" "text"[],
    "rating" integer,
    "notes" "text",
    "is_active" boolean,
    "created_at" timestamp with time zone
);


ALTER TABLE "public"."bkp_20260106_suppliers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."boleto_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_transaction_id" "uuid",
    "client_id" "uuid",
    "invoice_id" "uuid",
    "cob" character varying(20),
    "nosso_numero" character varying(50),
    "data_vencimento" "date",
    "data_liquidacao" "date",
    "data_extrato" "date",
    "valor_original" numeric(15,2),
    "valor_liquidado" numeric(15,2),
    "juros" numeric(15,2) DEFAULT 0,
    "multa" numeric(15,2) DEFAULT 0,
    "desconto" numeric(15,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."boleto_payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."boleto_report_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "report_id" "uuid" NOT NULL,
    "client_id" "uuid",
    "client_name" character varying(255),
    "invoice_id" "uuid",
    "boleto_number" character varying(100),
    "emission_date" "date",
    "due_date" "date",
    "payment_date" "date",
    "competence" character varying(20),
    "amount" numeric(15,2) NOT NULL,
    "status" character varying(50),
    "payment_method" character varying(50),
    "accounting_entry_id" "uuid",
    "is_provisioned" boolean DEFAULT false,
    "is_settled" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."boleto_report_items" OWNER TO "postgres";


COMMENT ON TABLE "public"."boleto_report_items" IS 'Detalhamento de cada boleto no relat├│rio importado';



CREATE TABLE IF NOT EXISTS "public"."boleto_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "file_name" character varying(255) NOT NULL,
    "file_type" character varying(50),
    "upload_date" timestamp with time zone DEFAULT "now"(),
    "period_start" "date",
    "period_end" "date",
    "total_boletos" integer DEFAULT 0,
    "total_emitidos" numeric(15,2) DEFAULT 0,
    "total_pagos" numeric(15,2) DEFAULT 0,
    "total_pendentes" numeric(15,2) DEFAULT 0,
    "status" character varying(50) DEFAULT 'PENDING'::character varying,
    "processing_log" "jsonb",
    "entries_created" integer DEFAULT 0,
    "uploaded_by" "uuid",
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."boleto_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."boleto_reports" IS 'Relat├│rios de boletos importados para processamento autom├ítico';



CREATE TABLE IF NOT EXISTS "public"."business_maturity_analysis" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "analysis_period" "text" NOT NULL,
    "analysis_date" "date" DEFAULT CURRENT_DATE,
    "analyzed_by" "text"[] DEFAULT ARRAY['cicero'::"text", 'milton'::"text", 'helena'::"text"],
    "has_updated_balancete" boolean DEFAULT false,
    "balancete_date" "date",
    "total_assets" numeric(15,2),
    "total_liabilities" numeric(15,2),
    "equity" numeric(15,2),
    "current_ratio" numeric(5,2),
    "debt_ratio" numeric(5,2),
    "revenue_ytd" numeric(15,2),
    "expenses_ytd" numeric(15,2),
    "profit_ytd" numeric(15,2),
    "profit_margin" numeric(5,2),
    "is_profitable" boolean DEFAULT false,
    "months_profitable" integer DEFAULT 0,
    "cash_balance" numeric(15,2),
    "average_monthly_revenue" numeric(15,2),
    "average_monthly_expenses" numeric(15,2),
    "runway_months" numeric(5,2),
    "has_cash_flow_issues" boolean DEFAULT false,
    "chart_of_accounts_complete" boolean DEFAULT false,
    "opening_balance_done" boolean DEFAULT false,
    "reconciliation_updated" boolean DEFAULT false,
    "pending_entries" integer DEFAULT 0,
    "accounting_score" integer DEFAULT 0,
    "labor_risks_count" integer DEFAULT 0,
    "labor_risk_value" numeric(15,2) DEFAULT 0,
    "contracts_pending" integer DEFAULT 0,
    "tax_compliance_score" integer DEFAULT 0,
    "partners_registered" boolean DEFAULT false,
    "capital_structure_clear" boolean DEFAULT false,
    "succession_plan" boolean DEFAULT false,
    "maturity_score" integer,
    "maturity_level" "text",
    "cicero_diagnosis" "text",
    "milton_diagnosis" "text",
    "helena_diagnosis" "text",
    "advocato_diagnosis" "text",
    "empresario_diagnosis" "text",
    "recommendations" "jsonb" DEFAULT '[]'::"jsonb",
    "blockers" "jsonb" DEFAULT '[]'::"jsonb",
    "next_steps" "jsonb" DEFAULT '[]'::"jsonb",
    "can_implement_plr" boolean DEFAULT false,
    "can_implement_incentives" boolean DEFAULT false,
    "can_implement_referrals" boolean DEFAULT false,
    "can_attract_investors" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."business_maturity_analysis" OWNER TO "postgres";


COMMENT ON TABLE "public"."business_maturity_analysis" IS 'An├ílise de maturidade da empresa pelos agentes IA';



CREATE TABLE IF NOT EXISTS "public"."cash_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "entry_date" "date" NOT NULL,
    "entry_type" "text" NOT NULL,
    "category" "text",
    "cost_center_id" "uuid",
    "account_id" "uuid",
    "notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "cash_entries_entry_type_check" CHECK (("entry_type" = ANY (ARRAY['entrada'::"text", 'saida'::"text"])))
);


ALTER TABLE "public"."cash_entries" OWNER TO "postgres";


COMMENT ON TABLE "public"."cash_entries" IS 'Lan├ºamentos de caixa - movimenta├º├Áes em dinheiro/esp├®cie';



CREATE TABLE IF NOT EXISTS "public"."cash_flow_projections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "projection_date" "date" NOT NULL,
    "projection_type" "text" NOT NULL,
    "frequency" "text",
    "recurrence_end_date" "date",
    "category" "text",
    "notes" "text",
    "is_active" boolean DEFAULT true,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "cash_flow_projections_frequency_check" CHECK (("frequency" = ANY (ARRAY['once'::"text", 'daily'::"text", 'weekly'::"text", 'monthly'::"text", 'yearly'::"text"]))),
    CONSTRAINT "cash_flow_projections_projection_type_check" CHECK (("projection_type" = ANY (ARRAY['RECEITA'::"text", 'DESPESA_FOLHA'::"text", 'DESPESA_PJ'::"text", 'DESPESA_IMPOSTO'::"text", 'DESPESA_OUTROS'::"text", 'DESPESA_RECORRENTE'::"text"])))
);

ALTER TABLE ONLY "public"."cash_flow_projections" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."cash_flow_projections" OWNER TO "postgres";


COMMENT ON TABLE "public"."cash_flow_projections" IS 'Tabela unificada de proje├º├Áes - substitui recurring_expenses com mais funcionalidades';



COMMENT ON COLUMN "public"."cash_flow_projections"."projection_type" IS 'Tipo: RECEITA, DESPESA_FOLHA, DESPESA_PJ, DESPESA_IMPOSTO, DESPESA_OUTROS, DESPESA_RECORRENTE';



COMMENT ON COLUMN "public"."cash_flow_projections"."frequency" IS 'Frequ├¬ncia da proje├º├úo: once, daily, weekly, monthly, yearly';



COMMENT ON COLUMN "public"."cash_flow_projections"."tenant_id" IS 'Identificador do tenant (organiza├º├úo) - isolamento multi-tenant';



CREATE TABLE IF NOT EXISTS "public"."cash_flow_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transaction_type" "text" NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "transaction_date" "date" NOT NULL,
    "category" "text" NOT NULL,
    "status" "text" DEFAULT 'projected'::"text" NOT NULL,
    "reference_type" "text",
    "reference_id" "uuid",
    "bank_account_id" "uuid",
    "notes" "text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "cash_flow_transactions_amount_check" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "cash_flow_transactions_reference_type_check" CHECK (("reference_type" = ANY (ARRAY['invoice'::"text", 'expense'::"text", 'account_payable'::"text", 'manual'::"text"]))),
    CONSTRAINT "cash_flow_transactions_status_check" CHECK (("status" = ANY (ARRAY['projected'::"text", 'confirmed'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "cash_flow_transactions_transaction_type_check" CHECK (("transaction_type" = ANY (ARRAY['inflow'::"text", 'outflow'::"text"])))
);


ALTER TABLE "public"."cash_flow_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."classification_learning" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "keyword" "text" NOT NULL,
    "chart_account_id" "uuid" NOT NULL,
    "confidence_score" integer DEFAULT 1,
    "last_used_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."classification_learning" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_commission_agents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "agent_id" "uuid" NOT NULL,
    "percentage" numeric(5,2) DEFAULT 50.00 NOT NULL,
    "is_active" boolean DEFAULT true,
    "start_date" "date" DEFAULT CURRENT_DATE,
    "end_date" "date",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_commission_agents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "contact_type" "text" NOT NULL,
    "contact_value" "text" NOT NULL,
    "contact_name" "text",
    "is_primary" boolean DEFAULT false,
    "is_whatsapp" boolean DEFAULT false,
    "is_valid" boolean DEFAULT true,
    "notes" "text",
    "last_contact_at" timestamp with time zone,
    "last_contact_result" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "client_contacts_contact_type_check" CHECK (("contact_type" = ANY (ARRAY['phone'::"text", 'mobile'::"text", 'whatsapp'::"text", 'email'::"text", 'telegram'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."client_contacts" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_contacts" IS 'Contatos do cliente para cobran├ºa (telefones, WhatsApp, emails)';



CREATE TABLE IF NOT EXISTS "public"."client_contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "template_id" "uuid",
    "contract_number" "text",
    "type" "text" DEFAULT 'service'::"text" NOT NULL,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date",
    "monthly_fee" numeric(10,2),
    "payment_day" integer,
    "content" "text",
    "ai_generated" boolean DEFAULT false,
    "ai_generation_date" timestamp with time zone,
    "storage_path" "text",
    "signed_storage_path" "text",
    "notes" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "client_contracts_payment_day_check" CHECK ((("payment_day" >= 1) AND ("payment_day" <= 31))),
    CONSTRAINT "client_contracts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'active'::"text", 'suspended'::"text", 'terminated'::"text", 'expired'::"text"]))),
    CONSTRAINT "client_contracts_type_check" CHECK (("type" = ANY (ARRAY['service'::"text", 'consulting'::"text", 'partnership'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."client_contracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_distracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "contract_id" "uuid",
    "template_id" "uuid",
    "distract_number" "text",
    "reason" "text" NOT NULL,
    "reason_details" "text",
    "termination_date" "date" NOT NULL,
    "notification_date" "date",
    "pending_amount" numeric(10,2) DEFAULT 0,
    "settlement_amount" numeric(10,2) DEFAULT 0,
    "settlement_status" "text" DEFAULT 'pending'::"text",
    "content" "text",
    "ai_generated" boolean DEFAULT false,
    "ai_generation_date" timestamp with time zone,
    "storage_path" "text",
    "signed_storage_path" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "notes" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "client_distracts_reason_check" CHECK (("reason" = ANY (ARRAY['client_request'::"text", 'company_suspended'::"text", 'company_inactive'::"text", 'non_payment'::"text", 'mutual_agreement'::"text", 'other'::"text"]))),
    CONSTRAINT "client_distracts_settlement_status_check" CHECK (("settlement_status" = ANY (ARRAY['pending'::"text", 'partial'::"text", 'settled'::"text", 'waived'::"text"]))),
    CONSTRAINT "client_distracts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_signature'::"text", 'signed'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."client_distracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_enrichment" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "cnpj" "text" NOT NULL,
    "razao_social" "text",
    "nome_fantasia" "text",
    "porte" "text",
    "natureza_juridica" "text",
    "situacao" "text",
    "data_abertura" "date",
    "capital_social" numeric,
    "logradouro" "text",
    "numero" "text",
    "complemento" "text",
    "bairro" "text",
    "municipio" "text",
    "uf" "text",
    "cep" "text",
    "telefone" "text",
    "email" "text",
    "atividade_principal" "jsonb",
    "atividades_secundarias" "jsonb",
    "socios" "jsonb",
    "qsa" "jsonb",
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL,
    "data_source" "text" DEFAULT 'brasilapi'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_enrichment" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "transaction_date" "date" NOT NULL,
    "description" "text" NOT NULL,
    "debit" numeric DEFAULT 0,
    "credit" numeric DEFAULT 0,
    "balance" numeric NOT NULL,
    "invoice_id" "uuid",
    "reference_type" "text",
    "reference_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid" NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_monthly_revenue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "reference_year" integer NOT NULL,
    "reference_month" integer NOT NULL,
    "gross_revenue" numeric(15,2) DEFAULT 0 NOT NULL,
    "net_revenue" numeric(15,2),
    "payroll_total" numeric(15,2),
    "calculated_fee" numeric(15,2),
    "final_fee" numeric(15,2),
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "invoice_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "client_monthly_revenue_reference_month_check" CHECK ((("reference_month" >= 1) AND ("reference_month" <= 12)))
);


ALTER TABLE "public"."client_monthly_revenue" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_monthly_revenue" IS 'Faturamento mensal dos clientes para c├ílculo de honor├írios vari├íveis';



CREATE TABLE IF NOT EXISTS "public"."client_opening_balance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "competence" character varying(7) NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "due_date" "date",
    "original_invoice_id" "uuid",
    "description" "text",
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "paid_amount" numeric(15,2) DEFAULT 0,
    "paid_date" "date",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "is_thirteenth_fee" boolean DEFAULT false,
    "journal_entry_id" "uuid",
    "fee_type" character varying(20) DEFAULT 'monthly'::character varying,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "client_opening_balance_amount_check" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "client_opening_balance_competence_check" CHECK ((("competence")::"text" ~ '^\d{2}/\d{4}$'::"text")),
    CONSTRAINT "client_opening_balance_paid_amount_check" CHECK (("paid_amount" >= (0)::numeric)),
    CONSTRAINT "paid_amount_not_greater" CHECK (("paid_amount" <= "amount"))
);


ALTER TABLE "public"."client_opening_balance" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_opening_balance" IS 'Saldo de Abertura - Concilia├º├úo Jan/2025 completa. Baixas: Iuvaci (parcial), Verdi (07-08/2024), Crystal (01/2025), Minera├º├úo Serrano (11/2024-01/2025)';



COMMENT ON COLUMN "public"."client_opening_balance"."competence" IS 'Month/Year format: MM/YYYY (e.g., 01/2024, 03/2024)';



COMMENT ON COLUMN "public"."client_opening_balance"."amount" IS 'Original amount for this competence';



COMMENT ON COLUMN "public"."client_opening_balance"."status" IS 'Payment status: pending (unpaid), paid (fully paid), partial (partially paid)';



COMMENT ON COLUMN "public"."client_opening_balance"."paid_amount" IS 'Amount already paid towards this competence';



COMMENT ON COLUMN "public"."client_opening_balance"."is_thirteenth_fee" IS 'Se esta compet├¬ncia ├® referente ao 13┬║ honor├írio';



COMMENT ON COLUMN "public"."client_opening_balance"."fee_type" IS 'Tipo do honor├írio: monthly, thirteenth, legalization, amendment, extra, other';



CREATE TABLE IF NOT EXISTS "public"."client_opening_balance_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "original_balance" numeric(15,2),
    "cleared_at" timestamp with time zone DEFAULT "now"(),
    "cleared_reason" "text",
    "period_closed" character varying(20),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_opening_balance_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "cpf" character varying(14),
    "percentage" numeric(5,2),
    "partner_type" "text",
    "is_administrator" boolean DEFAULT false,
    "email" "text",
    "phone" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    "partner_id" "uuid",
    CONSTRAINT "client_partners_partner_type_check" CHECK (("partner_type" = ANY (ARRAY['individual'::"text", 'company'::"text", 'administrator'::"text", 'director'::"text"])))
);


ALTER TABLE "public"."client_partners" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_partners" IS 'S├│cios e administradores de empresas clientes para an├ílise de grupo econ├┤mico';



CREATE TABLE IF NOT EXISTS "public"."client_partners_prospects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "client_name" "text",
    "client_cnpj" "text",
    "partner_cpf" "text" NOT NULL,
    "partner_name" "text" NOT NULL,
    "prospect_cnpj" "text" NOT NULL,
    "prospect_name" "text",
    "prospect_trade_name" "text",
    "prospect_status" "text",
    "prospect_size" "text",
    "prospect_sector" "text",
    "prospect_city" "text",
    "prospect_state" "text",
    "prospecting_status" "text" DEFAULT 'identified'::"text",
    "contact_date" "date",
    "meeting_date" "date",
    "proposal_date" "date",
    "close_date" "date",
    "estimated_monthly_fee" numeric(15,2),
    "actual_monthly_fee" numeric(15,2),
    "notes" "text",
    "last_contact_notes" "text",
    "assigned_to" "text" DEFAULT 'vendedor'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_partners_prospects" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_partners_prospects" IS 'Prospects identificados via quadro societ├írio dos clientes';



CREATE TABLE IF NOT EXISTS "public"."client_payers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "payer_name" "text" NOT NULL,
    "payer_document" "text",
    "relationship" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "notes" "text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_payers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."client_referrals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "referral_partner_id" "uuid" NOT NULL,
    "commission_percentage" numeric(5,2) DEFAULT 10 NOT NULL,
    "commission_months" integer DEFAULT 5 NOT NULL,
    "start_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "end_date" "date",
    "months_paid" integer DEFAULT 0,
    "total_commission_paid" numeric(15,2) DEFAULT 0,
    "status" character varying(20) DEFAULT 'active'::character varying,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_referrals" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_referrals" IS 'Indica├º├Áes de clientes com configura├º├úo de comiss├úo';



CREATE TABLE IF NOT EXISTS "public"."client_variable_fees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "fee_name" character varying(100) DEFAULT 'Honor├írio Vari├ível'::character varying NOT NULL,
    "fee_type" character varying(50) DEFAULT 'percentage'::character varying NOT NULL,
    "percentage_rate" numeric(5,2),
    "fixed_amount" numeric(15,2),
    "due_day" integer DEFAULT 20 NOT NULL,
    "calculation_base" character varying(50) DEFAULT 'faturamento'::character varying NOT NULL,
    "reference_month_offset" integer DEFAULT '-1'::integer,
    "is_active" boolean DEFAULT true,
    "start_date" "date",
    "end_date" "date",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "employee_commission_rate" numeric(5,2) DEFAULT 0,
    "employee_name" character varying(255),
    "employee_pix_key" character varying(255),
    "employee_pix_type" character varying(20),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."client_variable_fees" OWNER TO "postgres";


COMMENT ON TABLE "public"."client_variable_fees" IS 'Configura├º├úo de honor├írios vari├íveis (% sobre faturamento)';



COMMENT ON COLUMN "public"."client_variable_fees"."employee_commission_rate" IS 'Taxa de comiss├úo do funcion├írio sobre o honor├írio recebido';



COMMENT ON COLUMN "public"."client_variable_fees"."employee_name" IS 'Nome do funcion├írio que recebe a comiss├úo';



COMMENT ON COLUMN "public"."client_variable_fees"."employee_pix_key" IS 'Chave PIX do funcion├írio para pagamento da comiss├úo';



COMMENT ON COLUMN "public"."client_variable_fees"."employee_pix_type" IS 'Tipo da chave PIX (cpf, email, telefone, aleatoria)';



CREATE TABLE IF NOT EXISTS "public"."codigos_servico_lc116" (
    "id" integer NOT NULL,
    "codigo" character varying(10) NOT NULL,
    "descricao" "text" NOT NULL,
    "cnae_principal" character varying(10),
    "aliquota_minima" numeric(5,4) DEFAULT 0.02,
    "aliquota_maxima" numeric(5,4) DEFAULT 0.05,
    "ativo" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."codigos_servico_lc116" OWNER TO "postgres";


COMMENT ON TABLE "public"."codigos_servico_lc116" IS 'C├│digos de servi├ºo da Lei Complementar 116/2003 - Lista de servi├ºos sujeitos ao ISS';



COMMENT ON COLUMN "public"."codigos_servico_lc116"."codigo" IS 'C├│digo do item de servi├ºo (ex: 17.18)';



COMMENT ON COLUMN "public"."codigos_servico_lc116"."descricao" IS 'Descri├º├úo completa do servi├ºo';



COMMENT ON COLUMN "public"."codigos_servico_lc116"."cnae_principal" IS 'CNAE principal relacionado ao servi├ºo';



CREATE SEQUENCE IF NOT EXISTS "public"."codigos_servico_lc116_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."codigos_servico_lc116_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."codigos_servico_lc116_id_seq" OWNED BY "public"."codigos_servico_lc116"."id";



CREATE TABLE IF NOT EXISTS "public"."collection_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "trigger_days" integer NOT NULL,
    "action" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "template_id" "uuid",
    "is_active" boolean DEFAULT true,
    "priority" integer DEFAULT 0,
    "conditions" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."collection_rules" OWNER TO "postgres";


COMMENT ON TABLE "public"."collection_rules" IS 'R├®gua de cobran├ºa autom├ítica';



CREATE TABLE IF NOT EXISTS "public"."collection_work_order_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "work_order_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "description" "text",
    "result" "text",
    "next_step" "text",
    "next_contact_date" "date",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."collection_work_order_logs" OWNER TO "postgres";


COMMENT ON TABLE "public"."collection_work_order_logs" IS 'Hist├│rico completo de a├º├Áes realizadas em ordens de servi├ºo de cobran├ºa';



CREATE TABLE IF NOT EXISTS "public"."collection_work_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "invoice_id" "uuid",
    "assigned_to" "text" NOT NULL,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "action_type" "text" NOT NULL,
    "description" "text",
    "next_action_date" "date" NOT NULL,
    "resolved_at" timestamp with time zone,
    "resolution_notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "collection_work_orders_action_type_check" CHECK (("action_type" = ANY (ARRAY['phone_call'::"text", 'email'::"text", 'whatsapp'::"text", 'meeting'::"text", 'other'::"text"]))),
    CONSTRAINT "collection_work_orders_priority_check" CHECK (("priority" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "collection_work_orders_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_progress'::"text", 'resolved'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."collection_work_orders" OWNER TO "postgres";


COMMENT ON TABLE "public"."collection_work_orders" IS 'Ordens de servi├ºo para gest├úo de cobran├ºas com hist├│rico de a├º├Áes';



CREATE TABLE IF NOT EXISTS "public"."commission_agents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(200) NOT NULL,
    "cpf" character varying(14),
    "pix_key" character varying(100),
    "pix_key_type" character varying(20) DEFAULT 'cpf'::character varying,
    "email" character varying(200),
    "phone" character varying(20),
    "bank_name" character varying(100),
    "bank_agency" character varying(20),
    "bank_account" character varying(30),
    "is_active" boolean DEFAULT true,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."commission_agents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "cpf" "text",
    "rg" "text",
    "birth_date" "date",
    "role" "text",
    "participation_percentage" numeric(5,2),
    "is_administrator" boolean DEFAULT false,
    "entry_date" "date",
    "personal_address" "text",
    "personal_city" "text",
    "personal_state" "text",
    "phone" "text",
    "email" "text",
    "crc_number" "text",
    "oab_number" "text",
    "professional_council" "text",
    "description" "text",
    "expense_patterns" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."company_partners" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_profile" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "trading_name" "text",
    "cnpj" "text",
    "state_registration" "text",
    "municipal_registration" "text",
    "address" "text",
    "address_number" "text",
    "complement" "text",
    "neighborhood" "text",
    "city" "text",
    "state" "text",
    "zip_code" "text",
    "phone" "text",
    "email" "text",
    "website" "text",
    "tax_regime" "text",
    "main_activity" "text",
    "cnae_code" "text",
    "foundation_date" "date",
    "description" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."company_profile" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_service_costs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "service_id" "uuid" NOT NULL,
    "description" character varying(255) NOT NULL,
    "cost_type" character varying(50),
    "amount" numeric(15,2) NOT NULL,
    "payment_date" "date",
    "bank_transaction_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."company_service_costs" OWNER TO "postgres";


COMMENT ON TABLE "public"."company_service_costs" IS 'Taxas e custos de servi├ºos de abertura de empresas';



CREATE TABLE IF NOT EXISTS "public"."company_services" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "service_type" character varying(50) NOT NULL,
    "service_status" character varying(30) DEFAULT 'em_andamento'::character varying,
    "company_name" character varying(255),
    "company_cnpj" character varying(20),
    "company_type" character varying(50),
    "total_charged" numeric(15,2) NOT NULL,
    "total_costs" numeric(15,2) DEFAULT 0,
    "profit" numeric(15,2) GENERATED ALWAYS AS (("total_charged" - "total_costs")) STORED,
    "start_date" "date" DEFAULT CURRENT_DATE,
    "expected_completion" "date",
    "completion_date" "date",
    "payment_status" character varying(20) DEFAULT 'pending'::character varying,
    "amount_received" numeric(15,2) DEFAULT 0,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."company_services" OWNER TO "postgres";


COMMENT ON TABLE "public"."company_services" IS 'Servi├ºos de abertura, altera├º├úo e baixa de empresas';



CREATE TABLE IF NOT EXISTS "public"."content_publish_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "content_id" "uuid",
    "platform" "text" NOT NULL,
    "scheduled_at" timestamp with time zone,
    "published_at" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "whatsapp_recipients" "jsonb",
    "whatsapp_sent_count" integer DEFAULT 0,
    "instagram_account" "text",
    "instagram_post_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."content_publish_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."content_publish_queue" IS 'Fila de publica├º├úo para diferentes plataformas';



CREATE TABLE IF NOT EXISTS "public"."content_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_code" "text" NOT NULL,
    "template_name" "text" NOT NULL,
    "content_type" "text" NOT NULL,
    "target_platform" "text",
    "system_prompt" "text" NOT NULL,
    "user_prompt_template" "text" NOT NULL,
    "variables" "text"[],
    "max_tokens" integer DEFAULT 1000,
    "preferred_provider" "text" DEFAULT 'gemini'::"text",
    "tone" "text" DEFAULT 'professional'::"text",
    "example_output" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."content_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."content_templates" IS 'Templates de conte├║do com prompts para cada tipo';



CREATE TABLE IF NOT EXISTS "public"."contract_addendums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "addendum_number" "text" NOT NULL,
    "contract_id" "uuid" NOT NULL,
    "addendum_type" "text" NOT NULL,
    "previous_monthly_fee" numeric(12,2),
    "previous_services" "jsonb",
    "previous_end_date" "date",
    "new_monthly_fee" numeric(12,2),
    "new_services" "jsonb",
    "new_end_date" "date",
    "change_description" "text" NOT NULL,
    "justification" "text",
    "effective_date" "date" NOT NULL,
    "content" "text",
    "document_url" "text",
    "signed_document_url" "text",
    "signature_status" "text" DEFAULT 'pending'::"text",
    "signed_at" timestamp with time zone,
    "status" "text" DEFAULT 'draft'::"text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "contract_addendums_addendum_type_check" CHECK (("addendum_type" = ANY (ARRAY['value_change'::"text", 'service_add'::"text", 'service_remove'::"text", 'term_extension'::"text", 'term_reduction'::"text", 'general_change'::"text", 'correction'::"text"]))),
    CONSTRAINT "contract_addendums_signature_status_check" CHECK (("signature_status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'signed'::"text", 'refused'::"text"]))),
    CONSTRAINT "contract_addendums_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_signature'::"text", 'active'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."contract_addendums" OWNER TO "postgres";


COMMENT ON TABLE "public"."contract_addendums" IS 'Aditivos contratuais para altera├º├Áes nos contratos';



CREATE SEQUENCE IF NOT EXISTS "public"."contract_number_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."contract_number_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contract_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "contract_type" "text" NOT NULL,
    "template_content" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."contract_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."contract_terminations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "termination_number" "text" NOT NULL,
    "contract_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "termination_type" "text" NOT NULL,
    "termination_reason" "text" NOT NULL,
    "detailed_justification" "text",
    "request_date" "date" NOT NULL,
    "notice_date" "date",
    "effective_date" "date" NOT NULL,
    "notice_period_days" integer DEFAULT 30,
    "pending_fees" numeric(12,2) DEFAULT 0,
    "pending_months" integer DEFAULT 0,
    "fine_amount" numeric(12,2) DEFAULT 0,
    "discount_amount" numeric(12,2) DEFAULT 0,
    "total_settlement" numeric(12,2) DEFAULT 0,
    "settlement_status" "text" DEFAULT 'pending'::"text",
    "settlement_date" "date",
    "settlement_notes" "text",
    "documents_returned" boolean DEFAULT false,
    "documents_return_date" "date",
    "documents_return_protocol" "text",
    "documents_list" "jsonb" DEFAULT '[]'::"jsonb",
    "pending_obligations" "jsonb" DEFAULT '[]'::"jsonb",
    "responsibilities_end_date" "date",
    "responsibilities_description" "text",
    "content" "text",
    "document_url" "text",
    "signed_document_url" "text",
    "notification_url" "text",
    "signature_status" "text" DEFAULT 'pending'::"text",
    "signed_at" timestamp with time zone,
    "notification_sent" boolean DEFAULT false,
    "notification_sent_at" timestamp with time zone,
    "notification_method" "text",
    "notification_proof_url" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "notes" "text",
    "internal_notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "contract_terminations_settlement_status_check" CHECK (("settlement_status" = ANY (ARRAY['pending'::"text", 'partial'::"text", 'paid'::"text", 'waived'::"text", 'negotiating'::"text"]))),
    CONSTRAINT "contract_terminations_signature_status_check" CHECK (("signature_status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'signed'::"text", 'refused'::"text", 'notified_only'::"text"]))),
    CONSTRAINT "contract_terminations_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_signature'::"text", 'signed'::"text", 'notified'::"text", 'completed'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "contract_terminations_termination_type_check" CHECK (("termination_type" = ANY (ARRAY['mutual_agreement'::"text", 'client_request'::"text", 'accountant_request'::"text", 'non_payment'::"text", 'company_closed'::"text", 'company_suspended'::"text", 'contract_breach'::"text", 'force_majeure'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."contract_terminations" OWNER TO "postgres";


COMMENT ON TABLE "public"."contract_terminations" IS 'Distratos - Resolu├º├úo CFC 1.590/2020 exige rescis├úo formal';



CREATE TABLE IF NOT EXISTS "public"."contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "proposal_id" "uuid",
    "contract_number" "text",
    "start_date" "date" NOT NULL,
    "end_date" "date",
    "auto_renew" boolean DEFAULT false,
    "monthly_fee" numeric(15,2) NOT NULL,
    "services" "jsonb" DEFAULT '[]'::"jsonb",
    "status" "text" DEFAULT 'active'::"text",
    "signed_at" timestamp with time zone,
    "signature_id" "text",
    "document_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."contracts" OWNER TO "postgres";


COMMENT ON TABLE "public"."contracts" IS 'Contratos com clientes';



CREATE TABLE IF NOT EXISTS "public"."cost_center_accounts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cost_center_id" "uuid" NOT NULL,
    "chart_account_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."cost_center_accounts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cost_centers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "parent_id" "uuid",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "default_chart_account_id" "uuid",
    "order_index" integer DEFAULT 999,
    "center_type" "text" DEFAULT 'expenses'::"text",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "cost_centers_center_type_check" CHECK (("center_type" = ANY (ARRAY['expenses'::"text", 'assets'::"text"])))
);


ALTER TABLE "public"."cost_centers" OWNER TO "postgres";


COMMENT ON TABLE "public"."cost_centers" IS 'Centros de custo com separa├º├úo CLT x Terceiros por departamento';



CREATE TABLE IF NOT EXISTS "public"."crm_clientes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid",
    "prospect_id" "uuid",
    "cnpj" character varying(18),
    "razao_social" character varying(255) NOT NULL,
    "valor_mensalidade" numeric(10,2),
    "status" character varying(30) DEFAULT 'ATIVO'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."crm_clientes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."crm_interacoes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "prospect_id" "uuid",
    "empresa_id" "uuid",
    "tipo" character varying(50) NOT NULL,
    "assunto" character varying(255),
    "descricao" "text",
    "resultado" character varying(50),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."crm_interacoes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."crm_oportunidades" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "prospect_id" "uuid",
    "empresa_id" "uuid",
    "titulo" character varying(255) NOT NULL,
    "valor" numeric(15,2),
    "probabilidade" integer DEFAULT 50,
    "etapa" character varying(50) DEFAULT 'QUALIFICACAO'::character varying,
    "ativo" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."crm_oportunidades" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."crm_prospects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid",
    "cnpj" character varying(18),
    "razao_social" character varying(255) NOT NULL,
    "email" character varying(255),
    "telefone" character varying(20),
    "origem" character varying(50) DEFAULT 'MANUAL'::character varying,
    "status" character varying(30) DEFAULT 'NOVO'::character varying,
    "score" integer DEFAULT 50,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."crm_prospects" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."crm_tarefas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "prospect_id" "uuid",
    "oportunidade_id" "uuid",
    "titulo" character varying(255) NOT NULL,
    "tipo" character varying(50) DEFAULT 'OUTROS'::character varying,
    "prioridade" character varying(20) DEFAULT 'MEDIA'::character varying,
    "status" character varying(30) DEFAULT 'PENDENTE'::character varying,
    "data_vencimento" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."crm_tarefas" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."dashboard_widgets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "widget_type" "text" NOT NULL,
    "widget_config" "jsonb" NOT NULL,
    "position_x" integer DEFAULT 0,
    "position_y" integer DEFAULT 0,
    "width" integer DEFAULT 1,
    "height" integer DEFAULT 1,
    "is_visible" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."dashboard_widgets" OWNER TO "postgres";


COMMENT ON TABLE "public"."dashboard_widgets" IS 'Widgets customiz├íveis do dashboard';



CREATE TABLE IF NOT EXISTS "public"."debt_confession_installments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "confession_id" "uuid" NOT NULL,
    "installment_number" integer NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "due_date" "date" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "paid_amount" numeric(15,2) DEFAULT 0,
    "paid_at" timestamp with time zone,
    "payment_method" "text",
    "payment_reference" "text",
    "fine_amount" numeric(15,2) DEFAULT 0,
    "interest_amount" numeric(15,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "debt_confession_installments_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'paid'::"text", 'partial'::"text", 'overdue'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."debt_confession_installments" OWNER TO "postgres";


COMMENT ON TABLE "public"."debt_confession_installments" IS 'Parcelas das confiss├Áes de d├¡vida';



CREATE TABLE IF NOT EXISTS "public"."debt_confessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "confession_number" "text",
    "client_id" "uuid" NOT NULL,
    "total_debt" numeric(15,2) NOT NULL,
    "discount_percentage" numeric(5,2) DEFAULT 0,
    "discount_amount" numeric(15,2) DEFAULT 0,
    "final_amount" numeric(15,2) NOT NULL,
    "installments" integer DEFAULT 1 NOT NULL,
    "installment_value" numeric(15,2) NOT NULL,
    "first_due_date" "date" NOT NULL,
    "payment_day" integer DEFAULT 10,
    "invoice_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "content" "text",
    "document_url" "text",
    "signed_document_url" "text",
    "signature_status" "text" DEFAULT 'pending'::"text",
    "signed_at" timestamp with time zone,
    "signed_by" "text",
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "paid_installments" integer DEFAULT 0,
    "paid_amount" numeric(15,2) DEFAULT 0,
    "last_payment_date" "date",
    "defaulted_at" "date",
    "defaulted_reason" "text",
    "notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "debt_confessions_payment_day_check" CHECK ((("payment_day" >= 1) AND ("payment_day" <= 31))),
    CONSTRAINT "debt_confessions_signature_status_check" CHECK (("signature_status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'signed'::"text", 'refused'::"text"]))),
    CONSTRAINT "debt_confessions_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'signed'::"text", 'active'::"text", 'defaulted'::"text", 'cancelled'::"text", 'completed'::"text"])))
);


ALTER TABLE "public"."debt_confessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."debt_confessions" IS 'Confiss├Áes de d├¡vida - T├¡tulo Executivo Extrajudicial (Art. 585, II CPC)';



CREATE TABLE IF NOT EXISTS "public"."debt_negotiations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "negotiation_number" "text",
    "original_debt" numeric(12,2) NOT NULL,
    "interest_amount" numeric(12,2) DEFAULT 0,
    "fine_amount" numeric(12,2) DEFAULT 0,
    "discount_amount" numeric(12,2) DEFAULT 0,
    "discount_percentage" numeric(5,2) DEFAULT 0,
    "final_amount" numeric(12,2) NOT NULL,
    "payment_type" "text" NOT NULL,
    "installments_count" integer DEFAULT 1,
    "first_due_date" "date" NOT NULL,
    "installment_amount" numeric(12,2),
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "requires_approval" boolean DEFAULT false,
    "approval_level" "text",
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_notes" "text",
    "contract_generated" boolean DEFAULT false,
    "contract_signed" boolean DEFAULT false,
    "contract_signed_at" timestamp with time zone,
    "contract_url" "text",
    "invoice_ids" "uuid"[],
    "opening_balance_ids" "uuid"[],
    "negotiated_by" "uuid" NOT NULL,
    "notes" "text",
    "internal_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "debt_negotiations_payment_type_check" CHECK (("payment_type" = ANY (ARRAY['single'::"text", 'installment'::"text"]))),
    CONSTRAINT "debt_negotiations_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_approval'::"text", 'approved'::"text", 'rejected'::"text", 'active'::"text", 'completed'::"text", 'defaulted'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."debt_negotiations" OWNER TO "postgres";


COMMENT ON TABLE "public"."debt_negotiations" IS 'Negocia├º├Áes de d├¡vidas com clientes';



CREATE TABLE IF NOT EXISTS "public"."discount_approval_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "min_discount_percentage" numeric(5,2) NOT NULL,
    "max_discount_percentage" numeric(5,2) NOT NULL,
    "approval_level" "text" NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "discount_approval_rules_approval_level_check" CHECK (("approval_level" = ANY (ARRAY['operator'::"text", 'manager'::"text", 'director'::"text", 'owner'::"text"])))
);


ALTER TABLE "public"."discount_approval_rules" OWNER TO "postgres";


COMMENT ON TABLE "public"."discount_approval_rules" IS 'Regras de aprova├º├úo baseadas em percentual de desconto';



CREATE SEQUENCE IF NOT EXISTS "public"."distract_number_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."distract_number_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."document_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "content" "text" NOT NULL,
    "variables" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "document_templates_type_check" CHECK (("type" = ANY (ARRAY['contract'::"text", 'distract'::"text", 'addendum'::"text", 'receipt'::"text", 'letter'::"text"])))
);


ALTER TABLE "public"."document_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "invoice_id" "uuid",
    "expense_id" "uuid",
    "type" "text" NOT NULL,
    "file_name" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "file_size" bigint,
    "file_type" "text",
    "ocr_processed" boolean DEFAULT false,
    "ocr_data" "jsonb",
    "ocr_confidence" numeric(3,2),
    "version" integer DEFAULT 1,
    "signed" boolean DEFAULT false,
    "signed_at" timestamp with time zone,
    "signature_id" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "uploaded_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."documents" OWNER TO "postgres";


COMMENT ON TABLE "public"."documents" IS 'Gerenciamento de documentos com OCR';



CREATE TABLE IF NOT EXISTS "public"."domain_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    "aggregate_type" "text" NOT NULL,
    "aggregate_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "event_version" integer DEFAULT 1,
    "payload" "jsonb" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "user_id" "uuid",
    "correlation_id" "uuid",
    "causation_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "processing_error" "text"
);


ALTER TABLE "public"."domain_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."dr_cicero_knowledge" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "topic" "text" NOT NULL,
    "knowledge" "text" NOT NULL,
    "sources" "text"[],
    "category" "text",
    "learned_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."dr_cicero_knowledge" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."economic_group_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "economic_group_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "individual_fee" numeric(10,2) DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "group_id" "uuid",
    "company_name" "text",
    "cnpj" "text",
    "relationship_type" "text",
    "ownership_percent" numeric(5,2),
    "billing_share_percent" numeric(5,2),
    "joined_at" "date",
    "left_at" "date",
    "is_active" boolean,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."economic_group_members" OWNER TO "postgres";


COMMENT ON TABLE "public"."economic_group_members" IS 'Membros de cada grupo econ├┤mico';



CREATE SEQUENCE IF NOT EXISTS "public"."economic_group_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."economic_group_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."economic_groups" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "main_payer_client_id" "uuid",
    "total_monthly_fee" numeric(10,2) DEFAULT 0 NOT NULL,
    "payment_day" integer,
    "is_active" boolean DEFAULT true,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "group_color" "text",
    "group_name" "text",
    "group_code" "text",
    "description" "text",
    "main_company_id" "uuid",
    "main_company_name" "text",
    "main_company_cnpj" "text",
    "consolidate_billing" boolean DEFAULT true,
    "consolidated_reports" boolean DEFAULT true,
    "shared_discount_percent" numeric(5,2),
    "account_manager" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."economic_groups" OWNER TO "postgres";


COMMENT ON TABLE "public"."economic_groups" IS 'Grupos econ├┤micos (empresas vinculadas)';



CREATE TABLE IF NOT EXISTS "public"."employee_incentive_policies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "policy_name" "text" NOT NULL,
    "policy_type" "text" NOT NULL,
    "description" "text",
    "applies_to" "text"[] DEFAULT ARRAY['all'::"text"],
    "employee_reward_type" "text" NOT NULL,
    "employee_reward_percent" numeric(5,2),
    "employee_reward_fixed" numeric(15,2),
    "employee_reward_min" numeric(15,2),
    "employee_reward_max" numeric(15,2),
    "client_discount_percent" numeric(5,2),
    "client_discount_months" integer,
    "client_discount_max" numeric(15,2),
    "min_contract_value" numeric(15,2),
    "payment_after_months" integer DEFAULT 1,
    "is_active" boolean DEFAULT true,
    "valid_from" "date" DEFAULT CURRENT_DATE,
    "valid_until" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."employee_incentive_policies" OWNER TO "postgres";


COMMENT ON TABLE "public"."employee_incentive_policies" IS 'Pol├¡ticas de incentivo para funcion├írios venderem';



CREATE TABLE IF NOT EXISTS "public"."employee_sales" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "employee_id" "uuid",
    "employee_name" "text" NOT NULL,
    "employee_area" "text",
    "sale_type" "text" NOT NULL,
    "policy_id" "uuid",
    "prospect_name" "text" NOT NULL,
    "prospect_company" "text",
    "prospect_cnpj" "text",
    "prospect_contact" "text",
    "prospect_source" "text",
    "referring_client_id" "uuid",
    "referring_client_name" "text",
    "status" "text" DEFAULT 'lead'::"text",
    "contact_date" "date",
    "meeting_date" "date",
    "proposal_date" "date",
    "close_date" "date",
    "lost_reason" "text",
    "monthly_fee" numeric(15,2),
    "contract_months" integer DEFAULT 12,
    "commission_percent" numeric(5,2),
    "commission_value" numeric(15,2),
    "commission_paid" boolean DEFAULT false,
    "commission_paid_date" "date",
    "client_discount_percent" numeric(5,2),
    "client_discount_months" integer,
    "client_discount_value" numeric(15,2),
    "notes" "text",
    "how_it_happened" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."employee_sales" OWNER TO "postgres";


COMMENT ON TABLE "public"."employee_sales" IS 'Registro de vendas/indica├º├Áes feitas por funcion├írios';



CREATE TABLE IF NOT EXISTS "public"."employee_terminations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "employee_id" "uuid" NOT NULL,
    "termination_date" "date" NOT NULL,
    "last_working_day" "date" NOT NULL,
    "notice_start_date" "date",
    "payment_deadline" "date",
    "termination_type" "text" NOT NULL,
    "termination_reason" "text",
    "notice_type" "text",
    "notice_days" integer DEFAULT 30,
    "salary_at_termination" numeric(15,2) NOT NULL,
    "months_worked" integer NOT NULL,
    "years_worked" integer NOT NULL,
    "vacation_days_balance" integer DEFAULT 0,
    "thirteenth_months_due" integer DEFAULT 0,
    "saldo_salario" numeric(15,2) DEFAULT 0,
    "aviso_previo" numeric(15,2) DEFAULT 0,
    "ferias_vencidas" numeric(15,2) DEFAULT 0,
    "ferias_proporcionais" numeric(15,2) DEFAULT 0,
    "terco_constitucional" numeric(15,2) DEFAULT 0,
    "decimo_terceiro_proporcional" numeric(15,2) DEFAULT 0,
    "multa_fgts" numeric(15,2) DEFAULT 0,
    "saldo_fgts" numeric(15,2) DEFAULT 0,
    "desconto_aviso" numeric(15,2) DEFAULT 0,
    "desconto_vale_transporte" numeric(15,2) DEFAULT 0,
    "desconto_vale_alimentacao" numeric(15,2) DEFAULT 0,
    "desconto_inss" numeric(15,2) DEFAULT 0,
    "desconto_irrf" numeric(15,2) DEFAULT 0,
    "outros_descontos" numeric(15,2) DEFAULT 0,
    "total_proventos" numeric(15,2) DEFAULT 0,
    "total_descontos" numeric(15,2) DEFAULT 0,
    "valor_liquido" numeric(15,2) DEFAULT 0,
    "guia_fgts_rescisorio" numeric(15,2) DEFAULT 0,
    "guia_darf_irrf" numeric(15,2) DEFAULT 0,
    "status" "text" DEFAULT 'rascunho'::"text",
    "accounting_entry_id" "uuid",
    "advocato_consultation" "text",
    "advocato_warnings" "text"[],
    "documents" "jsonb" DEFAULT '[]'::"jsonb",
    "calculated_at" timestamp with time zone,
    "calculated_by" "uuid",
    "approved_at" timestamp with time zone,
    "approved_by" "uuid",
    "paid_at" timestamp with time zone,
    "paid_by" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "employee_terminations_notice_type_check" CHECK (("notice_type" = ANY (ARRAY['trabalhado'::"text", 'indenizado'::"text", 'dispensado'::"text", 'nao_cumprido'::"text"]))),
    CONSTRAINT "employee_terminations_status_check" CHECK (("status" = ANY (ARRAY['rascunho'::"text", 'calculada'::"text", 'aprovada'::"text", 'homologada'::"text", 'paga'::"text", 'cancelada'::"text"]))),
    CONSTRAINT "employee_terminations_termination_type_check" CHECK (("termination_type" = ANY (ARRAY['dispensa_sem_justa_causa'::"text", 'dispensa_com_justa_causa'::"text", 'pedido_demissao'::"text", 'acordo_mutuo'::"text", 'termino_contrato'::"text", 'aposentadoria'::"text", 'falecimento'::"text", 'rescisao_indireta'::"text"])))
);


ALTER TABLE "public"."employee_terminations" OWNER TO "postgres";


COMMENT ON TABLE "public"."employee_terminations" IS 'Rescis├Áes de contrato de funcion├írios';



CREATE TABLE IF NOT EXISTS "public"."employees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "cpf" "text",
    "rg" "text",
    "birth_date" "date",
    "pis" "text",
    "address" "text",
    "city" "text",
    "state" "text",
    "phone" "text",
    "email" "text",
    "department" "text" NOT NULL,
    "role" "text" NOT NULL,
    "hire_date" "date",
    "termination_date" "date",
    "contract_type" "text",
    "official_salary" numeric(15,2),
    "unofficial_salary" numeric(15,2),
    "unofficial_payment_method" "text",
    "unofficial_payment_description" "text",
    "is_per_production" boolean DEFAULT false,
    "production_description" "text",
    "average_monthly_payment" numeric(15,2),
    "vacation_days_accrued" integer DEFAULT 0,
    "last_vacation_date" "date",
    "thirteenth_provision" numeric(15,2) DEFAULT 0,
    "fgts_balance" numeric(15,2) DEFAULT 0,
    "description" "text",
    "payment_patterns" "text",
    "labor_risk_notes" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "work_area" "text",
    "salary_details" "jsonb" DEFAULT '{}'::"jsonb",
    "payment_day" integer DEFAULT 5,
    "payment_method" "text" DEFAULT 'pix'::"text",
    "bank_account" "jsonb" DEFAULT '{}'::"jsonb",
    "work_schedule" "jsonb" DEFAULT '{}'::"jsonb",
    "workload_hours" integer DEFAULT 220,
    "has_insalubrity" boolean DEFAULT false,
    "insalubrity_grade" "text",
    "has_periculosity" boolean DEFAULT false,
    "transport_voucher_value" numeric(10,2) DEFAULT 0,
    "meal_voucher_value" numeric(10,2) DEFAULT 0,
    "health_plan_value" numeric(10,2) DEFAULT 0,
    "health_plan_discount" numeric(10,2) DEFAULT 0,
    "dependents" integer DEFAULT 0,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."employees" OWNER TO "postgres";


COMMENT ON COLUMN "public"."employees"."dependents" IS 'N├║mero de dependentes para c├ílculo do IRRF';



CREATE TABLE IF NOT EXISTS "public"."empresas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cnpj" character varying(14),
    "razao_social" "text",
    "nome_fantasia" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."empresas" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."enrichment_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "message" "text",
    "metadata" "jsonb",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."enrichment_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."esocial_rubricas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "codigo" "text" NOT NULL,
    "descricao" "text" NOT NULL,
    "natureza" "text" NOT NULL,
    "tipo_rubrica" "text" NOT NULL,
    "incide_inss" boolean DEFAULT false,
    "incide_irrf" boolean DEFAULT false,
    "incide_fgts" boolean DEFAULT false,
    "incide_ferias" boolean DEFAULT false,
    "incide_13" boolean DEFAULT false,
    "formula_calculo" "text",
    "percentual_padrao" numeric(5,2),
    "cod_incidencia_cp" "text",
    "cod_incidencia_irrf" "text",
    "cod_incidencia_fgts" "text",
    "is_oficial" boolean DEFAULT true,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "account_id" "uuid",
    "account_debit_id" "uuid",
    "account_credit_id" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."esocial_rubricas" OWNER TO "postgres";


COMMENT ON TABLE "public"."esocial_rubricas" IS 'Rubricas eSocial com contas cont├íbeis vinculadas para lan├ºamentos autom├íticos';



CREATE TABLE IF NOT EXISTS "public"."expense_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "cost_center_id" "uuid",
    "chart_account_id" "uuid",
    "description" "text",
    "is_recurring" boolean DEFAULT false,
    "default_amount" numeric(15,2),
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "color" character varying(7) DEFAULT '#3B82F6'::character varying,
    "icon" character varying(50),
    "display_order" integer DEFAULT 0,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."expense_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."expenses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric(10,2) NOT NULL,
    "due_date" "date" NOT NULL,
    "payment_date" "date",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "competence" "text",
    "notes" "text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "client_id" "uuid",
    "account_id" "uuid",
    "cost_center" "text",
    "journal_entry_id" "uuid",
    "cost_center_id" "uuid" NOT NULL,
    "template_id" "uuid",
    "category_id" "uuid",
    "is_recurring" boolean DEFAULT false,
    "recurrence_frequency" "text" DEFAULT 'monthly'::"text",
    "recurrence_start_date" "date",
    "recurrence_end_date" "date",
    "recurrence_count" integer,
    "recurrence_day" integer DEFAULT 10,
    "recurrence_specific_days" integer[] DEFAULT ARRAY[]::integer[],
    "parent_expense_id" "uuid",
    "is_paused" boolean DEFAULT false,
    "supplier_id" "uuid",
    "chart_account_id" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "check_expense_amount_positive" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "expenses_recurrence_day_check" CHECK ((("recurrence_day" >= 1) AND ("recurrence_day" <= 31))),
    CONSTRAINT "expenses_recurrence_frequency_check" CHECK (("recurrence_frequency" = ANY (ARRAY['weekly'::"text", 'biweekly'::"text", 'monthly'::"text", 'annual'::"text"]))),
    CONSTRAINT "expenses_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'paid'::"text", 'overdue'::"text", 'canceled'::"text"])))
);


ALTER TABLE "public"."expenses" OWNER TO "postgres";


COMMENT ON COLUMN "public"."expenses"."account_id" IS 'Refer├¬ncia ao plano de contas';



COMMENT ON COLUMN "public"."expenses"."cost_center" IS 'Centro de custo';



COMMENT ON COLUMN "public"."expenses"."parent_expense_id" IS 'ID da despesa original que gerou esta inst├óncia recorrente';



COMMENT ON COLUMN "public"."expenses"."is_paused" IS 'Pausa a gera├º├úo de novas inst├óncias da despesa recorrente quando true';



COMMENT ON COLUMN "public"."expenses"."chart_account_id" IS 'Conta de Resultado (Despesa) - Natureza do gasto';



CREATE TABLE IF NOT EXISTS "public"."feature_analysis_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "feature_id" "uuid",
    "agent_id" "text" NOT NULL,
    "agent_name" "text" NOT NULL,
    "analysis_type" "text",
    "analysis_result" "jsonb",
    "recommendation" "text",
    "concerns" "text"[],
    "suggestions" "text"[],
    "viability_score" integer,
    "impact_score" integer,
    "effort_score" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."feature_analysis_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."feature_analysis_history" IS 'Hist├│rico de an├ílises da IA sobre solicita├º├Áes';



CREATE TABLE IF NOT EXISTS "public"."feature_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "requested_by" "text" NOT NULL,
    "requested_by_email" "text",
    "department" "text",
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "problem_description" "text",
    "expected_benefit" "text",
    "example_scenario" "text",
    "current_workaround" "text",
    "category" "text",
    "complexity" "text",
    "estimated_effort" "text",
    "priority_score" integer DEFAULT 0,
    "assigned_agent" "text",
    "agent_analysis" "text",
    "agent_recommendation" "text",
    "technical_spec" "jsonb",
    "database_changes" "text"[],
    "ui_changes" "text"[],
    "business_rules" "text"[],
    "status" "text" DEFAULT 'pending'::"text",
    "approved_by_agent" boolean DEFAULT false,
    "approved_by_manager" boolean DEFAULT false,
    "manager_name" "text",
    "rejection_reason" "text",
    "implementation_notes" "text",
    "migration_file" "text",
    "component_files" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "analyzed_at" timestamp with time zone,
    "approved_at" timestamp with time zone,
    "started_at" timestamp with time zone,
    "deployed_at" timestamp with time zone,
    "user_satisfaction" integer,
    "user_feedback" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."feature_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."feature_requests" IS 'Solicita├º├Áes de melhoria feitas pelos funcion├írios';



CREATE TABLE IF NOT EXISTS "public"."feature_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_code" "text" NOT NULL,
    "template_name" "text" NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "use_cases" "text"[],
    "base_spec" "jsonb",
    "required_tables" "text"[],
    "required_components" "text"[],
    "estimated_effort" "text",
    "clarifying_questions" "text"[],
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."feature_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."feature_templates" IS 'Templates de funcionalidades comuns para acelerar desenvolvimento';



CREATE TABLE IF NOT EXISTS "public"."fee_adjustment_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "adjustment_date" "date" NOT NULL,
    "previous_fee" numeric(10,2) NOT NULL,
    "new_fee" numeric(10,2) NOT NULL,
    "previous_minimum_wage" numeric(10,2) NOT NULL,
    "new_minimum_wage" numeric(10,2) NOT NULL,
    "fee_in_minimum_wages" numeric(10,4) NOT NULL,
    "adjustment_percentage" numeric(5,2),
    "adjustment_type" "text" DEFAULT 'minimum_wage'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."fee_adjustment_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."fee_adjustment_history" IS 'Hist├│rico de todos os reajustes de honor├írios';



CREATE TABLE IF NOT EXISTS "public"."file_processing_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "file_path" "text" NOT NULL,
    "file_type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "uploaded_by" "uuid" NOT NULL,
    "uploaded_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "processed_at" timestamp with time zone,
    "error_message" "text",
    "processing_result" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "file_processing_queue_file_type_check" CHECK (("file_type" = ANY (ARRAY['boleto_report'::"text", 'bank_statement'::"text"]))),
    CONSTRAINT "file_processing_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."file_processing_queue" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_analysis" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "analysis_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "health_score" integer,
    "trend" "text",
    "insights" "jsonb",
    "predictions" "jsonb",
    "recommendations" "jsonb",
    "alerts" "jsonb",
    "metrics" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."financial_analysis" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_gap_solutions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "gap_type" "text" NOT NULL,
    "gap_amount" numeric(15,2),
    "gap_description" "text",
    "detected_date" "date" NOT NULL,
    "target_resolution_date" "date",
    "solutions" "jsonb" DEFAULT '[]'::"jsonb",
    "selected_solution_id" "text",
    "implementation_status" "text" DEFAULT 'analyzing'::"text",
    "amount_recovered" numeric(15,2) DEFAULT 0,
    "notes" "text",
    "assigned_agents" "text"[] DEFAULT ARRAY['vendedor'::"text", 'milton'::"text", 'helena'::"text"],
    "assigned_humans" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "resolved_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."financial_gap_solutions" OWNER TO "postgres";


COMMENT ON TABLE "public"."financial_gap_solutions" IS 'Quando h├í rombo financeiro, a IA prop├Áe solu├º├Áes pr├íticas';



CREATE TABLE IF NOT EXISTS "public"."fiscal_year_closings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "fiscal_year" integer NOT NULL,
    "closing_date" "date" NOT NULL,
    "total_revenue" numeric(15,2) DEFAULT 0,
    "total_expenses" numeric(15,2) DEFAULT 0,
    "net_result" numeric(15,2) GENERATED ALWAYS AS (("total_revenue" - "total_expenses")) STORED,
    "result_type" "text" GENERATED ALWAYS AS (
CASE
    WHEN (("total_revenue" - "total_expenses") > (0)::numeric) THEN 'profit'::"text"
    WHEN (("total_revenue" - "total_expenses") < (0)::numeric) THEN 'loss'::"text"
    ELSE 'break_even'::"text"
END) STORED,
    "result_account_id" "uuid",
    "closing_journal_entry_id" "uuid",
    "result_transfer_entry_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text",
    "ai_generated" boolean DEFAULT false,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "completed_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "fiscal_year_closings_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'reverted'::"text"])))
);


ALTER TABLE "public"."fiscal_year_closings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."generated_content" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_id" "uuid",
    "template_code" "text",
    "variables_used" "jsonb",
    "provider_used" "text",
    "model_used" "text",
    "content_generated" "text" NOT NULL,
    "content_formatted" "jsonb",
    "status" "text" DEFAULT 'draft'::"text",
    "approved_by" "text",
    "approved_at" timestamp with time zone,
    "published_at" timestamp with time zone,
    "publish_platforms" "text"[],
    "views_count" integer DEFAULT 0,
    "engagement_count" integer DEFAULT 0,
    "generation_time_ms" integer,
    "tokens_used" integer,
    "cost_estimated" numeric(10,4),
    "created_by" "text" DEFAULT 'marketing'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."generated_content" OWNER TO "postgres";


COMMENT ON TABLE "public"."generated_content" IS 'Conte├║dos gerados pela IA';



CREATE TABLE IF NOT EXISTS "public"."grupos_economicos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nome" character varying(255) NOT NULL,
    "socio_principal" character varying(20),
    "empresas_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "total_empresas" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."grupos_economicos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."holidays" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "date" "date" NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "state_code" "text",
    "municipality_code" "text",
    "is_recurring" boolean DEFAULT false,
    "recurring_month" integer,
    "recurring_day" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "holidays_recurring_day_check" CHECK ((("recurring_day" >= 1) AND ("recurring_day" <= 31))),
    CONSTRAINT "holidays_recurring_month_check" CHECK ((("recurring_month" >= 1) AND ("recurring_month" <= 12))),
    CONSTRAINT "holidays_type_check" CHECK (("type" = ANY (ARRAY['national'::"text", 'state'::"text", 'municipal'::"text", 'optional'::"text"])))
);


ALTER TABLE "public"."holidays" OWNER TO "postgres";


COMMENT ON TABLE "public"."holidays" IS 'Tabela de feriados nacionais, estaduais e municipais para c├ílculo de dias ├║teis';



CREATE TABLE IF NOT EXISTS "public"."import_files" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bucket_id" "text" NOT NULL,
    "file_path" "text" NOT NULL,
    "original_name" "text" NOT NULL,
    "file_type" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "uploaded_by" "uuid",
    "processed_at" timestamp with time zone,
    "error_log" "text",
    "processing_metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "import_files_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."import_files" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."initial_load_control" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "load_type" "text" NOT NULL,
    "fiscal_year" integer NOT NULL,
    "competence" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "records_processed" integer DEFAULT 0,
    "total_amount" numeric(15,2) DEFAULT 0,
    "logs" "jsonb",
    "error_message" "text",
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "initial_load_control_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."initial_load_control" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."intelligence_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "pattern" "text" NOT NULL,
    "account_code" "text" NOT NULL,
    "account_name" "text",
    "operation_type" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."intelligence_rules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."inventory_movements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid",
    "movement_type" "text" NOT NULL,
    "quantity" numeric(10,2) NOT NULL,
    "unit_cost" numeric(10,2),
    "total_cost" numeric(15,2),
    "reference_type" "text",
    "reference_id" "uuid",
    "previous_stock" numeric(10,2),
    "new_stock" numeric(10,2),
    "notes" "text",
    "created_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."inventory_movements" OWNER TO "postgres";


COMMENT ON TABLE "public"."inventory_movements" IS 'Movimenta├º├úo de estoque (entradas e sa├¡das)';



CREATE TABLE IF NOT EXISTS "public"."invoice_generation_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "generation_day" integer DEFAULT 1,
    "due_day" integer DEFAULT 10,
    "base_amount" numeric(10,2),
    "additional_services" "jsonb" DEFAULT '[]'::"jsonb",
    "respect_opening_date" boolean DEFAULT true,
    "validate_company_status" boolean DEFAULT true,
    "is_active" boolean DEFAULT true,
    "last_generated_competence" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "invoice_generation_rules_due_day_check" CHECK ((("due_day" >= 1) AND ("due_day" <= 31))),
    CONSTRAINT "invoice_generation_rules_generation_day_check" CHECK ((("generation_day" >= 1) AND ("generation_day" <= 28)))
);


ALTER TABLE "public"."invoice_generation_rules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoice_status_audit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "old_status" character varying(50),
    "new_status" character varying(50) NOT NULL,
    "changed_by" "uuid",
    "changed_at" timestamp with time zone DEFAULT "now"(),
    "change_reason" "text",
    "automatic" boolean DEFAULT false,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."invoice_status_audit" OWNER TO "postgres";


COMMENT ON TABLE "public"."invoice_status_audit" IS 'Auditoria de mudan├ºas de status de invoices para rastreabilidade';



CREATE TABLE IF NOT EXISTS "public"."irpf_declarations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "calendar_year" integer NOT NULL,
    "fiscal_year" integer NOT NULL,
    "taxpayer_type" character varying(20) NOT NULL,
    "taxpayer_name" character varying(255) NOT NULL,
    "taxpayer_cpf" character varying(14) NOT NULL,
    "client_id" "uuid",
    "fee_amount" numeric(15,2) DEFAULT 300 NOT NULL,
    "status" character varying(30) DEFAULT 'pendente'::character varying,
    "documents_received_date" "date",
    "submission_date" "date",
    "rectification_date" "date",
    "result_type" character varying(20),
    "result_amount" numeric(15,2),
    "payment_status" character varying(20) DEFAULT 'pending'::character varying,
    "invoice_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."irpf_declarations" OWNER TO "postgres";


COMMENT ON TABLE "public"."irpf_declarations" IS 'Declara├º├Áes de IRPF (s├│cios e particulares)';



CREATE SEQUENCE IF NOT EXISTS "public"."journal_entries_entry_number_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."journal_entries_entry_number_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."journal_entries_entry_number_seq" OWNED BY "public"."journal_entries"."entry_number";



CREATE TABLE IF NOT EXISTS "public"."labor_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "employee_id" "uuid",
    "alert_type" "text" NOT NULL,
    "severity" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "recommendation" "text",
    "due_date" "date",
    "is_resolved" boolean DEFAULT false,
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    "resolution_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "entity_type" "text",
    "entity_id" "uuid",
    "entity_name" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."labor_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."labor_jurisprudence" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "court" "text" NOT NULL,
    "case_number" "text",
    "decision_date" "date",
    "summary" "text" NOT NULL,
    "full_decision" "text",
    "outcome" "text",
    "risk_type" "text",
    "key_arguments" "text"[],
    "relevance_score" integer DEFAULT 5,
    "keywords" "text"[],
    "source_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."labor_jurisprudence" OWNER TO "postgres";


COMMENT ON TABLE "public"."labor_jurisprudence" IS 'Decis├Áes judiciais relevantes para an├ílise de riscos';



CREATE TABLE IF NOT EXISTS "public"."labor_legislation" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "article" "text",
    "title" "text" NOT NULL,
    "content" "text" NOT NULL,
    "interpretation" "text",
    "keywords" "text"[],
    "is_active" boolean DEFAULT true,
    "last_update" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."labor_legislation" OWNER TO "postgres";


COMMENT ON TABLE "public"."labor_legislation" IS 'Base de conhecimento da legisla├º├úo trabalhista brasileira';



CREATE TABLE IF NOT EXISTS "public"."labor_solution_strategies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text" NOT NULL,
    "risk_types" "text"[],
    "legal_basis" "text"[],
    "implementation_steps" "jsonb",
    "requirements" "text"[],
    "warnings" "text"[],
    "estimated_cost" "text",
    "effectiveness_rating" integer DEFAULT 5,
    "complexity" "text",
    "time_to_implement" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."labor_solution_strategies" OWNER TO "postgres";


COMMENT ON TABLE "public"."labor_solution_strategies" IS 'Estrat├®gias de solu├º├úo para cada tipo de risco trabalhista';



CREATE TABLE IF NOT EXISTS "public"."logs_erros" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "modulo" character varying(100),
    "funcao" character varying(100),
    "mensagem" "text" NOT NULL,
    "dados_contexto" "jsonb" DEFAULT '{}'::"jsonb",
    "nivel" character varying(20) DEFAULT 'ERROR'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."logs_erros" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."logs_sincronizacao" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid",
    "tipo_operacao" character varying(50) NOT NULL,
    "servico" character varying(50),
    "status" character varying(30) DEFAULT 'SUCESSO'::character varying,
    "registros_processados" integer DEFAULT 0,
    "erro_mensagem" "text",
    "detalhes" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."logs_sincronizacao" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."marketing_videos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "video_type" "text" NOT NULL,
    "target_audience" "text"[],
    "video_url" "text",
    "thumbnail_url" "text",
    "duration_seconds" integer,
    "script" "text",
    "slides" "jsonb",
    "show_on_tvs" boolean DEFAULT true,
    "priority" integer DEFAULT 5,
    "start_date" "date",
    "end_date" "date",
    "show_times" "jsonb",
    "tags" "text"[],
    "status" "text" DEFAULT 'draft'::"text",
    "approved_by" "text",
    "created_by" "text" DEFAULT 'marketing'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."marketing_videos" OWNER TO "postgres";


COMMENT ON TABLE "public"."marketing_videos" IS 'V├¡deos de treinamento e motiva├º├úo para exibir nas TVs';



CREATE TABLE IF NOT EXISTS "public"."materialized_view_refresh_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "view_name" "text" NOT NULL,
    "refreshed_at" timestamp with time zone DEFAULT "now"(),
    "duration_ms" integer,
    "rows_affected" integer,
    "triggered_by" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."materialized_view_refresh_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."meeting_default_participants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_type" "text" NOT NULL,
    "participant_type" "text" NOT NULL,
    "participant_name" "text" NOT NULL,
    "participant_role" "text",
    "is_mandatory" boolean DEFAULT false,
    "notify_email" "text",
    "notify_whatsapp" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."meeting_default_participants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."message_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "subject" "text",
    "body" "text" NOT NULL,
    "variables" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."message_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."message_templates" IS 'Templates de mensagens para notifica├º├Áes multi-canal';



CREATE TABLE IF NOT EXISTS "public"."metrics_snapshots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "snapshot_date" "date" NOT NULL,
    "metric_type" "text" NOT NULL,
    "metric_value" numeric(15,2),
    "metric_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."metrics_snapshots" OWNER TO "postgres";


COMMENT ON TABLE "public"."metrics_snapshots" IS 'Snapshots di├írios de m├®tricas para analytics';



CREATE TABLE IF NOT EXISTS "public"."minimum_wage_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "effective_date" "date" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "decree_number" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "end_date" "date",
    "source" "text" DEFAULT 'MANUAL'::"text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."minimum_wage_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."minimum_wage_history" IS 'Hist├│rico de valores do sal├írio m├¡nimo brasileiro';



COMMENT ON COLUMN "public"."minimum_wage_history"."effective_date" IS 'Data de in├¡cio de vig├¬ncia do valor';



COMMENT ON COLUMN "public"."minimum_wage_history"."value" IS 'Valor do sal├írio m├¡nimo em reais';



COMMENT ON COLUMN "public"."minimum_wage_history"."end_date" IS 'Data de fim da vig├¬ncia (NULL = vig├¬ncia atual)';



COMMENT ON COLUMN "public"."minimum_wage_history"."source" IS 'Origem do dado: MANUAL, BCB_SGS_1619, IBGE';



CREATE TABLE IF NOT EXISTS "public"."monthly_closings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "closed_at" timestamp with time zone,
    "closed_by" "uuid",
    "reopened_at" timestamp with time zone,
    "reopened_by" "uuid",
    "reopened_reason" "text",
    "total_revenue" numeric(15,2) DEFAULT 0,
    "total_expenses" numeric(15,2) DEFAULT 0,
    "net_result" numeric(15,2) DEFAULT 0,
    "bank_balances" "jsonb" DEFAULT '[]'::"jsonb",
    "total_assets" numeric(15,2) DEFAULT 0,
    "total_liabilities" numeric(15,2) DEFAULT 0,
    "total_equity" numeric(15,2) DEFAULT 0,
    "accounts_receivable" numeric(15,2) DEFAULT 0,
    "accounts_payable" numeric(15,2) DEFAULT 0,
    "balance_transferred" boolean DEFAULT false,
    "transferred_at" timestamp with time zone,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "monthly_closings_month_check" CHECK ((("month" >= 1) AND ("month" <= 12))),
    CONSTRAINT "monthly_closings_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'closed'::"text", 'reopened'::"text"])))
);


ALTER TABLE "public"."monthly_closings" OWNER TO "postgres";


COMMENT ON TABLE "public"."monthly_closings" IS 'Controle de fechamento mensal - bloqueia altera├º├Áes em per├¡odos encerrados';



CREATE MATERIALIZED VIEW "public"."mv_cash_flow" AS
 WITH "daily_inflows" AS (
         SELECT "invoices"."due_date" AS "date",
            "sum"("invoices"."amount") AS "inflows"
           FROM "public"."invoices"
          WHERE ((("invoices"."status")::"text" = 'paid'::"text") AND ("invoices"."due_date" >= (CURRENT_DATE - '90 days'::interval)))
          GROUP BY "invoices"."due_date"
        ), "daily_outflows" AS (
         SELECT "expenses"."due_date" AS "date",
            "sum"("expenses"."amount") AS "outflows"
           FROM "public"."expenses"
          WHERE (("expenses"."status" = 'paid'::"text") AND ("expenses"."due_date" >= (CURRENT_DATE - '90 days'::interval)))
          GROUP BY "expenses"."due_date"
        )
 SELECT COALESCE("i"."date", "o"."date") AS "date",
    COALESCE("i"."inflows", (0)::numeric) AS "inflows",
    COALESCE("o"."outflows", (0)::numeric) AS "outflows",
    (COALESCE("i"."inflows", (0)::numeric) - COALESCE("o"."outflows", (0)::numeric)) AS "net_flow"
   FROM ("daily_inflows" "i"
     FULL JOIN "daily_outflows" "o" ON (("i"."date" = "o"."date")))
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."mv_cash_flow" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."mv_client_balances" WITH ("security_invoker"='true') AS
 SELECT "id" AS "client_id",
    "name" AS "client_name",
    (0)::numeric AS "total_debits",
    (0)::numeric AS "total_credits",
    (0)::numeric AS "balance",
    "now"() AS "last_entry_at"
   FROM "public"."clients" "c";


ALTER VIEW "public"."mv_client_balances" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."mv_coa_balances" AS
 SELECT "c"."id",
    "c"."code",
    "c"."name",
    "c"."account_type",
    "c"."nature",
    "c"."level",
    "c"."is_analytical",
    "c"."parent_id",
        CASE
            WHEN (("c"."nature")::"text" = 'DEVEDORA'::"text") THEN (COALESCE("sum"("i"."debit"), (0)::numeric) - COALESCE("sum"("i"."credit"), (0)::numeric))
            ELSE (COALESCE("sum"("i"."credit"), (0)::numeric) - COALESCE("sum"("i"."debit"), (0)::numeric))
        END AS "current_balance",
    COALESCE("sum"("i"."debit"), (0)::numeric) AS "total_debit",
    COALESCE("sum"("i"."credit"), (0)::numeric) AS "total_credit",
    "count"(DISTINCT "i"."entry_id") AS "entry_count",
    "max"("e"."entry_date") AS "last_entry_date"
   FROM (("public"."chart_of_accounts" "c"
     LEFT JOIN "public"."accounting_entry_items" "i" ON (("i"."account_id" = "c"."id")))
     LEFT JOIN "public"."accounting_entries" "e" ON ((("e"."id" = "i"."entry_id") AND ("e"."is_draft" = false))))
  WHERE ("c"."is_analytical" = true)
  GROUP BY "c"."id", "c"."code", "c"."name", "c"."account_type", "c"."nature", "c"."level", "c"."is_analytical", "c"."parent_id"
  ORDER BY "c"."code"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."mv_coa_balances" OWNER TO "postgres";


COMMENT ON MATERIALIZED VIEW "public"."mv_coa_balances" IS 'Cache de saldos do plano de contas para performance';



CREATE MATERIALIZED VIEW "public"."mv_dashboard_kpis" AS
 SELECT ( SELECT "count"(*) AS "count"
           FROM "public"."clients"
          WHERE ("clients"."status" = 'active'::"text")) AS "total_clients",
    ( SELECT "count"(*) AS "count"
           FROM "public"."invoices"
          WHERE (("invoices"."status")::"text" = 'pending'::"text")) AS "pending_invoices_count",
    ( SELECT COALESCE("sum"("invoices"."amount"), (0)::numeric) AS "coalesce"
           FROM "public"."invoices"
          WHERE (("invoices"."status")::"text" = 'pending'::"text")) AS "total_pending",
    ( SELECT "count"(*) AS "count"
           FROM "public"."invoices"
          WHERE (("invoices"."status")::"text" = 'overdue'::"text")) AS "overdue_invoices_count",
    ( SELECT COALESCE("sum"("invoices"."amount"), (0)::numeric) AS "coalesce"
           FROM "public"."invoices"
          WHERE (("invoices"."status")::"text" = 'overdue'::"text")) AS "total_overdue",
    ( SELECT "count"(*) AS "count"
           FROM "public"."expenses"
          WHERE ("expenses"."status" = 'pending'::"text")) AS "pending_expenses_count",
    ( SELECT COALESCE("sum"("expenses"."amount"), (0)::numeric) AS "coalesce"
           FROM "public"."expenses"
          WHERE ("expenses"."status" = 'pending'::"text")) AS "total_expenses",
    "now"() AS "last_updated"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."mv_dashboard_kpis" OWNER TO "postgres";


COMMENT ON MATERIALIZED VIEW "public"."mv_dashboard_kpis" IS 'Cache de KPIs principais do dashboard - refresh a cada 5 minutos recomendado';



CREATE OR REPLACE VIEW "public"."mv_default_summary" WITH ("security_invoker"='true') AS
 SELECT "client_id",
    "count"(*) FILTER (WHERE (("status")::"text" = 'overdue'::"text")) AS "overdue_count",
    COALESCE("sum"("amount") FILTER (WHERE (("status")::"text" = 'overdue'::"text")), (0)::numeric) AS "overdue_amount",
    "count"(*) FILTER (WHERE (("status")::"text" = 'pending'::"text")) AS "pending_count",
    COALESCE("sum"("amount") FILTER (WHERE (("status")::"text" = 'pending'::"text")), (0)::numeric) AS "pending_amount",
    "count"(*) FILTER (WHERE (("status")::"text" = 'paid'::"text")) AS "paid_count",
    COALESCE("sum"("amount") FILTER (WHERE (("status")::"text" = 'paid'::"text")), (0)::numeric) AS "paid_amount"
   FROM "public"."invoices"
  GROUP BY "client_id";


ALTER VIEW "public"."mv_default_summary" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."mv_dre_monthly" AS
 WITH "monthly_data" AS (
         SELECT "date_trunc"('month'::"text", ("ae"."entry_date")::timestamp with time zone) AS "month",
            "ca"."account_type",
            "ca"."code" AS "account_code",
            "ca"."name" AS "account_name",
            "sum"("aei"."debit") AS "debits",
            "sum"("aei"."credit") AS "credits"
           FROM (("public"."accounting_entries" "ae"
             JOIN "public"."accounting_entry_items" "aei" ON (("aei"."entry_id" = "ae"."id")))
             JOIN "public"."chart_of_accounts" "ca" ON (("ca"."id" = "aei"."account_id")))
          WHERE ("ae"."entry_date" >= "date_trunc"('year'::"text", (CURRENT_DATE)::timestamp with time zone))
          GROUP BY ("date_trunc"('month'::"text", ("ae"."entry_date")::timestamp with time zone)), "ca"."account_type", "ca"."code", "ca"."name"
        )
 SELECT "month",
    "account_type",
    "account_code",
    "account_name",
    "debits",
    "credits",
        CASE
            WHEN (("account_type")::"text" = ANY (ARRAY[('RECEITA'::character varying)::"text", ('revenue'::character varying)::"text", ('income'::character varying)::"text"])) THEN ("credits" - "debits")
            WHEN (("account_type")::"text" = ANY (ARRAY[('DESPESA'::character varying)::"text", ('expense'::character varying)::"text", ('cost'::character varying)::"text"])) THEN ("debits" - "credits")
            ELSE ("debits" - "credits")
        END AS "net_value"
   FROM "monthly_data"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."mv_dre_monthly" OWNER TO "postgres";


CREATE MATERIALIZED VIEW "public"."mv_trial_balance" AS
 SELECT "ca"."id" AS "account_id",
    "ca"."code",
    "ca"."name",
    "ca"."account_type",
    "ca"."parent_id",
    COALESCE("sum"("aei"."debit"), (0)::numeric) AS "total_debits",
    COALESCE("sum"("aei"."credit"), (0)::numeric) AS "total_credits",
    COALESCE(("sum"("aei"."debit") - "sum"("aei"."credit")), (0)::numeric) AS "balance"
   FROM (("public"."chart_of_accounts" "ca"
     LEFT JOIN "public"."accounting_entry_items" "aei" ON (("aei"."account_id" = "ca"."id")))
     LEFT JOIN "public"."accounting_entries" "ae" ON ((("ae"."id" = "aei"."entry_id") AND ("ae"."entry_date" >= "date_trunc"('year'::"text", (CURRENT_DATE)::timestamp with time zone)))))
  GROUP BY "ca"."id", "ca"."code", "ca"."name", "ca"."account_type", "ca"."parent_id"
  WITH NO DATA;


ALTER MATERIALIZED VIEW "public"."mv_trial_balance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."negotiation_contact_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid" NOT NULL,
    "negotiation_id" "uuid",
    "contact_id" "uuid",
    "contact_type" "text" NOT NULL,
    "contact_direction" "text" DEFAULT 'outbound'::"text" NOT NULL,
    "contact_result" "text" NOT NULL,
    "summary" "text" NOT NULL,
    "details" "text",
    "next_action" "text",
    "next_contact_date" timestamp with time zone,
    "promise_date" "date",
    "promise_amount" numeric(12,2),
    "promise_fulfilled" boolean,
    "contacted_by" "uuid" NOT NULL,
    "contact_duration" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "negotiation_contact_history_contact_direction_check" CHECK (("contact_direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text"]))),
    CONSTRAINT "negotiation_contact_history_contact_result_check" CHECK (("contact_result" = ANY (ARRAY['answered'::"text", 'not_answered'::"text", 'busy'::"text", 'voicemail'::"text", 'wrong_number'::"text", 'callback_scheduled'::"text", 'promise_to_pay'::"text", 'negotiation_started'::"text", 'refused'::"text", 'sent'::"text", 'delivered'::"text", 'read'::"text", 'replied'::"text", 'other'::"text"]))),
    CONSTRAINT "negotiation_contact_history_contact_type_check" CHECK (("contact_type" = ANY (ARRAY['phone_call'::"text", 'whatsapp'::"text", 'email'::"text", 'sms'::"text", 'visit'::"text", 'meeting'::"text", 'letter'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."negotiation_contact_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."negotiation_contact_history" IS 'Hist├│rico de tentativas de contato com o cliente';



CREATE TABLE IF NOT EXISTS "public"."negotiation_installments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "negotiation_id" "uuid" NOT NULL,
    "installment_number" integer NOT NULL,
    "amount" numeric(12,2) NOT NULL,
    "due_date" "date" NOT NULL,
    "payment_date" "date",
    "paid_amount" numeric(12,2),
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "payment_method" "text",
    "payment_reference" "text",
    "boleto_url" "text",
    "boleto_barcode" "text",
    "pix_qrcode" "text",
    "pix_copy_paste" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "negotiation_installments_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'paid'::"text", 'partial'::"text", 'overdue'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."negotiation_installments" OWNER TO "postgres";


COMMENT ON TABLE "public"."negotiation_installments" IS 'Parcelas de uma negocia├º├úo de d├¡vida';



CREATE SEQUENCE IF NOT EXISTS "public"."negotiation_number_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."negotiation_number_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."nfse" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "numero_nfse" character varying(20),
    "codigo_verificacao" character varying(50),
    "numero_rps" character varying(20) NOT NULL,
    "serie_rps" character varying(10) DEFAULT 'A'::character varying,
    "tipo_rps" integer DEFAULT 1,
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "numero_lote" character varying(20),
    "protocolo" character varying(100),
    "data_emissao" "date" DEFAULT CURRENT_DATE NOT NULL,
    "competencia" "date" NOT NULL,
    "data_autorizacao" timestamp with time zone,
    "data_cancelamento" timestamp with time zone,
    "prestador_cnpj" character varying(14) NOT NULL,
    "prestador_inscricao_municipal" character varying(20),
    "prestador_razao_social" character varying(200),
    "tomador_cnpj" character varying(14),
    "tomador_cpf" character varying(11),
    "tomador_razao_social" character varying(200) NOT NULL,
    "tomador_email" character varying(200),
    "tomador_endereco" character varying(200),
    "tomador_numero" character varying(20),
    "tomador_complemento" character varying(100),
    "tomador_bairro" character varying(100),
    "tomador_cidade" character varying(100),
    "tomador_uf" character varying(2),
    "tomador_cep" character varying(8),
    "tomador_codigo_municipio" character varying(7),
    "item_lista_servico" character varying(10) DEFAULT '1701'::character varying,
    "codigo_cnae" character varying(10) DEFAULT '6920601'::character varying,
    "discriminacao" "text" NOT NULL,
    "codigo_municipio" character varying(7) DEFAULT '5208707'::character varying,
    "municipio_incidencia" character varying(7) DEFAULT '5208707'::character varying,
    "exigibilidade_iss" integer DEFAULT 1,
    "valor_servicos" numeric(15,2) NOT NULL,
    "valor_deducoes" numeric(15,2) DEFAULT 0,
    "valor_pis" numeric(15,2) DEFAULT 0,
    "valor_cofins" numeric(15,2) DEFAULT 0,
    "valor_inss" numeric(15,2) DEFAULT 0,
    "valor_ir" numeric(15,2) DEFAULT 0,
    "valor_csll" numeric(15,2) DEFAULT 0,
    "outras_retencoes" numeric(15,2) DEFAULT 0,
    "valor_iss" numeric(15,2) DEFAULT 0,
    "aliquota" numeric(5,4) DEFAULT 0.02,
    "desconto_incondicionado" numeric(15,2) DEFAULT 0,
    "desconto_condicionado" numeric(15,2) DEFAULT 0,
    "valor_liquido" numeric(15,2),
    "iss_retido" boolean DEFAULT false,
    "optante_simples_nacional" boolean DEFAULT false,
    "incentivo_fiscal" boolean DEFAULT false,
    "invoice_id" "uuid",
    "client_id" "uuid",
    "xml_rps" "text",
    "xml_nfse" "text",
    "xml_cancelamento" "text",
    "codigo_erro" character varying(10),
    "mensagem_erro" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "cancelled_by" "uuid",
    "motivo_cancelamento" "text",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "nfse_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('processing'::character varying)::"text", ('authorized'::character varying)::"text", ('cancelled'::character varying)::"text", ('error'::character varying)::"text"])))
);


ALTER TABLE "public"."nfse" OWNER TO "postgres";


COMMENT ON TABLE "public"."nfse" IS 'Notas Fiscais de Servi├ºo Eletr├┤nicas emitidas';



COMMENT ON COLUMN "public"."nfse"."status" IS 'pending=aguardando envio, processing=enviado aguardando retorno, authorized=autorizada, cancelled=cancelada, error=erro';



CREATE TABLE IF NOT EXISTS "public"."nfse_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "ambiente" character varying(20) DEFAULT 'homologacao'::character varying,
    "base_url_homologacao" character varying(500) DEFAULT 'https://www.issnetonline.com.br/homologaabrasf/webservicenfse204'::character varying,
    "base_url_producao" character varying(500),
    "endpoint" character varying(100) DEFAULT 'nfse.asmx'::character varying,
    "prestador_cnpj" character varying(14) NOT NULL,
    "prestador_razao_social" character varying(200),
    "prestador_inscricao_municipal" character varying(20),
    "certificado_arquivo" character varying(200),
    "serie_rps_padrao" character varying(10) DEFAULT 'A'::character varying,
    "item_lista_servico_padrao" character varying(10) DEFAULT '1701'::character varying,
    "codigo_cnae_padrao" character varying(10) DEFAULT '6920601'::character varying,
    "aliquota_padrao" numeric(5,4) DEFAULT 0.02,
    "descricao_servico_padrao" "text" DEFAULT 'Servi├ºos cont├íbeis mensais'::"text",
    "ultimo_numero_rps" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "iss_fixo" numeric(15,2) DEFAULT NULL::numeric,
    "usar_iss_fixo" boolean DEFAULT true,
    "optante_simples_nacional" boolean DEFAULT true,
    "regime_tributario" character varying(20) DEFAULT 'simples_nacional'::character varying,
    "regime_especial_tributacao" integer DEFAULT 3,
    "incentivo_fiscal" boolean DEFAULT false,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "nfse_config_ambiente_check" CHECK ((("ambiente")::"text" = ANY (ARRAY[('homologacao'::character varying)::"text", ('producao'::character varying)::"text"])))
);


ALTER TABLE "public"."nfse_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."nfse_config" IS 'Configura├º├úo do prestador para emiss├úo de NFS-e. Ampla ├® optante do Simples Nacional.';



COMMENT ON COLUMN "public"."nfse_config"."iss_fixo" IS 'Valor fixo do ISS quando usar_iss_fixo=true';



COMMENT ON COLUMN "public"."nfse_config"."usar_iss_fixo" IS 'Se true, usa iss_fixo. Se false, calcula pela aliquota';



COMMENT ON COLUMN "public"."nfse_config"."optante_simples_nacional" IS 'Prestador ├® optante pelo Simples Nacional';



COMMENT ON COLUMN "public"."nfse_config"."regime_especial_tributacao" IS 'Regime: 1=Microempresa Municipal, 2=Estimativa, 3=Sociedade de Profissionais, 4=Cooperativa, 5=MEI, 6=ME EPP';



COMMENT ON COLUMN "public"."nfse_config"."incentivo_fiscal" IS 'Prestador possui incentivo fiscal';



CREATE TABLE IF NOT EXISTS "public"."nfse_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nfse_id" "uuid",
    "operacao" character varying(50) NOT NULL,
    "request_xml" "text",
    "request_timestamp" timestamp with time zone DEFAULT "now"(),
    "response_xml" "text",
    "response_timestamp" timestamp with time zone,
    "sucesso" boolean,
    "codigo_retorno" character varying(10),
    "mensagem_retorno" "text",
    "protocolo" character varying(100),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."nfse_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."nfse_log" IS 'Log de comunica├º├úo com webservice NFS-e';



CREATE TABLE IF NOT EXISTS "public"."nfse_tomadas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "numero_nfse" "text" NOT NULL,
    "codigo_verificacao" "text",
    "data_emissao" "date",
    "competencia" "text",
    "prestador_cnpj" "text" NOT NULL,
    "prestador_cpf" "text",
    "prestador_razao_social" "text",
    "prestador_inscricao_municipal" "text",
    "prestador_endereco" "text",
    "prestador_municipio" "text",
    "prestador_uf" "text",
    "tomador_cnpj" "text" NOT NULL,
    "tomador_razao_social" "text",
    "valor_servicos" numeric(15,2) DEFAULT 0 NOT NULL,
    "valor_deducoes" numeric(15,2) DEFAULT 0,
    "valor_pis" numeric(15,2) DEFAULT 0,
    "valor_cofins" numeric(15,2) DEFAULT 0,
    "valor_inss" numeric(15,2) DEFAULT 0,
    "valor_ir" numeric(15,2) DEFAULT 0,
    "valor_csll" numeric(15,2) DEFAULT 0,
    "valor_iss" numeric(15,2) DEFAULT 0,
    "outras_retencoes" numeric(15,2) DEFAULT 0,
    "aliquota" numeric(6,4) DEFAULT 0,
    "valor_liquido" numeric(15,2) DEFAULT 0,
    "discriminacao" "text",
    "item_lista_servico" "text",
    "codigo_cnae" "text",
    "codigo_municipio" "text",
    "xml_nfse" "text",
    "status" "text" DEFAULT 'pendente'::"text",
    "conta_pagar_id" "uuid",
    "supplier_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "nfse_tomadas_status_check" CHECK (("status" = ANY (ARRAY['pendente'::"text", 'lancada'::"text", 'ignorada'::"text", 'erro'::"text"])))
);


ALTER TABLE "public"."nfse_tomadas" OWNER TO "postgres";


COMMENT ON TABLE "public"."nfse_tomadas" IS 'NFS-e de servi├ºos tomados (recebidas) para lan├ºamento em contas a pagar';



CREATE TABLE IF NOT EXISTS "public"."notifications_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "invoice_id" "uuid",
    "type" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "recipient" "text" NOT NULL,
    "subject" "text",
    "message" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "error_message" "text",
    "external_id" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."notifications_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."notifications_log" IS 'Log de todas as notifica├º├Áes enviadas';



CREATE TABLE IF NOT EXISTS "public"."office_products" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text",
    "name" "text" NOT NULL,
    "description" "text",
    "brand" "text",
    "category" "text" NOT NULL,
    "subcategory" "text",
    "unit" "text" NOT NULL,
    "package_size" numeric(10,2),
    "minimum_stock" numeric(10,2) DEFAULT 1,
    "ideal_stock" numeric(10,2) DEFAULT 3,
    "current_stock" numeric(10,2) DEFAULT 0,
    "average_weekly_consumption" numeric(10,2),
    "average_monthly_consumption" numeric(10,2),
    "last_price" numeric(15,2),
    "last_price_date" "date",
    "average_price" numeric(15,2),
    "preferred_supplier" "text",
    "notes" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."office_products" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."office_recurring_expenses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "category" "text" NOT NULL,
    "description" "text",
    "average_monthly_amount" numeric(15,2),
    "payment_day" integer,
    "transaction_patterns" "text"[],
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."office_recurring_expenses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."office_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "value" "jsonb" NOT NULL,
    "description" "text",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."office_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organization_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid",
    "user_id" "uuid",
    "role_id" "uuid",
    "is_active" boolean DEFAULT true,
    "invited_at" timestamp with time zone DEFAULT "now"(),
    "joined_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."organization_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "cnpj" "text",
    "email" "text",
    "phone" "text",
    "logo_url" "text",
    "is_active" boolean DEFAULT true,
    "subscription_plan" "text" DEFAULT 'basic'::"text",
    "subscription_expires_at" timestamp with time zone,
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."organizations" OWNER TO "postgres";


COMMENT ON TABLE "public"."organizations" IS 'Escrit├│rios cont├íbeis (multi-tenant)';



CREATE TABLE IF NOT EXISTS "public"."parametros_folha" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "parametro" "text" NOT NULL,
    "valor" numeric(12,2) NOT NULL,
    "vigencia_inicio" "date" NOT NULL,
    "vigencia_fim" "date",
    "descricao" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."parametros_folha" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_family" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "partner_id" "uuid",
    "name" "text" NOT NULL,
    "relationship" "text" NOT NULL,
    "cpf" "text",
    "birth_date" "date",
    "works_at_company" boolean DEFAULT false,
    "department" "text",
    "role_at_company" "text",
    "description" "text",
    "related_expenses" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."partner_family" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_properties" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "partner_id" "uuid",
    "name" "text" NOT NULL,
    "property_type" "text",
    "address" "text",
    "address_number" "text",
    "complement" "text",
    "neighborhood" "text",
    "city" "text",
    "state" "text",
    "zip_code" "text",
    "property_registration" "text",
    "iptu_inscription" "text",
    "has_condominium" boolean DEFAULT false,
    "condominium_name" "text",
    "average_condominium" numeric(15,2),
    "average_iptu" numeric(15,2),
    "description" "text",
    "expense_patterns" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."partner_properties" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partner_vehicles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "partner_id" "uuid",
    "name" "text" NOT NULL,
    "vehicle_type" "text",
    "brand" "text",
    "model" "text",
    "year_manufacture" integer,
    "year_model" integer,
    "color" "text",
    "license_plate" "text",
    "renavam" "text",
    "chassis" "text",
    "average_ipva" numeric(15,2),
    "average_fuel_monthly" numeric(15,2),
    "description" "text",
    "expense_patterns" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."partner_vehicles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "name" "text" NOT NULL,
    "cpf" "text",
    "role" "text",
    "email" "text",
    "phone" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    "pix_key" "text"
);


ALTER TABLE "public"."partners" OWNER TO "postgres";


COMMENT ON TABLE "public"."partners" IS 'Tabela de s├│cios vinculados aos clientes';



CREATE TABLE IF NOT EXISTS "public"."payroll" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "employee_id" "uuid",
    "competencia" "date" NOT NULL,
    "status" "text" DEFAULT 'rascunho'::"text",
    "total_proventos_oficial" numeric(12,2) DEFAULT 0,
    "total_descontos_oficial" numeric(12,2) DEFAULT 0,
    "liquido_oficial" numeric(12,2) DEFAULT 0,
    "total_por_fora" numeric(12,2) DEFAULT 0,
    "liquido_total_real" numeric(12,2) DEFAULT 0,
    "inss_empresa" numeric(12,2) DEFAULT 0,
    "fgts_valor" numeric(12,2) DEFAULT 0,
    "provisao_ferias" numeric(12,2) DEFAULT 0,
    "provisao_13" numeric(12,2) DEFAULT 0,
    "custo_total_empresa" numeric(12,2) DEFAULT 0,
    "valor_sistema_externo" numeric(12,2),
    "diferenca_detectada" numeric(12,2),
    "data_calculo" timestamp with time zone,
    "data_conferencia" timestamp with time zone,
    "data_fechamento" timestamp with time zone,
    "data_pagamento" timestamp with time zone,
    "conferido_por" "uuid",
    "notas" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."payroll" OWNER TO "postgres";


COMMENT ON TABLE "public"."payroll" IS 'Folha de pagamento mensal por funcion├írio';



CREATE TABLE IF NOT EXISTS "public"."payroll_details" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payroll_id" "uuid" NOT NULL,
    "employee_id" "uuid" NOT NULL,
    "employee_name" character varying(255) NOT NULL,
    "employee_cpf" character varying(14),
    "salary_bruto" numeric(15,2) NOT NULL,
    "inss_aliquota" numeric(5,2) DEFAULT 10.00 NOT NULL,
    "inss_retido" numeric(15,2) NOT NULL,
    "irrf_aliquota" numeric(5,2) DEFAULT 5.00 NOT NULL,
    "irrf_retido" numeric(15,2) NOT NULL,
    "outros_descontos" numeric(15,2) DEFAULT 0 NOT NULL,
    "salary_liquido" numeric(15,2) NOT NULL,
    "validation_status" character varying(20) DEFAULT 'valid'::character varying,
    "validation_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "payroll_details_validation_status_check" CHECK ((("validation_status")::"text" = ANY (ARRAY[('valid'::character varying)::"text", ('invalid'::character varying)::"text", ('warning'::character varying)::"text"])))
);


ALTER TABLE "public"."payroll_details" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payroll_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payroll_id" "uuid",
    "rubrica_codigo" "text",
    "descricao" "text" NOT NULL,
    "referencia" "text",
    "valor" numeric(12,2) NOT NULL,
    "is_oficial" boolean DEFAULT true,
    "is_desconto" boolean DEFAULT false,
    "observacao" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."payroll_events" OWNER TO "postgres";


COMMENT ON TABLE "public"."payroll_events" IS 'Eventos/lan├ºamentos da folha de pagamento';



CREATE TABLE IF NOT EXISTS "public"."payroll_journal_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payroll_id" "uuid",
    "journal_entry_id" "uuid",
    "entry_type" "text" NOT NULL,
    "description" "text" NOT NULL,
    "debit_account" "text" NOT NULL,
    "credit_account" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "competence_date" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."payroll_journal_entries" OWNER TO "postgres";


COMMENT ON TABLE "public"."payroll_journal_entries" IS 'Lan├ºamentos cont├íbeis gerados automaticamente pela folha de pagamento';



CREATE TABLE IF NOT EXISTS "public"."payroll_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payroll_id" "uuid" NOT NULL,
    "payment_type" character varying(20) NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "payment_date" "date" NOT NULL,
    "due_date" "date" NOT NULL,
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "bank_transaction_id" "uuid",
    "tracking_codigo" character varying(50),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "payroll_payments_payment_type_check" CHECK ((("payment_type")::"text" = ANY (ARRAY[('salario'::character varying)::"text", ('inss'::character varying)::"text", ('irrf'::character varying)::"text"]))),
    CONSTRAINT "payroll_payments_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('paid'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."payroll_payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payrolls" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "month" integer NOT NULL,
    "year" integer NOT NULL,
    "status" character varying(20) DEFAULT 'draft'::character varying NOT NULL,
    "competence_date" "date" NOT NULL,
    "due_date" "date" NOT NULL,
    "closed_date" "date",
    "reference_code" character varying(50) NOT NULL,
    "total_bruto" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_inss" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_irrf" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_liquido" numeric(15,2) DEFAULT 0 NOT NULL,
    "notes" "text",
    "created_by" "uuid",
    "approved_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "payrolls_month_check" CHECK ((("month" >= 1) AND ("month" <= 12))),
    CONSTRAINT "payrolls_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('provisioned'::character varying)::"text", ('paid'::character varying)::"text", ('closed'::character varying)::"text"])))
);


ALTER TABLE "public"."payrolls" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pending_reconciliations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bank_account_id" "uuid" NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "cnab_reference" "text" NOT NULL,
    "cnab_document" "text",
    "amount" numeric(15,2) NOT NULL,
    "payment_date" "date" NOT NULL,
    "confidence" numeric(3,2) DEFAULT 0.85,
    "status" "text" DEFAULT 'pending'::"text",
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejected_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "ofx_fitid" "text",
    "ofx_amount" numeric(15,2),
    "ofx_date" "date",
    "cnab_amount" numeric(15,2),
    "cnab_date" "date",
    "chart_of_accounts_id" "uuid",
    "cost_center_id" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "pending_reconciliations_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."pending_reconciliations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."perdcomp_pedidos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid" NOT NULL,
    "tipo" character varying(20) NOT NULL,
    "numero_pedido" character varying(50),
    "numero_recibo" character varying(50),
    "tributo_origem" character varying(10),
    "competencia_origem" character varying(7),
    "valor_principal" numeric(15,2),
    "valor_selic" numeric(15,2),
    "valor_total" numeric(15,2),
    "tributo_destino" character varying(10),
    "competencia_destino" character varying(7),
    "status" character varying(20) DEFAULT 'GERADO'::character varying,
    "data_transmissao" timestamp with time zone,
    "data_analise" timestamp with time zone,
    "data_resultado" timestamp with time zone,
    "motivo_indeferimento" "text",
    "retencoes_ids" "uuid"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "perdcomp_pedidos_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('GERADO'::character varying)::"text", ('TRANSMITIDO'::character varying)::"text", ('EM_ANALISE'::character varying)::"text", ('DEFERIDO'::character varying)::"text", ('INDEFERIDO'::character varying)::"text", ('CANCELADO'::character varying)::"text"]))),
    CONSTRAINT "perdcomp_pedidos_tipo_check" CHECK ((("tipo")::"text" = ANY (ARRAY[('RESTITUICAO'::character varying)::"text", ('COMPENSACAO'::character varying)::"text"])))
);


ALTER TABLE "public"."perdcomp_pedidos" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."period_close_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "period_id" "uuid",
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "action" "text" NOT NULL,
    "performed_by" "uuid",
    "performed_at" timestamp with time zone DEFAULT "now"(),
    "reason" "text",
    "balances" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "period_close_history_action_check" CHECK (("action" = ANY (ARRAY['closed'::"text", 'reopened'::"text", 'locked'::"text"])))
);


ALTER TABLE "public"."period_close_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."period_reopen_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "period_id" "uuid",
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "requested_by" "uuid",
    "requested_at" timestamp with time zone DEFAULT "now"(),
    "reason" "text" NOT NULL,
    "justification" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "period_reopen_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."period_reopen_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."plr_criteria" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "criteria_name" "text" NOT NULL,
    "criteria_type" "text" NOT NULL,
    "description" "text",
    "weight_percent" numeric(5,2) NOT NULL,
    "min_value" numeric(15,2),
    "max_value" numeric(15,2),
    "scale_type" "text" DEFAULT 'linear'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."plr_criteria" OWNER TO "postgres";


COMMENT ON TABLE "public"."plr_criteria" IS 'Crit├®rios e pesos para c├ílculo do PLR';



CREATE TABLE IF NOT EXISTS "public"."plr_employee_share" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid",
    "employee_id" "uuid",
    "employee_name" "text" NOT NULL,
    "scores" "jsonb" DEFAULT '{}'::"jsonb",
    "total_score" numeric(10,2),
    "share_percent" numeric(5,4),
    "base_value" numeric(15,2),
    "bonus_value" numeric(15,2) DEFAULT 0,
    "final_value" numeric(15,2),
    "paid" boolean DEFAULT false,
    "paid_date" "date",
    "paid_method" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."plr_employee_share" OWNER TO "postgres";


COMMENT ON TABLE "public"."plr_employee_share" IS 'Participa├º├úo individual de cada funcion├írio no PLR';



CREATE TABLE IF NOT EXISTS "public"."plr_programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_name" "text" NOT NULL,
    "reference_year" integer NOT NULL,
    "description" "text",
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "revenue_target" numeric(15,2),
    "profit_target" numeric(15,2),
    "client_target" integer,
    "retention_target" numeric(5,2),
    "revenue_actual" numeric(15,2),
    "profit_actual" numeric(15,2),
    "client_actual" integer,
    "retention_actual" numeric(5,2),
    "plr_pool_percent" numeric(5,2) DEFAULT 10.0,
    "plr_pool_value" numeric(15,2),
    "plr_pool_fixed" numeric(15,2),
    "status" "text" DEFAULT 'active'::"text",
    "approved_by" "text",
    "approved_at" timestamp with time zone,
    "paid_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."plr_programs" OWNER TO "postgres";


COMMENT ON TABLE "public"."plr_programs" IS 'Programas de Participa├º├úo nos Lucros e Resultados';



CREATE TABLE IF NOT EXISTS "public"."product_consumption" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid",
    "consumption_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "quantity" numeric(10,2) NOT NULL,
    "registered_by" "text",
    "reason" "text" DEFAULT 'uso_normal'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."product_consumption" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "product_id" "uuid",
    "purchase_date" "date" NOT NULL,
    "quantity" numeric(10,2) NOT NULL,
    "unit_price" numeric(15,2) NOT NULL,
    "total_price" numeric(15,2) NOT NULL,
    "supplier" "text",
    "invoice_number" "text",
    "invoice_file_url" "text",
    "purchased_by" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."product_purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "full_name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."program_prerequisites" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_code" "text" NOT NULL,
    "program_name" "text" NOT NULL,
    "description" "text",
    "min_maturity_score" integer NOT NULL,
    "required_conditions" "jsonb" NOT NULL,
    "recommended_conditions" "jsonb",
    "risks_if_premature" "text"[],
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."program_prerequisites" OWNER TO "postgres";


COMMENT ON TABLE "public"."program_prerequisites" IS 'Pr├®-requisitos para implementar cada programa';



CREATE TABLE IF NOT EXISTS "public"."proposals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "title" "text" NOT NULL,
    "description" "text",
    "proposed_fee" numeric(15,2),
    "payment_terms" "text",
    "services" "jsonb" DEFAULT '[]'::"jsonb",
    "status" "text" DEFAULT 'draft'::"text",
    "sent_at" timestamp with time zone,
    "viewed_at" timestamp with time zone,
    "accepted_at" timestamp with time zone,
    "valid_until" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."proposals" OWNER TO "postgres";


COMMENT ON TABLE "public"."proposals" IS 'Propostas comerciais';



CREATE TABLE IF NOT EXISTS "public"."provider_invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider_id" "uuid",
    "document_type" "text" NOT NULL,
    "document_number" "text",
    "document_date" "date" NOT NULL,
    "competence_month" integer,
    "competence_year" integer,
    "gross_value" numeric(15,2) NOT NULL,
    "iss_value" numeric(15,2) DEFAULT 0,
    "inss_value" numeric(15,2) DEFAULT 0,
    "irrf_value" numeric(15,2) DEFAULT 0,
    "other_deductions" numeric(15,2) DEFAULT 0,
    "net_value" numeric(15,2),
    "payment_date" "date",
    "payment_method" "text",
    "bank_transaction_id" "uuid",
    "file_url" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."provider_invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_list_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "list_id" "uuid",
    "product_id" "uuid",
    "product_name" "text" NOT NULL,
    "brand" "text",
    "quantity" numeric(10,2) NOT NULL,
    "unit" "text",
    "last_price" numeric(15,2),
    "estimated_price" numeric(15,2),
    "quoted_price" numeric(15,2),
    "actual_price" numeric(15,2),
    "suggested_supplier" "text",
    "quoted_supplier" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "priority" "text" DEFAULT 'normal'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."purchase_list_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_lists" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "list_number" integer NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "created_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "needed_by_date" "date",
    "status" "text" DEFAULT 'draft'::"text",
    "created_by" "text",
    "assigned_to" "text",
    "approved_by" "text",
    "estimated_total" numeric(15,2),
    "quoted_total" numeric(15,2),
    "actual_total" numeric(15,2),
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approved_at" timestamp with time zone,
    "approved_by_agent" "text",
    "total_estimated" numeric(15,2),
    "total_actual" numeric(15,2),
    "purchase_date" "date",
    "invoice_number" "text",
    "invoice_file_url" "text",
    "accounting_entry_id" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."purchase_lists" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."purchase_lists_list_number_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."purchase_lists_list_number_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."purchase_lists_list_number_seq" OWNED BY "public"."purchase_lists"."list_number";



CREATE TABLE IF NOT EXISTS "public"."reconciliation_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "rule_name" "text" NOT NULL,
    "pattern" "text" NOT NULL,
    "rule_type" "text" NOT NULL,
    "target_category" "text",
    "target_account_id" "uuid",
    "auto_match" boolean DEFAULT false NOT NULL,
    "priority" integer DEFAULT 0,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid" NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "reconciliation_rules_rule_type_check" CHECK (("rule_type" = ANY (ARRAY['expense'::"text", 'revenue'::"text", 'client_payment'::"text"])))
);


ALTER TABLE "public"."reconciliation_rules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recurring_expense_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "category" "text" NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "recurrence_day" integer NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date",
    "account_id" "uuid",
    "cost_center" "text",
    "notes" "text",
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "recurring_expense_templates_recurrence_day_check" CHECK ((("recurrence_day" >= 1) AND ("recurrence_day" <= 31)))
);


ALTER TABLE "public"."recurring_expense_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recurring_expenses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description" "text" NOT NULL,
    "amount" numeric(15,2) NOT NULL,
    "payment_day" integer NOT NULL,
    "category" "text",
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."recurring_expenses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recurring_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "description" "text",
    "supplier_cnpj" character varying(20),
    "supplier_name" character varying(100),
    "due_day" integer NOT NULL,
    "amount_estimate" numeric(15,2),
    "account_code" character varying(20),
    "category" character varying(50),
    "is_personal" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "notify_days_before" integer DEFAULT 3,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "recurring_payments_due_day_check" CHECK ((("due_day" >= 1) AND ("due_day" <= 31)))
);


ALTER TABLE "public"."recurring_payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referral_commission_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referral_id" "uuid" NOT NULL,
    "reference_year" integer NOT NULL,
    "reference_month" integer NOT NULL,
    "month_number" integer NOT NULL,
    "client_fee_amount" numeric(15,2) NOT NULL,
    "commission_percentage" numeric(5,2) NOT NULL,
    "commission_amount" numeric(15,2) NOT NULL,
    "payment_status" character varying(20) DEFAULT 'pending'::character varying,
    "payment_date" "date",
    "bank_transaction_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."referral_commission_payments" OWNER TO "postgres";


COMMENT ON TABLE "public"."referral_commission_payments" IS 'Pagamentos de comiss├Áes por indica├º├úo';



CREATE TABLE IF NOT EXISTS "public"."referral_partners" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "cpf" character varying(14),
    "email" character varying(255),
    "phone" character varying(20),
    "pix_key" character varying(255),
    "pix_key_type" character varying(20),
    "bank_name" character varying(100),
    "bank_agency" character varying(10),
    "bank_account" character varying(20),
    "is_active" boolean DEFAULT true,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."referral_partners" OWNER TO "postgres";


COMMENT ON TABLE "public"."referral_partners" IS 'Parceiros/corretores que indicam clientes';



CREATE TABLE IF NOT EXISTS "public"."referral_policy" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "policy_name" "text" NOT NULL,
    "referrer_type" "text" NOT NULL,
    "referrer_reward_type" "text" NOT NULL,
    "referrer_reward_percent" numeric(5,2),
    "referrer_reward_max" numeric(15,2),
    "referrer_reward_months" integer DEFAULT 3,
    "referred_discount_percent" numeric(5,2),
    "referred_discount_months" integer DEFAULT 3,
    "is_active" boolean DEFAULT true,
    "valid_from" "date" DEFAULT CURRENT_DATE,
    "valid_until" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."referral_policy" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referral_program" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referrer_type" "text" NOT NULL,
    "referrer_client_id" "uuid",
    "referrer_name" "text" NOT NULL,
    "referrer_contact" "text",
    "referred_name" "text" NOT NULL,
    "referred_company" "text",
    "referred_cnpj" "text",
    "referred_contact" "text",
    "referred_email" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "contact_date" "date",
    "meeting_date" "date",
    "proposal_date" "date",
    "close_date" "date",
    "estimated_monthly_fee" numeric(15,2),
    "actual_monthly_fee" numeric(15,2),
    "reward_type" "text",
    "reward_value" numeric(15,2),
    "reward_percent" numeric(5,2),
    "reward_paid" boolean DEFAULT false,
    "reward_paid_date" "date",
    "notes" "text",
    "assigned_to" "text" DEFAULT 'vendedor'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."referral_program" OWNER TO "postgres";


COMMENT ON TABLE "public"."referral_program" IS 'Programa de indica├º├Áes com recompensas';



CREATE TABLE IF NOT EXISTS "public"."responsibility_letters" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "letter_number" "text" NOT NULL,
    "contract_id" "uuid",
    "client_id" "uuid" NOT NULL,
    "reference_year" integer NOT NULL,
    "reference_start_date" "date" NOT NULL,
    "reference_end_date" "date" NOT NULL,
    "administrator_name" "text" NOT NULL,
    "administrator_cpf" "text" NOT NULL,
    "administrator_role" "text",
    "declarations" "jsonb" DEFAULT '[{"code": "D1", "text": "Reconhe├ºo minha responsabilidade pela elabora├º├úo das demonstra├º├Áes cont├íbeis"}, {"code": "D2", "text": "Confirmo que todas as transa├º├Áes foram devidamente registradas"}, {"code": "D3", "text": "Declaro que n├úo tenho conhecimento de fraudes envolvendo a administra├º├úo"}, {"code": "D4", "text": "Confirmo a integridade e completude das informa├º├Áes fornecidas"}, {"code": "D5", "text": "Declaro ci├¬ncia das responsabilidades legais e tribut├írias"}]'::"jsonb" NOT NULL,
    "specific_declarations" "jsonb" DEFAULT '[]'::"jsonb",
    "content" "text",
    "document_url" "text",
    "signed_document_url" "text",
    "signature_status" "text" DEFAULT 'pending'::"text",
    "signed_at" timestamp with time zone,
    "refusal_date" "date",
    "refusal_reason" "text",
    "safeguards_adopted" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "reminder_sent" boolean DEFAULT false,
    "reminder_sent_at" timestamp with time zone,
    "notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "responsibility_letters_signature_status_check" CHECK (("signature_status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'signed'::"text", 'refused'::"text"]))),
    CONSTRAINT "responsibility_letters_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'signed'::"text", 'refused'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."responsibility_letters" OWNER TO "postgres";


COMMENT ON TABLE "public"."responsibility_letters" IS 'Carta de Responsabilidade da Administra├º├úo - ITG 1000 exige anualmente';



CREATE TABLE IF NOT EXISTS "public"."retencoes_tributarias" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid",
    "cnpj_tomador" "text" NOT NULL,
    "cnpj_prestador" "text" NOT NULL,
    "razao_social_tomador" "text",
    "razao_social_prestador" "text",
    "numero_documento" "text" NOT NULL,
    "tipo_documento" "text" DEFAULT 'NFSE'::"text",
    "data_emissao" "date",
    "valor_servico" numeric(15,2),
    "base_calculo" numeric(15,2),
    "tipo_retencao" "text" NOT NULL,
    "aliquota" numeric(5,2),
    "valor_retido" numeric(15,2),
    "competencia" "text",
    "codigo_servico" "text",
    "observacoes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."retencoes_tributarias" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."revenue_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "color" "text" DEFAULT '#10B981'::"text",
    "icon" "text",
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."revenue_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."revenue_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "calculation_type" "text" NOT NULL,
    "value" numeric,
    "multiplier" numeric,
    "percentage" numeric,
    "description" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid" NOT NULL,
    CONSTRAINT "revenue_types_calculation_type_check" CHECK (("calculation_type" = ANY (ARRAY['fixed'::"text", 'minimum_wage'::"text", 'percentage'::"text", 'custom'::"text"])))
);


ALTER TABLE "public"."revenue_types" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."risk_solution_mapping" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "risk_type" "text" NOT NULL,
    "risk_description" "text" NOT NULL,
    "solution_codes" "text"[],
    "priority_order" integer[],
    "ai_recommendation" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."risk_solution_mapping" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "permissions" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "is_system" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."sales_training_modules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "module_code" "text" NOT NULL,
    "module_name" "text" NOT NULL,
    "description" "text",
    "target_audience" "text",
    "duration_minutes" integer,
    "content" "jsonb",
    "scripts" "jsonb",
    "exercises" "jsonb",
    "quiz" "jsonb",
    "prerequisites" "text"[],
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."sales_training_modules" OWNER TO "postgres";


COMMENT ON TABLE "public"."sales_training_modules" IS 'M├│dulos de treinamento de vendas com scripts';



CREATE TABLE IF NOT EXISTS "public"."sales_training_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "module_id" "uuid",
    "trainee_name" "text" NOT NULL,
    "trainee_type" "text",
    "training_date" "date" DEFAULT CURRENT_DATE,
    "score" numeric(5,2),
    "completed" boolean DEFAULT false,
    "feedback" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."sales_training_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."serpro_caixa_postal" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "empresa_id" "uuid" NOT NULL,
    "numero_mensagem" character varying(50),
    "tipo_mensagem" character varying(50),
    "assunto" "text" NOT NULL,
    "remetente" character varying(100),
    "conteudo" "text",
    "conteudo_html" "text",
    "data_envio" timestamp with time zone,
    "data_leitura" timestamp with time zone,
    "lida" boolean DEFAULT false,
    "prioridade" character varying(20) DEFAULT 'NORMAL'::character varying,
    "tem_anexos" boolean DEFAULT false,
    "anexos" "jsonb",
    "dte_ativo" boolean DEFAULT true,
    "codigo_dte" character varying(20),
    "origem" character varying(20) DEFAULT 'SERPRO'::character varying,
    "sincronizado_em" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."serpro_caixa_postal" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."service_proposals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "proposal_number" "text" NOT NULL,
    "client_id" "uuid",
    "prospect_name" "text",
    "prospect_cnpj" "text",
    "prospect_email" "text",
    "prospect_phone" "text",
    "prospect_address" "text",
    "prospect_city" "text",
    "prospect_state" "text",
    "proposal_type" "text" DEFAULT 'accounting'::"text" NOT NULL,
    "services" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "monthly_fee" numeric(12,2),
    "setup_fee" numeric(12,2) DEFAULT 0,
    "total_annual" numeric(12,2),
    "payment_day" integer,
    "payment_method" "text" DEFAULT 'boleto'::"text",
    "adjustment_index" "text" DEFAULT 'IGPM'::"text",
    "discount_percentage" numeric(5,2) DEFAULT 0,
    "valid_until" "date" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "sent_at" timestamp with time zone,
    "viewed_at" timestamp with time zone,
    "accepted_at" timestamp with time zone,
    "rejected_at" timestamp with time zone,
    "rejection_reason" "text",
    "converted_contract_id" "uuid",
    "notes" "text",
    "internal_notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "service_proposals_payment_day_check" CHECK ((("payment_day" >= 1) AND ("payment_day" <= 31))),
    CONSTRAINT "service_proposals_proposal_type_check" CHECK (("proposal_type" = ANY (ARRAY['accounting'::"text", 'payroll'::"text", 'tax'::"text", 'consulting'::"text", 'opening'::"text", 'full_package'::"text"]))),
    CONSTRAINT "service_proposals_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'viewed'::"text", 'negotiating'::"text", 'accepted'::"text", 'rejected'::"text", 'expired'::"text", 'converted'::"text"])))
);


ALTER TABLE "public"."service_proposals" OWNER TO "postgres";


COMMENT ON TABLE "public"."service_proposals" IS 'Propostas de servi├ºos cont├íbeis - NBC PG 01 exige proposta escrita antes do contrato';



CREATE TABLE IF NOT EXISTS "public"."service_providers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid",
    "name" "text" NOT NULL,
    "cpf" "text",
    "rg" "text",
    "birth_date" "date",
    "phone" "text",
    "email" "text",
    "address" "text",
    "city" "text",
    "state" "text",
    "has_mei" boolean DEFAULT false,
    "mei_cnpj" "text",
    "mei_company_name" "text",
    "mei_trading_name" "text",
    "mei_activity" "text",
    "contract_type" "text",
    "contract_start_date" "date",
    "contract_end_date" "date",
    "contract_value" numeric(15,2),
    "payment_type" "text",
    "contract_description" "text",
    "contract_signed" boolean DEFAULT false,
    "contract_file_url" "text",
    "last_invoice_date" "date",
    "last_invoice_number" "text",
    "requires_invoice" boolean DEFAULT true,
    "service_description" "text",
    "service_area" "text",
    "description" "text",
    "payment_patterns" "text",
    "labor_risk_notes" "text",
    "compliance_status" "text" DEFAULT 'pendente_contrato'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "monthly_value" numeric(15,2),
    "services_description" "text",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."service_providers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."solution_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "gap_type" "text" NOT NULL,
    "solution_code" "text" NOT NULL,
    "solution_name" "text" NOT NULL,
    "description" "text" NOT NULL,
    "implementation_steps" "jsonb",
    "expected_impact_percent" numeric(5,2),
    "time_to_implement" "text",
    "complexity" "text",
    "required_resources" "text"[],
    "scripts" "jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."solution_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."solution_templates" IS 'Templates de solu├º├Áes por tipo de problema';



CREATE TABLE IF NOT EXISTS "public"."sora_generation_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid",
    "priority" integer DEFAULT 5,
    "status" "text" DEFAULT 'pending'::"text",
    "attempts" integer DEFAULT 0,
    "max_attempts" integer DEFAULT 3,
    "api_request" "jsonb",
    "api_response" "jsonb",
    "video_url" "text",
    "processing_time_seconds" integer,
    "error_message" "text",
    "last_error_at" timestamp with time zone,
    "queued_at" timestamp with time zone DEFAULT "now"(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."sora_generation_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."sora_generation_queue" IS 'Fila de processamento de v├¡deos Sora';



CREATE TABLE IF NOT EXISTS "public"."sora_video_projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_name" "text" NOT NULL,
    "project_type" "text" NOT NULL,
    "prompt" "text" NOT NULL,
    "negative_prompt" "text",
    "duration_seconds" integer DEFAULT 10,
    "aspect_ratio" "text" DEFAULT '16:9'::"text",
    "resolution" "text" DEFAULT '1080p'::"text",
    "style" "text" DEFAULT 'professional'::"text",
    "include_audio" boolean DEFAULT true,
    "audio_type" "text" DEFAULT 'music'::"text",
    "narration_text" "text",
    "music_style" "text",
    "include_logo" boolean DEFAULT true,
    "include_intro" boolean DEFAULT true,
    "include_outro" boolean DEFAULT true,
    "brand_colors" "jsonb" DEFAULT '{"accent": "#f5a623", "primary": "#1e3a5f", "secondary": "#4a90d9"}'::"jsonb",
    "status" "text" DEFAULT 'draft'::"text",
    "generation_started_at" timestamp with time zone,
    "generation_completed_at" timestamp with time zone,
    "video_url" "text",
    "video_duration_actual" integer,
    "thumbnail_url" "text",
    "sora_job_id" "text",
    "sora_model_used" "text",
    "generation_cost" numeric(10,4),
    "approved_by" "text",
    "approved_at" timestamp with time zone,
    "rejection_reason" "text",
    "published_to" "text"[],
    "publish_schedule" timestamp with time zone,
    "created_by" "text" DEFAULT 'marketing'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."sora_video_projects" OWNER TO "postgres";


COMMENT ON TABLE "public"."sora_video_projects" IS 'Projetos de v├¡deo para gera├º├úo com OpenAI Sora 2';



CREATE TABLE IF NOT EXISTS "public"."sora_video_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_code" "text" NOT NULL,
    "template_name" "text" NOT NULL,
    "category" "text" NOT NULL,
    "base_prompt" "text" NOT NULL,
    "variables" "text"[],
    "default_duration" integer DEFAULT 30,
    "default_aspect_ratio" "text" DEFAULT '16:9'::"text",
    "default_style" "text" DEFAULT 'professional'::"text",
    "video_structure" "jsonb",
    "example_variables" "jsonb",
    "example_output" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."sora_video_templates" OWNER TO "postgres";


COMMENT ON TABLE "public"."sora_video_templates" IS 'Templates reutiliz├íveis de v├¡deo com prompts';



CREATE TABLE IF NOT EXISTS "public"."stored_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "client_id" "uuid",
    "file_name" "text" NOT NULL,
    "file_type" "text" NOT NULL,
    "file_size" integer,
    "storage_bucket" "text" NOT NULL,
    "storage_path" "text" NOT NULL,
    "document_type" "text",
    "description" "text",
    "ai_generated" boolean DEFAULT false,
    "generation_date" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."stored_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."suppliers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "trading_name" "text",
    "cnpj" "text",
    "phone" "text",
    "email" "text",
    "contact_person" "text",
    "address" "text",
    "city" "text",
    "categories" "text"[],
    "rating" integer,
    "notes" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "account_id" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."suppliers" OWNER TO "postgres";


COMMENT ON COLUMN "public"."suppliers"."account_id" IS 'Conta cont├íbil anal├¡tica no Passivo (2.1.1.01.xxxx)';



CREATE TABLE IF NOT EXISTS "public"."system_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text",
    "employee_id" "uuid",
    "password_hash" "text",
    "temp_password" "text",
    "must_change_password" boolean DEFAULT true,
    "role" "text" DEFAULT 'viewer'::"text" NOT NULL,
    "permissions" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "last_login" timestamp with time zone,
    "login_attempts" integer DEFAULT 0,
    "locked_until" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."system_users" OWNER TO "postgres";


COMMENT ON TABLE "public"."system_users" IS 'Usu├írios do sistema com controle de acesso e permiss├Áes';



CREATE TABLE IF NOT EXISTS "public"."tabela_inss" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "vigencia_inicio" "date" NOT NULL,
    "vigencia_fim" "date",
    "faixa" integer NOT NULL,
    "valor_inicial" numeric(12,2) NOT NULL,
    "valor_final" numeric(12,2) NOT NULL,
    "aliquota" numeric(5,2) NOT NULL,
    "parcela_deduzir" numeric(12,2) DEFAULT 0,
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."tabela_inss" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tabela_irrf" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "vigencia_inicio" "date" NOT NULL,
    "vigencia_fim" "date",
    "faixa" integer NOT NULL,
    "valor_inicial" numeric(12,2) NOT NULL,
    "valor_final" numeric(12,2) NOT NULL,
    "aliquota" numeric(5,2) NOT NULL,
    "parcela_deduzir" numeric(12,2) DEFAULT 0,
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."tabela_irrf" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_configurations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "tax_code" "text" NOT NULL,
    "recurrence_type" "text" DEFAULT 'monthly'::"text",
    "payment_day" integer DEFAULT 20,
    "calculation_method" "text" DEFAULT 'fixed'::"text",
    "default_rate" numeric(10,4),
    "fixed_amount" numeric(10,2),
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."tax_configurations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_installments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description" "text" NOT NULL,
    "total_amount" numeric(15,2) NOT NULL,
    "remaining_balance" numeric(15,2),
    "installment_value" numeric(10,2) NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "payment_day" integer NOT NULL,
    "active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."tax_installments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_obligations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "client_id" "uuid",
    "obligation_type" "text" NOT NULL,
    "tax_regime" "text",
    "due_date" "date" NOT NULL,
    "competence" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "filed_at" timestamp with time zone,
    "protocol" "text",
    "responsible_user_id" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."tax_obligations" OWNER TO "postgres";


COMMENT ON TABLE "public"."tax_obligations" IS 'Calend├írio de obriga├º├Áes fiscais';



CREATE TABLE IF NOT EXISTS "public"."tenant_features" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    "feature_key" "text" NOT NULL,
    "enabled" boolean DEFAULT false,
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tenant_features" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tenant_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tenant_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text",
    "permissions" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "invited_at" timestamp with time zone DEFAULT "now"(),
    "accepted_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "tenant_users_role_check" CHECK (("role" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'manager'::"text", 'member'::"text", 'viewer'::"text"])))
);


ALTER TABLE "public"."tenant_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tenants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "cnpj" "text",
    "plan" "text" DEFAULT 'starter'::"text",
    "status" "text" DEFAULT 'active'::"text",
    "trial_ends_at" timestamp with time zone,
    "settings" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "tenants_plan_check" CHECK (("plan" = ANY (ARRAY['starter'::"text", 'professional'::"text", 'enterprise'::"text"]))),
    CONSTRAINT "tenants_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'suspended'::"text", 'cancelled'::"text", 'trial'::"text"])))
);


ALTER TABLE "public"."tenants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trial_balance_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "trial_balance_id" "uuid" NOT NULL,
    "account_id" "uuid" NOT NULL,
    "account_code" "text" NOT NULL,
    "account_name" "text" NOT NULL,
    "account_type" "text" NOT NULL,
    "account_nature" "text" NOT NULL,
    "previous_balance" numeric(15,2) DEFAULT 0,
    "debit_movement" numeric(15,2) DEFAULT 0,
    "credit_movement" numeric(15,2) DEFAULT 0,
    "current_balance" numeric(15,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."trial_balance_lines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trial_balances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "period_type" "text" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "competence" "text" NOT NULL,
    "fiscal_year" integer NOT NULL,
    "total_debit" numeric(15,2) DEFAULT 0 NOT NULL,
    "total_credit" numeric(15,2) DEFAULT 0 NOT NULL,
    "is_balanced" boolean GENERATED ALWAYS AS (("total_debit" = "total_credit")) STORED,
    "status" "text" DEFAULT 'draft'::"text",
    "ai_generated" boolean DEFAULT false,
    "generation_date" timestamp with time zone DEFAULT "now"(),
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL,
    CONSTRAINT "trial_balances_period_type_check" CHECK (("period_type" = ANY (ARRAY['monthly'::"text", 'quarterly'::"text", 'annual'::"text"]))),
    CONSTRAINT "trial_balances_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'reviewed'::"text", 'approved'::"text", 'closed'::"text"])))
);


ALTER TABLE "public"."trial_balances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tv_playlist" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tv_location" "text" NOT NULL,
    "tv_name" "text",
    "videos" "jsonb" DEFAULT '[]'::"jsonb",
    "shuffle" boolean DEFAULT false,
    "loop" boolean DEFAULT true,
    "active_start_time" time without time zone DEFAULT '08:00:00'::time without time zone,
    "active_end_time" time without time zone DEFAULT '18:00:00'::time without time zone,
    "active_days" integer[] DEFAULT ARRAY[1, 2, 3, 4, 5],
    "volume" integer DEFAULT 50,
    "show_clock" boolean DEFAULT true,
    "show_weather" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."tv_playlist" OWNER TO "postgres";


COMMENT ON TABLE "public"."tv_playlist" IS 'Configura├º├úo das TVs de cada sala';



CREATE TABLE IF NOT EXISTS "public"."tv_video_playlist" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "tv_location" "text" NOT NULL,
    "video_project_id" "uuid",
    "video_url" "text",
    "video_title" "text",
    "video_duration" integer,
    "display_order" integer DEFAULT 0,
    "start_date" "date" DEFAULT CURRENT_DATE,
    "end_date" "date",
    "display_times" "text"[],
    "repeat_interval_minutes" integer DEFAULT 30,
    "is_active" boolean DEFAULT true,
    "play_count" integer DEFAULT 0,
    "last_played_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."tv_video_playlist" OWNER TO "postgres";


COMMENT ON TABLE "public"."tv_video_playlist" IS 'Playlist de v├¡deos para cada TV do escrit├│rio';



CREATE TABLE IF NOT EXISTS "public"."user_office_access" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "office_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'user'::"text" NOT NULL,
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."user_office_access" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_office_access" IS 'Controle de acesso de usu├írios aos escrit├│rios cont├íbeis (multi-tenant)';



COMMENT ON COLUMN "public"."user_office_access"."role" IS 'Papel do usu├írio: admin (tudo), manager (gerencia), user (opera), viewer (apenas visualiza)';



CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."app_role" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."user_roles" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_account_ledger" WITH ("security_invoker"='true') AS
 SELECT "c"."code" AS "account_code",
    "c"."name" AS "account_name",
    "c"."nature",
    "e"."entry_date",
    "e"."document_number",
    "e"."description" AS "entry_description",
    "i"."history" AS "item_history",
    "i"."debit",
    "i"."credit",
    "e"."id" AS "entry_id",
    "i"."id" AS "item_id"
   FROM (("public"."accounting_entry_items" "i"
     JOIN "public"."accounting_entries" "e" ON (("e"."id" = "i"."entry_id")))
     JOIN "public"."chart_of_accounts" "c" ON (("c"."id" = "i"."account_id")))
  WHERE ("e"."is_draft" = false)
  ORDER BY "c"."code", "e"."entry_date", "e"."id";


ALTER VIEW "public"."v_account_ledger" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_accounting_entries_with_source" WITH ("security_invoker"='true') AS
 SELECT "ae"."id",
    "ae"."internal_code",
    "ae"."entry_date",
    "ae"."competence_date",
    "ae"."description",
    "ae"."entry_type",
    "ae"."total_debit",
    "ae"."total_credit",
    "ae"."source_type",
    "ae"."source_id",
    "ae"."created_at",
        CASE
            WHEN (("ae"."source_type")::"text" = 'bank_transaction'::"text") THEN "bt"."description"
            WHEN (("ae"."source_type")::"text" = 'invoice'::"text") THEN "concat"('Fatura: ', "i"."competence")
            ELSE NULL::"text"
        END AS "source_description",
        CASE
            WHEN (("ae"."source_type")::"text" = 'bank_transaction'::"text") THEN "bt"."fitid"
            ELSE NULL::"text"
        END AS "source_external_id",
    ( SELECT "count"(*) AS "count"
           FROM "public"."accounting_entry_lines" "ael"
          WHERE ("ael"."entry_id" = "ae"."id")) AS "line_count"
   FROM (("public"."accounting_entries" "ae"
     LEFT JOIN "public"."bank_transactions" "bt" ON ((("ae"."source_id" = "bt"."id") AND (("ae"."source_type")::"text" = 'bank_transaction'::"text"))))
     LEFT JOIN "public"."invoices" "i" ON ((("ae"."source_id" = "i"."id") AND (("ae"."source_type")::"text" = 'invoice'::"text"))));


ALTER VIEW "public"."v_accounting_entries_with_source" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_accounts_receivable" WITH ("security_invoker"='true') AS
 SELECT "sum"("amount") AS "total_receivable",
    "count"(*) AS "invoice_count",
    "competence"
   FROM "public"."invoices"
  WHERE (("status")::"text" = 'pending'::"text")
  GROUP BY "competence"
  ORDER BY "competence";


ALTER VIEW "public"."v_accounts_receivable" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_balancete" WITH ("security_invoker"='true') AS
 WITH "account_balances" AS (
         SELECT "coa"."id" AS "account_id",
            "coa"."code" AS "account_code",
            "coa"."name" AS "account_name",
            "coa"."account_type",
            "coa"."nature",
            "coa"."is_analytical",
            "coa"."parent_id",
            EXTRACT(year FROM "ae"."entry_date") AS "year",
            EXTRACT(month FROM "ae"."entry_date") AS "month",
            COALESCE("sum"("ael"."debit"), (0)::numeric) AS "total_debit",
            COALESCE("sum"("ael"."credit"), (0)::numeric) AS "total_credit"
           FROM (("public"."chart_of_accounts" "coa"
             LEFT JOIN "public"."accounting_entry_lines" "ael" ON (("ael"."account_id" = "coa"."id")))
             LEFT JOIN "public"."accounting_entries" "ae" ON (("ae"."id" = "ael"."entry_id")))
          WHERE ("coa"."is_active" = true)
          GROUP BY "coa"."id", "coa"."code", "coa"."name", "coa"."account_type", "coa"."nature", "coa"."is_analytical", "coa"."parent_id", (EXTRACT(year FROM "ae"."entry_date")), (EXTRACT(month FROM "ae"."entry_date"))
        )
 SELECT "account_id",
    "account_code",
    "account_name",
    "account_type",
    "nature",
    "is_analytical",
    "parent_id",
    "year",
    "month",
    "total_debit",
    "total_credit",
        CASE
            WHEN (("nature")::"text" = 'DEVEDORA'::"text") THEN ("total_debit" - "total_credit")
            WHEN (("nature")::"text" = 'CREDORA'::"text") THEN ("total_credit" - "total_debit")
            ELSE ("total_debit" - "total_credit")
        END AS "balance"
   FROM "account_balances"
  WHERE (("total_debit" > (0)::numeric) OR ("total_credit" > (0)::numeric));


ALTER VIEW "public"."v_balancete" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_balancete" IS 'Balancete - THE SOURCE OF TRUTH. All other views consume from this.';



CREATE OR REPLACE VIEW "public"."v_adiantamentos_socios" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "year",
    "month",
    "total_debit",
    "total_credit",
    "balance" AS "saldo"
   FROM "public"."v_balancete"
  WHERE ((("account_code")::"text" ~~ '1.1.3.04%'::"text") AND ("is_analytical" = true));


ALTER VIEW "public"."v_adiantamentos_socios" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_adiantamentos_socios" IS 'Partner advances from accounting entries (via Balancete)';



CREATE OR REPLACE VIEW "public"."v_ai_validation_stats" WITH ("security_invoker"='true') AS
 SELECT "count"(*) FILTER (WHERE ("ai_validated" = true)) AS "validated_count",
    "count"(*) FILTER (WHERE ("ai_validated" = false)) AS "pending_count",
    "count"(*) FILTER (WHERE ("ai_validation_result" = 'valid'::"text")) AS "valid_count",
    "count"(*) FILTER (WHERE ("ai_validation_result" = 'invalid'::"text")) AS "invalid_count",
    "count"(*) FILTER (WHERE ("ai_validation_result" = 'warning'::"text")) AS "warning_count",
    "avg"("ai_confidence") FILTER (WHERE ("ai_confidence" IS NOT NULL)) AS "avg_confidence",
    "count"(*) AS "total_entries"
   FROM "public"."accounting_entries";


ALTER VIEW "public"."v_ai_validation_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_analise_cobranca" WITH ("security_invoker"='true') AS
 SELECT "competence" AS "competencia",
    "count"(*) AS "boletos_gerados",
    "sum"("amount") AS "valor_gerado",
    "count"(*) FILTER (WHERE (("status")::"text" = 'paid'::"text")) AS "boletos_pagos",
    COALESCE("sum"("paid_amount") FILTER (WHERE (("status")::"text" = 'paid'::"text")), (0)::numeric) AS "valor_recebido",
    "count"(*) FILTER (WHERE ((("status")::"text" = 'pending'::"text") AND ("due_date" < CURRENT_DATE))) AS "boletos_atrasados",
    COALESCE("sum"("amount") FILTER (WHERE ((("status")::"text" = 'pending'::"text") AND ("due_date" < CURRENT_DATE))), (0)::numeric) AS "valor_atrasado",
        CASE
            WHEN ("sum"("amount") > (0)::numeric) THEN "round"(((COALESCE("sum"("paid_amount") FILTER (WHERE (("status")::"text" = 'paid'::"text")), (0)::numeric) / "sum"("amount")) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "percentual_recebimento"
   FROM "public"."invoices"
  WHERE ("competence" IS NOT NULL)
  GROUP BY "competence"
  ORDER BY "competence" DESC;


ALTER VIEW "public"."v_analise_cobranca" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_balanco_patrimonial" WITH ("security_invoker"='true') AS
 SELECT "year",
    "month",
    "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '1%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) AS "ativo",
    "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '2%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) AS "passivo",
    "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '5%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) AS "patrimonio_liquido"
   FROM "public"."v_balancete"
  WHERE ("is_analytical" = true)
  GROUP BY "year", "month"
  ORDER BY "year", "month";


ALTER VIEW "public"."v_balanco_patrimonial" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_balanco_patrimonial" IS 'Balance sheet summary consuming from Balancete';



CREATE OR REPLACE VIEW "public"."v_bank_balance_by_period" WITH ("security_invoker"='true') AS
 SELECT "ba"."id" AS "bank_account_id",
    "ba"."name" AS "account_name",
    EXTRACT(year FROM "bt"."transaction_date") AS "year",
    EXTRACT(month FROM "bt"."transaction_date") AS "month",
    "sum"(
        CASE
            WHEN (("bt"."transaction_type" = 'credit'::"text") AND (NOT COALESCE("bt"."is_opening_balance", false))) THEN "abs"("bt"."amount")
            ELSE (0)::numeric
        END) AS "credits",
    "sum"(
        CASE
            WHEN (("bt"."transaction_type" = 'credit'::"text") AND COALESCE("bt"."is_opening_balance", false)) THEN "abs"("bt"."amount")
            ELSE (0)::numeric
        END) AS "opening_balance_credits",
    "sum"(
        CASE
            WHEN ("bt"."transaction_type" = 'debit'::"text") THEN "abs"("bt"."amount")
            ELSE (0)::numeric
        END) AS "debits",
    "count"(*) AS "transaction_count"
   FROM ("public"."bank_accounts" "ba"
     LEFT JOIN "public"."bank_transactions" "bt" ON (("bt"."bank_account_id" = "ba"."id")))
  WHERE ("bt"."transaction_date" IS NOT NULL)
  GROUP BY "ba"."id", "ba"."name", (EXTRACT(year FROM "bt"."transaction_date")), (EXTRACT(month FROM "bt"."transaction_date"))
  ORDER BY (EXTRACT(year FROM "bt"."transaction_date")), (EXTRACT(month FROM "bt"."transaction_date"));


ALTER VIEW "public"."v_bank_balance_by_period" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_bank_balance_by_period" IS 'Resumo de movimenta├º├úo banc├íria por per├¡odo, separando saldo de abertura';



CREATE OR REPLACE VIEW "public"."v_bank_balance_from_entries" WITH ("security_invoker"='true') AS
 SELECT "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    "sum"("ael"."debit") AS "total_debit",
    "sum"("ael"."credit") AS "total_credit",
    ("sum"("ael"."debit") - "sum"("ael"."credit")) AS "balance"
   FROM (("public"."accounting_entry_lines" "ael"
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "ael"."account_id")))
     JOIN "public"."accounting_entries" "ae" ON (("ae"."id" = "ael"."entry_id")))
  WHERE (("coa"."code")::"text" = '1.1.1.05'::"text")
  GROUP BY "coa"."code", "coa"."name";


ALTER VIEW "public"."v_bank_balance_from_entries" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projections_contractors" WITH ("security_invoker"='true') AS
 WITH "active_pj" AS (
         SELECT "employees"."id" AS "employee_id",
            "employees"."name",
            (COALESCE("employees"."unofficial_salary", (0)::numeric) + COALESCE("employees"."official_salary", (0)::numeric)) AS "contract_value"
           FROM "public"."employees"
          WHERE (("employees"."is_active" = true) AND ("employees"."contract_type" = 'PJ'::"text") AND ((COALESCE("employees"."unofficial_salary", (0)::numeric) + COALESCE("employees"."official_salary", (0)::numeric)) > (0)::numeric))
        ), "next_payment_date" AS (
         SELECT
                CASE
                    WHEN (EXTRACT(day FROM CURRENT_DATE) <= (10)::numeric) THEN "make_date"((EXTRACT(year FROM CURRENT_DATE))::integer, (EXTRACT(month FROM CURRENT_DATE))::integer, 10)
                    ELSE "make_date"((EXTRACT(year FROM (CURRENT_DATE + '1 mon'::interval)))::integer, (EXTRACT(month FROM (CURRENT_DATE + '1 mon'::interval)))::integer, 10)
                END AS "pay_date"
        )
 SELECT "e"."employee_id",
    "e"."name",
    'PJ'::"text" AS "type",
    "d"."pay_date" AS "due_date",
    "e"."contract_value" AS "amount",
    ('Honor├írios PJ - '::"text" || "e"."name") AS "description"
   FROM "active_pj" "e",
    "next_payment_date" "d";


ALTER VIEW "public"."v_projections_contractors" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projections_custom" AS
 WITH "future_dates" AS (
         SELECT ("generate_series"((CURRENT_DATE)::timestamp without time zone, (CURRENT_DATE + '1 year'::interval), '1 day'::interval))::"date" AS "ref_date"
        ), "expanded_projections" AS (
         SELECT "cash_flow_projections"."id",
            "cash_flow_projections"."description",
            "cash_flow_projections"."amount",
            "cash_flow_projections"."projection_date" AS "due_date",
            "cash_flow_projections"."projection_type",
            "cash_flow_projections"."category",
            'manual'::"text" AS "confidence_level"
           FROM "public"."cash_flow_projections"
          WHERE (("cash_flow_projections"."is_active" = true) AND (("cash_flow_projections"."frequency" IS NULL) OR ("cash_flow_projections"."frequency" = 'once'::"text")) AND ("cash_flow_projections"."projection_date" >= CURRENT_DATE))
        UNION ALL
         SELECT "cp"."id",
            "cp"."description",
            "cp"."amount",
            "fd"."ref_date" AS "due_date",
            "cp"."projection_type",
            "cp"."category",
            'recurring'::"text" AS "confidence_level"
           FROM ("public"."cash_flow_projections" "cp"
             CROSS JOIN "future_dates" "fd")
          WHERE (("cp"."is_active" = true) AND ("cp"."frequency" = 'daily'::"text") AND ("fd"."ref_date" >= "cp"."projection_date") AND (("cp"."recurrence_end_date" IS NULL) OR ("fd"."ref_date" <= "cp"."recurrence_end_date")))
        UNION ALL
         SELECT "cp"."id",
            "cp"."description",
            "cp"."amount",
            "fd"."ref_date" AS "due_date",
            "cp"."projection_type",
            "cp"."category",
            'recurring'::"text" AS "confidence_level"
           FROM ("public"."cash_flow_projections" "cp"
             CROSS JOIN "future_dates" "fd")
          WHERE (("cp"."is_active" = true) AND ("cp"."frequency" = 'weekly'::"text") AND ("fd"."ref_date" >= "cp"."projection_date") AND (EXTRACT(dow FROM "fd"."ref_date") = EXTRACT(dow FROM "cp"."projection_date")) AND (("cp"."recurrence_end_date" IS NULL) OR ("fd"."ref_date" <= "cp"."recurrence_end_date")))
        UNION ALL
         SELECT "cp"."id",
            "cp"."description",
            "cp"."amount",
            "make_date"((EXTRACT(year FROM "fd"."ref_date"))::integer, (EXTRACT(month FROM "fd"."ref_date"))::integer, LEAST((EXTRACT(day FROM "cp"."projection_date"))::integer, (EXTRACT(day FROM (("date_trunc"('month'::"text", ("fd"."ref_date")::timestamp with time zone) + '1 mon'::interval) - '1 day'::interval)))::integer)) AS "due_date",
            "cp"."projection_type",
            "cp"."category",
            'recurring'::"text" AS "confidence_level"
           FROM ("public"."cash_flow_projections" "cp"
             CROSS JOIN ( SELECT DISTINCT ("date_trunc"('month'::"text", ("future_dates"."ref_date")::timestamp with time zone))::"date" AS "ref_date"
                   FROM "future_dates") "fd")
          WHERE (("cp"."is_active" = true) AND ("cp"."frequency" = 'monthly'::"text") AND ("fd"."ref_date" >= ("date_trunc"('month'::"text", ("cp"."projection_date")::timestamp with time zone))::"date") AND (("cp"."recurrence_end_date" IS NULL) OR ("fd"."ref_date" <= "cp"."recurrence_end_date")))
        UNION ALL
         SELECT "cp"."id",
            "cp"."description",
            "cp"."amount",
            "make_date"("fd"."year", (EXTRACT(month FROM "cp"."projection_date"))::integer, (EXTRACT(day FROM "cp"."projection_date"))::integer) AS "due_date",
            "cp"."projection_type",
            "cp"."category",
            'recurring'::"text" AS "confidence_level"
           FROM ("public"."cash_flow_projections" "cp"
             CROSS JOIN ( SELECT DISTINCT (EXTRACT(year FROM "future_dates"."ref_date"))::integer AS "year"
                   FROM "future_dates") "fd")
          WHERE (("cp"."is_active" = true) AND ("cp"."frequency" = 'yearly'::"text") AND ("make_date"("fd"."year", (EXTRACT(month FROM "cp"."projection_date"))::integer, (EXTRACT(day FROM "cp"."projection_date"))::integer) >= "cp"."projection_date") AND (("cp"."recurrence_end_date" IS NULL) OR ("make_date"("fd"."year", (EXTRACT(month FROM "cp"."projection_date"))::integer, (EXTRACT(day FROM "cp"."projection_date"))::integer) <= "cp"."recurrence_end_date")))
        )
 SELECT DISTINCT "description",
    "amount",
    "due_date",
    "projection_type",
    "category",
    "confidence_level"
   FROM "expanded_projections"
  ORDER BY "due_date";


ALTER VIEW "public"."v_projections_custom" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projections_payroll" WITH ("security_invoker"='true') AS
 WITH "active_clt" AS (
         SELECT "employees"."id" AS "employee_id",
            "employees"."name",
            "employees"."official_salary"
           FROM "public"."employees"
          WHERE (("employees"."is_active" = true) AND ("employees"."contract_type" = 'CLT'::"text") AND ("employees"."official_salary" > (0)::numeric))
        ), "current_dates" AS (
         SELECT "make_date"((EXTRACT(year FROM CURRENT_DATE))::integer, (EXTRACT(month FROM CURRENT_DATE))::integer, 15) AS "adiantamento_date",
            ((("date_trunc"('month'::"text", (CURRENT_DATE)::timestamp with time zone) + '1 mon'::interval) - '1 day'::interval))::"date" AS "salario_date"
        )
 SELECT "e"."employee_id",
    "e"."name",
    'ADIANTAMENTO'::"text" AS "type",
    "d"."adiantamento_date" AS "due_date",
    "round"(("e"."official_salary" * 0.40), 2) AS "amount",
    ('Adiantamento Salarial - '::"text" || "e"."name") AS "description"
   FROM "active_clt" "e",
    "current_dates" "d"
  WHERE ("d"."adiantamento_date" >= CURRENT_DATE)
UNION ALL
 SELECT "e"."employee_id",
    "e"."name",
    'SALARIO'::"text" AS "type",
    "d"."salario_date" AS "due_date",
    "round"(("e"."official_salary" * 0.60), 2) AS "amount",
    ('Saldo de Sal├írio - '::"text" || "e"."name") AS "description"
   FROM "active_clt" "e",
    "current_dates" "d"
  WHERE ("d"."salario_date" >= CURRENT_DATE);


ALTER VIEW "public"."v_projections_payroll" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projections_recurring" WITH ("security_invoker"='true') AS
 WITH "future_months" AS (
         SELECT ("generate_series"("date_trunc"('month'::"text", (CURRENT_DATE)::timestamp with time zone), ("date_trunc"('month'::"text", (CURRENT_DATE)::timestamp with time zone) + '11 mons'::interval), '1 mon'::interval))::"date" AS "ref_date"
        )
 SELECT 'RECURRING'::"text" AS "projection_type",
    "re"."description",
    "make_date"((EXTRACT(year FROM "fm"."ref_date"))::integer, (EXTRACT(month FROM "fm"."ref_date"))::integer,
        CASE
            WHEN (("re"."payment_day")::numeric > EXTRACT(day FROM (("fm"."ref_date" + '1 mon'::interval) - '1 day'::interval))) THEN (EXTRACT(day FROM (("fm"."ref_date" + '1 mon'::interval) - '1 day'::interval)))::integer
            ELSE "re"."payment_day"
        END) AS "due_date",
    "re"."amount",
    'fixed'::"text" AS "confidence_level"
   FROM ("public"."recurring_expenses" "re"
     CROSS JOIN "future_months" "fm")
  WHERE ("re"."active" = true);


ALTER VIEW "public"."v_projections_recurring" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_projections_taxes" WITH ("security_invoker"='true') AS
 WITH "avg_revenue" AS (
         SELECT COALESCE("avg"("invoices"."amount"), (0)::numeric) AS "monthly_avg"
           FROM "public"."invoices"
          WHERE (("invoices"."type" = 'honorario_mensal'::"text") AND (("invoices"."competence")::"text" = ANY (ARRAY[(("to_char"((CURRENT_DATE - '1 mon'::interval), 'MM/YYYY'::"text"))::character varying)::"text", (("to_char"((CURRENT_DATE - '2 mons'::interval), 'MM/YYYY'::"text"))::character varying)::"text", (("to_char"((CURRENT_DATE - '3 mons'::interval), 'MM/YYYY'::"text"))::character varying)::"text"])))
        ), "future_months" AS (
         SELECT ("generate_series"("date_trunc"('month'::"text", (CURRENT_DATE)::timestamp with time zone), ("date_trunc"('month'::"text", (CURRENT_DATE)::timestamp with time zone) + '11 mons'::interval), '1 mon'::interval))::"date" AS "ref_date"
        )
 SELECT 'TAX_RECURRING'::"text" AS "projection_type",
    "tc"."name" AS "description",
    ("fm"."ref_date" + ((("tc"."payment_day" - 1) || ' days'::"text"))::interval) AS "due_date",
        CASE
            WHEN ("tc"."calculation_method" = 'fixed'::"text") THEN "tc"."fixed_amount"
            WHEN ("tc"."calculation_method" = 'revenue_percentage'::"text") THEN ( SELECT ("avg_revenue"."monthly_avg" * "tc"."default_rate")
               FROM "avg_revenue")
            ELSE (0)::numeric
        END AS "amount",
    'high'::"text" AS "confidence_level"
   FROM ("future_months" "fm"
     CROSS JOIN "public"."tax_configurations" "tc")
  WHERE ("tc"."active" = true)
UNION ALL
 SELECT 'TAX_INSTALLMENT'::"text" AS "projection_type",
    "ti"."description",
    "make_date"((EXTRACT(year FROM "fm"."ref_date"))::integer, (EXTRACT(month FROM "fm"."ref_date"))::integer, "ti"."payment_day") AS "due_date",
    "ti"."installment_value" AS "amount",
    'certain'::"text" AS "confidence_level"
   FROM ("public"."tax_installments" "ti"
     JOIN "future_months" "fm" ON ((("fm"."ref_date" >= "date_trunc"('month'::"text", ("ti"."start_date")::timestamp with time zone)) AND ("fm"."ref_date" <= "date_trunc"('month'::"text", ("ti"."end_date")::timestamp with time zone)))))
  WHERE ("ti"."active" = true);


ALTER VIEW "public"."v_projections_taxes" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cash_flow_daily" AS
 SELECT "invoices"."due_date",
    "invoices"."description",
    ("invoices"."amount")::numeric AS "value",
    'RECEIVABLE'::"text" AS "type",
    'CONFIRMED'::"text" AS "status"
   FROM "public"."invoices"
  WHERE (("invoices"."status")::"text" = 'pending'::"text")
UNION ALL
 SELECT "v_projections_payroll"."due_date",
    "v_projections_payroll"."description",
    (- "v_projections_payroll"."amount") AS "value",
    'PAYROLL'::"text" AS "type",
    'PROJECTED'::"text" AS "status"
   FROM "public"."v_projections_payroll"
UNION ALL
 SELECT "v_projections_contractors"."due_date",
    "v_projections_contractors"."description",
    (- "v_projections_contractors"."amount") AS "value",
    'CONTRACTOR'::"text" AS "type",
    'PROJECTED'::"text" AS "status"
   FROM "public"."v_projections_contractors"
UNION ALL
 SELECT "v_projections_taxes"."due_date",
    "v_projections_taxes"."description",
    (- "v_projections_taxes"."amount") AS "value",
    'TAX'::"text" AS "type",
        CASE
            WHEN ("v_projections_taxes"."confidence_level" = 'certain'::"text") THEN 'CONFIRMED'::"text"
            ELSE 'PROJECTED'::"text"
        END AS "status"
   FROM "public"."v_projections_taxes"
UNION ALL
 SELECT "v_projections_recurring"."due_date",
    "v_projections_recurring"."description",
    (- ("v_projections_recurring"."amount")::numeric) AS "value",
    'RECURRING'::"text" AS "type",
    'PROJECTED'::"text" AS "status"
   FROM "public"."v_projections_recurring"
UNION ALL
 SELECT "v_projections_custom"."due_date",
    "v_projections_custom"."description",
        CASE
            WHEN ("v_projections_custom"."projection_type" = 'RECEITA'::"text") THEN ("v_projections_custom"."amount")::numeric
            ELSE (- ("v_projections_custom"."amount")::numeric)
        END AS "value",
    "v_projections_custom"."projection_type" AS "type",
        CASE
            WHEN ("v_projections_custom"."confidence_level" = 'manual'::"text") THEN 'MANUAL'::"text"
            ELSE 'PROJECTED'::"text"
        END AS "status"
   FROM "public"."v_projections_custom";


ALTER VIEW "public"."v_cash_flow_daily" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cash_flow_summary" WITH ("security_invoker"='true') AS
 SELECT ( SELECT COALESCE("sum"("v_balancete"."balance"), (0)::numeric) AS "coalesce"
           FROM "public"."v_balancete"
          WHERE (("v_balancete"."account_code")::"text" = '1.1.1.05'::"text")) AS "bank_balance",
    ( SELECT COALESCE("sum"("v_balancete"."balance"), (0)::numeric) AS "coalesce"
           FROM "public"."v_balancete"
          WHERE (("v_balancete"."account_code")::"text" = '1.1.2.01'::"text")) AS "accounts_receivable",
    ( SELECT COALESCE("sum"("v_balancete"."balance"), (0)::numeric) AS "coalesce"
           FROM "public"."v_balancete"
          WHERE ((("v_balancete"."account_code")::"text" ~~ '1.1.3.04%'::"text") AND ("v_balancete"."is_analytical" = true))) AS "partner_advances",
    ( SELECT COALESCE("sum"("v_balancete"."balance"), (0)::numeric) AS "coalesce"
           FROM "public"."v_balancete"
          WHERE ((("v_balancete"."account_code")::"text" ~~ '3%'::"text") AND ("v_balancete"."is_analytical" = true))) AS "total_revenue",
    ( SELECT COALESCE("sum"("v_balancete"."balance"), (0)::numeric) AS "coalesce"
           FROM "public"."v_balancete"
          WHERE ((("v_balancete"."account_code")::"text" ~~ '4%'::"text") AND ("v_balancete"."is_analytical" = true))) AS "total_expenses";


ALTER VIEW "public"."v_cash_flow_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_cash_flow_summary" IS 'Cash flow summary consuming from Balancete';



CREATE OR REPLACE VIEW "public"."v_client_classification_check" WITH ("security_invoker"='true') AS
 SELECT "id",
    "name",
    "cnpj",
    "cpf",
    "monthly_fee",
    "is_pro_bono",
    "is_barter",
    "is_active",
        CASE
            WHEN ((("monthly_fee" IS NULL) OR ("monthly_fee" = (0)::numeric)) AND (NOT "is_pro_bono") AND (NOT COALESCE("is_barter", false))) THEN 'DEVERIA SER PRO-BONO'::"text"
            WHEN (("monthly_fee" > (0)::numeric) AND "is_pro_bono") THEN 'N├âO DEVERIA SER PRO-BONO'::"text"
            WHEN ("is_barter" AND "is_pro_bono") THEN 'BARTER E PRO-BONO CONFLITANTE'::"text"
            ELSE 'OK'::"text"
        END AS "classification_status",
        CASE
            WHEN ((("monthly_fee" IS NULL) OR ("monthly_fee" = (0)::numeric)) AND (NOT COALESCE("is_barter", false))) THEN 'PRO-BONO'::"text"
            WHEN COALESCE("is_barter", false) THEN 'BARTER'::"text"
            ELSE 'REGULAR'::"text"
        END AS "expected_classification"
   FROM "public"."clients"
  WHERE ("is_active" = true);


ALTER VIEW "public"."v_client_classification_check" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_client_classification_check" IS 'Verifica inconsist├¬ncias na classifica├º├úo de clientes (Pro-Bono, Barter, Regular)';



CREATE OR REPLACE VIEW "public"."v_client_opening_balance_summary" WITH ("security_invoker"='true') AS
 SELECT "c"."id" AS "client_id",
    "c"."name" AS "client_name",
    "c"."cnpj",
    "count"("cob"."id") AS "total_competences",
    "sum"("cob"."amount") AS "total_amount",
    "sum"("cob"."paid_amount") AS "total_paid",
    "sum"(("cob"."amount" - "cob"."paid_amount")) AS "total_pending",
    "count"(
        CASE
            WHEN (("cob"."status")::"text" = 'pending'::"text") THEN 1
            ELSE NULL::integer
        END) AS "pending_count",
    "count"(
        CASE
            WHEN (("cob"."status")::"text" = 'paid'::"text") THEN 1
            ELSE NULL::integer
        END) AS "paid_count",
    "count"(
        CASE
            WHEN (("cob"."status")::"text" = 'partial'::"text") THEN 1
            ELSE NULL::integer
        END) AS "partial_count",
    "min"("cob"."due_date") AS "oldest_due_date",
    "max"("cob"."due_date") AS "newest_due_date"
   FROM ("public"."clients" "c"
     LEFT JOIN "public"."client_opening_balance" "cob" ON (("c"."id" = "cob"."client_id")))
  GROUP BY "c"."id", "c"."name", "c"."cnpj";


ALTER VIEW "public"."v_client_opening_balance_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_client_opening_balance_summary" IS 'Summary view of opening balance per client with aggregated statistics';



CREATE OR REPLACE VIEW "public"."v_clients_for_negotiation" WITH ("security_invoker"='true') AS
 SELECT "c"."id" AS "client_id",
    "c"."name" AS "client_name",
    "c"."cnpj",
    "c"."cpf",
    "c"."email",
    "c"."phone",
    "c"."uf",
    "c"."municipio",
    "debt"."total_debt",
    "debt"."overdue_amount",
    "debt"."overdue_days",
    "debt"."oldest_due_date",
    "debt"."pending_invoices",
    "debt"."pending_opening_balance",
    ( SELECT "count"(*) AS "count"
           FROM "public"."client_contacts" "cc"
          WHERE (("cc"."client_id" = "c"."id") AND ("cc"."is_valid" = true))) AS "contact_count",
    ( SELECT "json_agg"("json_build_object"('id', "cc"."id", 'type', "cc"."contact_type", 'value', "cc"."contact_value", 'name', "cc"."contact_name", 'is_primary', "cc"."is_primary", 'is_whatsapp', "cc"."is_whatsapp")) AS "json_agg"
           FROM "public"."client_contacts" "cc"
          WHERE (("cc"."client_id" = "c"."id") AND ("cc"."is_valid" = true))) AS "contacts",
    ( SELECT "max"("nch"."created_at") AS "max"
           FROM "public"."negotiation_contact_history" "nch"
          WHERE ("nch"."client_id" = "c"."id")) AS "last_contact_at",
    ( SELECT "count"(*) AS "count"
           FROM "public"."debt_negotiations" "dn"
          WHERE (("dn"."client_id" = "c"."id") AND ("dn"."status" = ANY (ARRAY['active'::"text", 'pending_approval'::"text", 'approved'::"text"])))) AS "active_negotiations"
   FROM ("public"."clients" "c"
     CROSS JOIN LATERAL "public"."calculate_client_debt"("c"."id") "debt"("total_invoices", "total_opening_balance", "total_debt", "overdue_amount", "overdue_days", "oldest_due_date", "pending_invoices", "pending_opening_balance"))
  WHERE (("c"."is_active" = true) AND ("debt"."total_debt" > (0)::numeric))
  ORDER BY "debt"."overdue_days" DESC, "debt"."total_debt" DESC;


ALTER VIEW "public"."v_clients_for_negotiation" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_clients_for_negotiation" IS 'Clientes com d├¡vidas pendentes e informa├º├Áes para negocia├º├úo';



CREATE OR REPLACE VIEW "public"."v_clients_pending_adjustment" WITH ("security_invoker"='true') AS
 WITH "current_wage" AS (
         SELECT "public"."get_minimum_wage_at_date"() AS "value"
        )
 SELECT "c"."id",
    "c"."name",
    "c"."cnpj",
    "c"."monthly_fee" AS "current_fee",
    "c"."fee_in_minimum_wages",
    "c"."last_fee_adjustment_date",
    "c"."last_adjustment_minimum_wage",
    "cw"."value" AS "current_minimum_wage",
        CASE
            WHEN (("c"."fee_in_minimum_wages" IS NOT NULL) AND ("c"."fee_in_minimum_wages" > (0)::numeric)) THEN "round"(("c"."fee_in_minimum_wages" * "cw"."value"), 2)
            ELSE "c"."monthly_fee"
        END AS "expected_fee",
        CASE
            WHEN (("c"."fee_in_minimum_wages" IS NOT NULL) AND ("c"."fee_in_minimum_wages" > (0)::numeric)) THEN ("round"(("c"."fee_in_minimum_wages" * "cw"."value"), 2) - "c"."monthly_fee")
            ELSE (0)::numeric
        END AS "fee_difference",
        CASE
            WHEN ("c"."last_adjustment_minimum_wage" IS NULL) THEN 'NUNCA_AJUSTADO'::"text"
            WHEN ("c"."last_adjustment_minimum_wage" < "cw"."value") THEN 'REAJUSTE_PENDENTE'::"text"
            ELSE 'ATUALIZADO'::"text"
        END AS "adjustment_status",
    "c"."auto_adjust_by_minimum_wage"
   FROM ("public"."clients" "c"
     CROSS JOIN "current_wage" "cw")
  WHERE (("c"."is_active" = true) AND (NOT COALESCE("c"."is_pro_bono", false)) AND (NOT COALESCE("c"."is_barter", false)) AND ("c"."monthly_fee" > (0)::numeric))
  ORDER BY
        CASE
            WHEN ("c"."last_adjustment_minimum_wage" IS NULL) THEN 0
            WHEN ("c"."last_adjustment_minimum_wage" < "cw"."value") THEN 1
            ELSE 2
        END, "c"."name";


ALTER VIEW "public"."v_clients_pending_adjustment" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_clients_pending_adjustment" IS 'Lista clientes que precisam de reajuste de honor├írios';



CREATE OR REPLACE VIEW "public"."v_contas_a_receber" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "year",
    "month",
    "total_debit",
    "total_credit",
    "balance" AS "saldo"
   FROM "public"."v_balancete"
  WHERE (("account_code")::"text" = '1.1.2.01'::"text");


ALTER VIEW "public"."v_contas_a_receber" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_contas_a_receber" IS 'Accounts receivable from accounting entries (via Balancete)';



CREATE OR REPLACE VIEW "public"."v_contracts_complete" WITH ("security_invoker"='true') AS
 SELECT "c"."id",
    "c"."contract_number",
    "c"."contract_type",
    "c"."status",
    "c"."start_date",
    "c"."end_date",
    "c"."monthly_fee",
    "c"."payment_day",
    "c"."signature_status",
    "c"."created_at",
    "cl"."id" AS "client_id",
    "cl"."name" AS "client_name",
    "cl"."cnpj" AS "client_cnpj",
    "cl"."email" AS "client_email",
    "cl"."phone" AS "client_phone",
    "p"."proposal_number",
    "p"."status" AS "proposal_status",
    ( SELECT "contract_addendums"."addendum_number"
           FROM "public"."contract_addendums"
          WHERE ("contract_addendums"."contract_id" = "c"."id")
          ORDER BY "contract_addendums"."created_at" DESC
         LIMIT 1) AS "last_addendum",
    ( SELECT "responsibility_letters"."status"
           FROM "public"."responsibility_letters"
          WHERE (("responsibility_letters"."contract_id" = "c"."id") AND (("responsibility_letters"."reference_year")::numeric = EXTRACT(year FROM CURRENT_DATE)))
          ORDER BY "responsibility_letters"."created_at" DESC
         LIMIT 1) AS "current_year_letter_status",
    ( SELECT "contract_terminations"."termination_number"
           FROM "public"."contract_terminations"
          WHERE (("contract_terminations"."contract_id" = "c"."id") AND ("contract_terminations"."status" <> 'cancelled'::"text"))
         LIMIT 1) AS "termination_number"
   FROM (("public"."accounting_contracts" "c"
     LEFT JOIN "public"."clients" "cl" ON (("c"."client_id" = "cl"."id")))
     LEFT JOIN "public"."service_proposals" "p" ON (("c"."proposal_id" = "p"."id")));


ALTER VIEW "public"."v_contracts_complete" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_debt_confessions_summary" WITH ("security_invoker"='true') AS
 SELECT "dc"."id",
    "dc"."confession_number",
    "dc"."client_id",
    "dc"."total_debt",
    "dc"."discount_percentage",
    "dc"."discount_amount",
    "dc"."final_amount",
    "dc"."installments",
    "dc"."installment_value",
    "dc"."first_due_date",
    "dc"."payment_day",
    "dc"."invoice_ids",
    "dc"."content",
    "dc"."document_url",
    "dc"."signed_document_url",
    "dc"."signature_status",
    "dc"."signed_at",
    "dc"."signed_by",
    "dc"."status",
    "dc"."paid_installments",
    "dc"."paid_amount",
    "dc"."last_payment_date",
    "dc"."defaulted_at",
    "dc"."defaulted_reason",
    "dc"."notes",
    "dc"."created_by",
    "dc"."created_at",
    "dc"."updated_at",
    "c"."name" AS "client_name",
    "c"."cnpj" AS "client_cnpj",
    COALESCE(( SELECT "count"(*) AS "count"
           FROM "public"."debt_confession_installments" "dci"
          WHERE (("dci"."confession_id" = "dc"."id") AND ("dci"."status" = 'paid'::"text"))), (0)::bigint) AS "paid_count",
    COALESCE(( SELECT "count"(*) AS "count"
           FROM "public"."debt_confession_installments" "dci"
          WHERE (("dci"."confession_id" = "dc"."id") AND ("dci"."status" = 'overdue'::"text"))), (0)::bigint) AS "overdue_count",
    COALESCE(( SELECT "sum"("dci"."paid_amount") AS "sum"
           FROM "public"."debt_confession_installments" "dci"
          WHERE ("dci"."confession_id" = "dc"."id")), (0)::numeric) AS "total_paid",
    COALESCE(( SELECT "min"("dci"."due_date") AS "min"
           FROM "public"."debt_confession_installments" "dci"
          WHERE (("dci"."confession_id" = "dc"."id") AND ("dci"."status" = ANY (ARRAY['pending'::"text", 'overdue'::"text"])))), NULL::"date") AS "next_due_date"
   FROM ("public"."debt_confessions" "dc"
     LEFT JOIN "public"."clients" "c" ON (("dc"."client_id" = "c"."id")));


ALTER VIEW "public"."v_debt_confessions_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_despesas" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "year",
    "month",
    "total_debit",
    "total_credit",
    "balance" AS "saldo"
   FROM "public"."v_balancete"
  WHERE ((("account_code")::"text" ~~ '4%'::"text") AND ("is_analytical" = true));


ALTER VIEW "public"."v_despesas" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_despesas" IS 'Expense accounts from accounting entries (via Balancete)';



CREATE OR REPLACE VIEW "public"."v_dre_mensal" WITH ("security_invoker"='true') AS
 WITH "receitas" AS (
         SELECT "to_char"(("ae"."entry_date")::timestamp with time zone, 'YYYY-MM'::"text") AS "competencia",
            "coa"."code",
            "coa"."name",
            "sum"("ael"."credit") AS "valor"
           FROM (("public"."accounting_entry_lines" "ael"
             JOIN "public"."accounting_entries" "ae" ON (("ae"."id" = "ael"."entry_id")))
             JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "ael"."account_id")))
          WHERE ((("coa"."code")::"text" ~~ '3.%'::"text") AND ("ael"."credit" > (0)::numeric))
          GROUP BY ("to_char"(("ae"."entry_date")::timestamp with time zone, 'YYYY-MM'::"text")), "coa"."code", "coa"."name"
        ), "despesas" AS (
         SELECT "to_char"(("ae"."entry_date")::timestamp with time zone, 'YYYY-MM'::"text") AS "competencia",
            "left"(("coa"."code")::"text", 3) AS "grupo",
            "sum"("ael"."debit") AS "valor"
           FROM (("public"."accounting_entry_lines" "ael"
             JOIN "public"."accounting_entries" "ae" ON (("ae"."id" = "ael"."entry_id")))
             JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "ael"."account_id")))
          WHERE ((("coa"."code")::"text" ~~ '4.%'::"text") AND ("ael"."debit" > (0)::numeric))
          GROUP BY ("to_char"(("ae"."entry_date")::timestamp with time zone, 'YYYY-MM'::"text")), ("left"(("coa"."code")::"text", 3))
        ), "totais" AS (
         SELECT "receitas"."competencia",
            "sum"("receitas"."valor") AS "total_receitas"
           FROM "receitas"
          GROUP BY "receitas"."competencia"
        )
 SELECT "r"."competencia",
    "r"."code" AS "conta",
    "r"."name" AS "descricao",
    "r"."valor",
        CASE
            WHEN ("t"."total_receitas" > (0)::numeric) THEN "round"((("r"."valor" / "t"."total_receitas") * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "av_percentual",
    'RECEITA'::"text" AS "tipo"
   FROM ("receitas" "r"
     JOIN "totais" "t" ON (("t"."competencia" = "r"."competencia")))
UNION ALL
 SELECT "d"."competencia",
    "d"."grupo" AS "conta",
        CASE "d"."grupo"
            WHEN '4.1'::"text" THEN 'Despesas Operacionais'::"text"
            WHEN '4.2'::"text" THEN 'Despesas com Pessoal'::"text"
            WHEN '4.3'::"text" THEN 'Despesas Financeiras'::"text"
            WHEN '4.4'::"text" THEN 'Impostos e Taxas'::"text"
            ELSE 'Outras Despesas'::"text"
        END AS "descricao",
    "d"."valor",
        CASE
            WHEN ("t"."total_receitas" > (0)::numeric) THEN "round"((("d"."valor" / "t"."total_receitas") * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "av_percentual",
    'DESPESA'::"text" AS "tipo"
   FROM ("despesas" "d"
     JOIN "totais" "t" ON (("t"."competencia" = "d"."competencia")))
  ORDER BY 1, 6, 2;


ALTER VIEW "public"."v_dre_mensal" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_dre_summary" WITH ("security_invoker"='true') AS
 SELECT "year",
    "month",
    "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '3%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) AS "receitas",
    "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '4%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) AS "despesas",
    ("sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '3%'::"text") THEN "balance"
            ELSE (0)::numeric
        END) - "sum"(
        CASE
            WHEN (("account_code")::"text" ~~ '4%'::"text") THEN "balance"
            ELSE (0)::numeric
        END)) AS "resultado"
   FROM "public"."v_balancete"
  WHERE ("is_analytical" = true)
  GROUP BY "year", "month"
  ORDER BY "year", "month";


ALTER VIEW "public"."v_dre_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_dre_summary" IS 'DRE summary consuming from Balancete';



CREATE OR REPLACE VIEW "public"."v_honorarios_por_cliente_ano" WITH ("security_invoker"='true') AS
 SELECT "c"."id" AS "client_id",
    "c"."name" AS "client_name",
    SUBSTRING("cob"."competence" FROM 4 FOR 4) AS "ano",
    "count"(*) FILTER (WHERE (("cob"."fee_type")::"text" = 'monthly'::"text")) AS "honorarios_mensais",
    "count"(*) FILTER (WHERE (("cob"."fee_type")::"text" = 'thirteenth'::"text")) AS "decimo_terceiro",
    "count"(*) FILTER (WHERE (("cob"."fee_type")::"text" <> ALL (ARRAY[('monthly'::character varying)::"text", ('thirteenth'::character varying)::"text"]))) AS "outros_honorarios",
    "sum"("cob"."amount") AS "total_valor",
    "sum"(
        CASE
            WHEN (("cob"."status")::"text" = 'pending'::"text") THEN "cob"."amount"
            ELSE (0)::numeric
        END) AS "valor_pendente"
   FROM ("public"."clients" "c"
     LEFT JOIN "public"."client_opening_balance" "cob" ON (("c"."id" = "cob"."client_id")))
  WHERE ("cob"."id" IS NOT NULL)
  GROUP BY "c"."id", "c"."name", (SUBSTRING("cob"."competence" FROM 4 FOR 4))
  ORDER BY "c"."name", (SUBSTRING("cob"."competence" FROM 4 FOR 4));


ALTER VIEW "public"."v_honorarios_por_cliente_ano" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_honorarios_por_cliente_ano" IS 'Resumo de honor├írios por cliente e ano, separando mensais, 13┬║ e outros';



CREATE OR REPLACE VIEW "public"."v_invoices_with_13th" WITH ("security_invoker"='true') AS
 SELECT "i"."id",
    "i"."client_id",
    "i"."competence",
    "i"."amount",
    "i"."due_date",
    "i"."status",
    "i"."paid_date",
    "i"."paid_amount",
    "i"."boleto_digitable_line",
    "i"."external_charge_id",
    "i"."notes",
    "i"."created_at",
    "i"."updated_at",
    "i"."boleto_url",
    "i"."boleto_barcode",
    "i"."pix_qrcode",
    "i"."pix_copy_paste",
    "i"."pix_txid",
    "i"."payment_method",
    "i"."payment_link",
    "i"."created_by",
    "i"."revenue_type_id",
    "i"."calculation_base",
    "i"."calculated_amount",
    "i"."fine_amount",
    "i"."interest_amount",
    "i"."total_received",
    "i"."discount_amount",
    "c"."name" AS "client_name",
    "c"."has_13th_fee",
        CASE
            WHEN (("i"."competence")::"text" ~~ '13/%'::"text") THEN true
            ELSE false
        END AS "is_thirteenth_fee",
        CASE
            WHEN (("i"."competence")::"text" ~~ '13/%'::"text") THEN '13┬║ Honor├írio'::"text"
            ELSE 'Honor├írio Mensal'::"text"
        END AS "fee_type"
   FROM ("public"."invoices" "i"
     JOIN "public"."clients" "c" ON (("c"."id" = "i"."client_id")))
  WHERE ("c"."is_active" = true);


ALTER VIEW "public"."v_invoices_with_13th" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_invoices_with_13th" IS 'Faturas com identifica├º├úo de 13┬║ honor├írio';



CREATE OR REPLACE VIEW "public"."v_minimum_wage_history" WITH ("security_invoker"='true') AS
 SELECT "id",
    "effective_date",
    "end_date",
    "value",
    "source",
    "notes",
        CASE
            WHEN ("end_date" IS NULL) THEN 'VIGENTE'::"text"
            WHEN ("end_date" >= CURRENT_DATE) THEN 'VIGENTE'::"text"
            ELSE 'ENCERRADO'::"text"
        END AS "status",
        CASE
            WHEN ("end_date" IS NULL) THEN NULL::integer
            ELSE (("end_date" - "effective_date") + 1)
        END AS "days_in_effect",
    "created_at"
   FROM "public"."minimum_wage_history"
  ORDER BY "effective_date" DESC;


ALTER VIEW "public"."v_minimum_wage_history" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_minimum_wage_history" IS 'Hist├│rico de sal├írios m├¡nimos com status de vig├¬ncia';



CREATE OR REPLACE VIEW "public"."v_payroll_summary" WITH ("security_invoker"='true') AS
 SELECT "year",
    "month",
    "count"(*) AS "total_folhas",
    "sum"(
        CASE
            WHEN (("status")::"text" = 'draft'::"text") THEN 1
            ELSE 0
        END) AS "rascunhos",
    "sum"(
        CASE
            WHEN (("status")::"text" = 'provisioned'::"text") THEN 1
            ELSE 0
        END) AS "provisionadas",
    "sum"(
        CASE
            WHEN (("status")::"text" = 'paid'::"text") THEN 1
            ELSE 0
        END) AS "pagas",
    "sum"("total_bruto") AS "total_bruto_mes",
    "sum"("total_inss") AS "total_inss_mes",
    "sum"("total_irrf") AS "total_irrf_mes",
    "sum"("total_liquido") AS "total_liquido_mes"
   FROM "public"."payrolls"
  WHERE ("deleted_at" IS NULL)
  GROUP BY "year", "month"
  ORDER BY "year" DESC, "month" DESC;


ALTER VIEW "public"."v_payroll_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_pending_responsibility_letters" WITH ("security_invoker"='true') AS
 SELECT "c"."id" AS "contract_id",
    "c"."contract_number",
    "cl"."id" AS "client_id",
    "cl"."name" AS "client_name",
    "cl"."cnpj" AS "client_cnpj",
    (EXTRACT(year FROM CURRENT_DATE))::integer AS "reference_year",
    COALESCE("rl"."status", 'not_created'::"text") AS "letter_status",
    "rl"."id" AS "letter_id"
   FROM (("public"."accounting_contracts" "c"
     JOIN "public"."clients" "cl" ON (("c"."client_id" = "cl"."id")))
     LEFT JOIN "public"."responsibility_letters" "rl" ON ((("rl"."contract_id" = "c"."id") AND (("rl"."reference_year")::numeric = EXTRACT(year FROM CURRENT_DATE)))))
  WHERE (("c"."status" = 'active'::"text") AND ("c"."requires_responsibility_letter" = true) AND (("rl"."id" IS NULL) OR ("rl"."status" <> ALL (ARRAY['signed'::"text", 'archived'::"text"]))));


ALTER VIEW "public"."v_pending_responsibility_letters" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_receitas" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "year",
    "month",
    "total_debit",
    "total_credit",
    "balance" AS "saldo"
   FROM "public"."v_balancete"
  WHERE ((("account_code")::"text" ~~ '3%'::"text") AND ("is_analytical" = true));


ALTER VIEW "public"."v_receitas" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_receitas" IS 'Revenue accounts from accounting entries (via Balancete)';



CREATE OR REPLACE VIEW "public"."v_rentabilidade_cliente" WITH ("security_invoker"='true') AS
 WITH "receita_cliente" AS (
         SELECT "c"."id" AS "cliente_id",
            "c"."name" AS "cliente_nome",
            COALESCE("sum"("i"."paid_amount"), (0)::numeric) AS "receita_total",
            "count"("i"."id") AS "qtd_faturas"
           FROM ("public"."clients" "c"
             LEFT JOIN "public"."invoices" "i" ON ((("i"."client_id" = "c"."id") AND (("i"."status")::"text" = 'paid'::"text"))))
          GROUP BY "c"."id", "c"."name"
        ), "total_despesas" AS (
         SELECT COALESCE("sum"("ael"."debit"), (0)::numeric) AS "total"
           FROM ("public"."accounting_entry_lines" "ael"
             JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "ael"."account_id")))
          WHERE ((("coa"."code")::"text" ~~ '4.%'::"text") AND ("ael"."debit" > (0)::numeric))
        ), "total_clientes" AS (
         SELECT "count"(DISTINCT "receita_cliente"."cliente_id") AS "qtd"
           FROM "receita_cliente"
          WHERE ("receita_cliente"."receita_total" > (0)::numeric)
        )
 SELECT "rc"."cliente_id",
    "rc"."cliente_nome",
    "rc"."receita_total",
    "rc"."qtd_faturas",
    "round"(("td"."total" / (NULLIF("tc"."qtd", 0))::numeric), 2) AS "custo_alocado",
    "round"(("rc"."receita_total" - ("td"."total" / (NULLIF("tc"."qtd", 0))::numeric)), 2) AS "lucro_estimado",
        CASE
            WHEN ("rc"."receita_total" > (0)::numeric) THEN "round"(((("rc"."receita_total" - ("td"."total" / (NULLIF("tc"."qtd", 0))::numeric)) / "rc"."receita_total") * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "margem_percentual"
   FROM (("receita_cliente" "rc"
     CROSS JOIN "total_despesas" "td")
     CROSS JOIN "total_clientes" "tc")
  WHERE ("rc"."receita_total" > (0)::numeric)
  ORDER BY "rc"."receita_total" DESC;


ALTER VIEW "public"."v_rentabilidade_cliente" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_saldo_banco" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "year",
    "month",
    "total_debit",
    "total_credit",
    "balance" AS "saldo"
   FROM "public"."v_balancete"
  WHERE (("account_code")::"text" = '1.1.1.05'::"text");


ALTER VIEW "public"."v_saldo_banco" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_saldo_banco" IS 'Bank balance from accounting entries (via Balancete)';



CREATE OR REPLACE VIEW "public"."v_tracking_summary" WITH ("security_invoker"='true') AS
 SELECT "tipo",
    "competencia_ano",
    "competencia_mes",
    "count"(*) AS "total_lancamentos",
    "count"(*) FILTER (WHERE ("foi_duplicado" = true)) AS "duplicados",
    "count"(*) FILTER (WHERE ("deleted_at" IS NULL)) AS "ativos"
   FROM "public"."accounting_entry_tracking"
  GROUP BY "tipo", "competencia_ano", "competencia_mes"
  ORDER BY "competencia_ano" DESC, "competencia_mes" DESC, "tipo";


ALTER VIEW "public"."v_tracking_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_trial_balance" WITH ("security_invoker"='true') AS
 WITH "period_movements" AS (
         SELECT "c"."id",
            "c"."code",
            "c"."name",
            "c"."account_type",
            "c"."nature",
            "c"."level",
            "c"."parent_id",
            "c"."is_analytical",
            COALESCE("sum"("i"."debit"), (0)::numeric) AS "period_debit",
            COALESCE("sum"("i"."credit"), (0)::numeric) AS "period_credit",
            "count"(DISTINCT "i"."entry_id") AS "entry_count"
           FROM (("public"."chart_of_accounts" "c"
             LEFT JOIN "public"."accounting_entry_items" "i" ON (("i"."account_id" = "c"."id")))
             LEFT JOIN "public"."accounting_entries" "e" ON ((("e"."id" = "i"."entry_id") AND ("e"."is_draft" = false))))
          GROUP BY "c"."id", "c"."code", "c"."name", "c"."account_type", "c"."nature", "c"."level", "c"."parent_id", "c"."is_analytical"
        )
 SELECT "id",
    "code",
    "name",
    "account_type",
    "nature",
    "level",
    "parent_id",
    "is_analytical",
    "period_debit",
    "period_credit",
    "entry_count",
        CASE
            WHEN (("nature")::"text" = 'DEVEDORA'::"text") THEN ("period_debit" - "period_credit")
            ELSE ("period_credit" - "period_debit")
        END AS "balance"
   FROM "period_movements" "pm"
  WHERE ("is_analytical" = true)
  ORDER BY "code";


ALTER VIEW "public"."v_trial_balance" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_trial_balance" IS 'Balancete de verifica├º├úo';



CREATE TABLE IF NOT EXISTS "public"."variable_fee_calculations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "variable_fee_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "reference_month" "date" NOT NULL,
    "revenue_base" numeric(15,2) NOT NULL,
    "percentage_rate" numeric(5,2) NOT NULL,
    "calculated_amount" numeric(15,2) NOT NULL,
    "invoice_id" "uuid",
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "employee_commission" numeric(15,2) DEFAULT 0,
    "employee_commission_paid" boolean DEFAULT false,
    "employee_commission_paid_at" timestamp with time zone,
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."variable_fee_calculations" OWNER TO "postgres";


COMMENT ON TABLE "public"."variable_fee_calculations" IS 'Honor├írios vari├íveis calculados por m├¬s';



CREATE TABLE IF NOT EXISTS "public"."video_branding_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "config_name" "text" DEFAULT 'default'::"text",
    "logo_url" "text",
    "logo_position" "text" DEFAULT 'bottom-right'::"text",
    "logo_size" "text" DEFAULT 'small'::"text",
    "primary_color" "text" DEFAULT '#1e3a5f'::"text",
    "secondary_color" "text" DEFAULT '#4a90d9'::"text",
    "accent_color" "text" DEFAULT '#f5a623'::"text",
    "text_color" "text" DEFAULT '#ffffff'::"text",
    "intro_video_url" "text",
    "intro_duration" integer DEFAULT 3,
    "outro_video_url" "text",
    "outro_duration" integer DEFAULT 3,
    "default_music_url" "text",
    "music_volume" numeric(3,2) DEFAULT 0.3,
    "font_family" "text" DEFAULT 'Montserrat'::"text",
    "title_font_size" integer DEFAULT 48,
    "subtitle_font_size" integer DEFAULT 32,
    "is_active" boolean DEFAULT true,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."video_branding_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."video_branding_config" IS 'Configura├º├úo de branding para v├¡deos';



CREATE OR REPLACE VIEW "public"."vw_all_labor_alerts" WITH ("security_invoker"='true') AS
 SELECT 'employee'::"text" AS "source",
    "e"."id" AS "source_id",
    "e"."name",
    'RISCO TRABALHISTA'::"text" AS "alert_type",
    'critical'::"text" AS "severity",
    'Pagamento n├úo oficial detectado'::"text" AS "title",
    "e"."labor_risk_notes" AS "description",
    'Regularizar pagamento ou converter para PJ'::"text" AS "recommendation"
   FROM "public"."employees" "e"
  WHERE (("e"."is_active" = true) AND ("e"."unofficial_salary" > (0)::numeric))
UNION ALL
 SELECT 'provider'::"text" AS "source",
    "sp"."id" AS "source_id",
    "sp"."name",
    'COMPLIANCE'::"text" AS "alert_type",
    'critical'::"text" AS "severity",
    'Prestador sem contrato assinado'::"text" AS "title",
    'Prestador de servi├ºos sem contrato formal pode gerar v├¡nculo trabalhista'::"text" AS "description",
    'Gerar e assinar contrato de presta├º├úo de servi├ºos'::"text" AS "recommendation"
   FROM "public"."service_providers" "sp"
  WHERE (("sp"."is_active" = true) AND ("sp"."contract_signed" = false))
UNION ALL
 SELECT 'provider'::"text" AS "source",
    "sp"."id" AS "source_id",
    "sp"."name",
    'COMPLIANCE'::"text" AS "alert_type",
    'warning'::"text" AS "severity",
    'Prestador sem nota fiscal recente'::"text" AS "title",
    'N├úo h├í registro de NF nos ├║ltimos 45 dias'::"text" AS "description",
    'Exigir emiss├úo de NF antes do pr├│ximo pagamento'::"text" AS "recommendation"
   FROM "public"."service_providers" "sp"
  WHERE (("sp"."is_active" = true) AND ("sp"."requires_invoice" = true) AND (("sp"."last_invoice_date" IS NULL) OR ("sp"."last_invoice_date" < (CURRENT_DATE - '45 days'::interval))))
UNION ALL
 SELECT 'employee'::"text" AS "source",
    "e"."id" AS "source_id",
    "e"."name",
    'F├ëRIAS'::"text" AS "alert_type",
    'warning'::"text" AS "severity",
    'F├®rias podem estar vencendo'::"text" AS "title",
    'Funcion├írio h├í mais de 12 meses sem f├®rias registradas'::"text" AS "description",
    'Verificar per├¡odo aquisitivo e programar f├®rias'::"text" AS "recommendation"
   FROM "public"."employees" "e"
  WHERE (("e"."is_active" = true) AND ("e"."contract_type" = 'CLT'::"text") AND (("e"."last_vacation_date" IS NULL) OR ("e"."last_vacation_date" < (CURRENT_DATE - '1 year'::interval))));


ALTER VIEW "public"."vw_all_labor_alerts" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_all_labor_alerts" IS 'Consolida├º├úo de todos os alertas trabalhistas e de compliance';



CREATE OR REPLACE VIEW "public"."vw_agent_dashboard" WITH ("security_invoker"='true') AS
 SELECT "agent_id",
    "name" AS "agent_name",
    "role",
    ( SELECT "count"(*) AS "count"
           FROM "public"."ai_page_agents" "pa"
          WHERE ("pa"."primary_agent_id" = "a"."agent_id")) AS "pages_managed",
    ( SELECT "jsonb_agg"("pa"."page_name") AS "jsonb_agg"
           FROM "public"."ai_page_agents" "pa"
          WHERE ("pa"."primary_agent_id" = "a"."agent_id")) AS "pages",
        CASE "agent_id"
            WHEN 'cicero'::"text" THEN ( SELECT "count"(*) AS "count"
               FROM "public"."payroll"
              WHERE ("payroll"."status" <> 'fechada'::"text"))
            WHEN 'milton'::"text" THEN ( SELECT "count"(*) AS "count"
               FROM "public"."purchase_lists"
              WHERE ("purchase_lists"."approval_status" = 'pending'::"text"))
            WHEN 'helena'::"text" THEN ( SELECT "count"(*) AS "count"
               FROM "public"."ai_meetings"
              WHERE ("ai_meetings"."status" = 'scheduled'::"text"))
            WHEN 'advocato'::"text" THEN ( SELECT "count"(*) AS "count"
               FROM "public"."vw_all_labor_alerts")
            WHEN 'atlas'::"text" THEN ( SELECT "count"(*) AS "count"
               FROM "public"."ai_pending_questions"
              WHERE ("ai_pending_questions"."status" = 'pending'::"text"))
            ELSE (0)::bigint
        END AS "pending_tasks",
        CASE "agent_id"
            WHEN 'cicero'::"text" THEN 'Dr. C├¡cero est├í monitorando a contabilidade e folha de pagamento'::"text"
            WHEN 'milton'::"text" THEN 'Prof. Milton est├í analisando finan├ºas e or├ºamentos'::"text"
            WHEN 'helena'::"text" THEN 'Dra. Helena est├í coordenando gest├úo e reuni├Áes'::"text"
            WHEN 'advocato'::"text" THEN 'Dr. Advocato est├í monitorando riscos trabalhistas'::"text"
            WHEN 'empresario'::"text" THEN 'Sr. Empres├írio est├í avaliando estruturas societ├írias'::"text"
            WHEN 'atlas'::"text" THEN 'Atlas est├í aprendendo padr├Áes de transa├º├Áes'::"text"
            ELSE 'Agente ativo'::"text"
        END AS "current_status"
   FROM "public"."ai_agents" "a"
  WHERE ("is_active" = true)
  ORDER BY "agent_id";


ALTER VIEW "public"."vw_agent_dashboard" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_agent_dashboard" IS 'Vis├úo geral do status de cada agente IA';



CREATE OR REPLACE VIEW "public"."vw_ai_company_context" WITH ("security_invoker"='true') AS
 SELECT 'company'::"text" AS "entity_type",
    "cp"."id",
    "cp"."name",
    "cp"."description",
    "cp"."notes" AS "additional_info"
   FROM "public"."company_profile" "cp"
UNION ALL
 SELECT 'partner'::"text" AS "entity_type",
    "p"."id",
    "p"."name",
    "p"."description",
    "p"."expense_patterns" AS "additional_info"
   FROM "public"."company_partners" "p"
  WHERE ("p"."is_active" = true)
UNION ALL
 SELECT 'family'::"text" AS "entity_type",
    "f"."id",
    ((((("f"."name" || ' ('::"text") || "f"."relationship") || ' de '::"text") || "p"."name") || ')'::"text") AS "name",
    "f"."description",
    "f"."related_expenses" AS "additional_info"
   FROM ("public"."partner_family" "f"
     JOIN "public"."company_partners" "p" ON (("f"."partner_id" = "p"."id")))
  WHERE ("f"."is_active" = true)
UNION ALL
 SELECT 'employee'::"text" AS "entity_type",
    "e"."id",
    ((("e"."name" || ' ('::"text") || "e"."department") || ')'::"text") AS "name",
    "e"."description",
    "e"."payment_patterns" AS "additional_info"
   FROM "public"."employees" "e"
  WHERE ("e"."is_active" = true)
UNION ALL
 SELECT 'property'::"text" AS "entity_type",
    "pp"."id",
    (("pp"."name" || ' - '::"text") || "p"."name") AS "name",
    "pp"."description",
    "pp"."expense_patterns" AS "additional_info"
   FROM ("public"."partner_properties" "pp"
     JOIN "public"."company_partners" "p" ON (("pp"."partner_id" = "p"."id")))
  WHERE ("pp"."is_active" = true)
UNION ALL
 SELECT 'vehicle'::"text" AS "entity_type",
    "v"."id",
    (("v"."name" || ' - '::"text") || "p"."name") AS "name",
    "v"."description",
    "v"."expense_patterns" AS "additional_info"
   FROM ("public"."partner_vehicles" "v"
     JOIN "public"."company_partners" "p" ON (("v"."partner_id" = "p"."id")))
  WHERE ("v"."is_active" = true);


ALTER VIEW "public"."vw_ai_company_context" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_ai_company_context" IS 'Contexto completo da empresa para uso pela IA na classifica├º├úo de transa├º├Áes';



CREATE OR REPLACE VIEW "public"."vw_labor_risks_with_solutions" WITH ("security_invoker"='true') AS
 SELECT "a"."id" AS "alert_id",
    "a"."alert_type",
    "a"."severity",
    "a"."title",
    "a"."description",
    "a"."recommendation",
        CASE
            WHEN ("a"."alert_type" = 'unofficial_salary'::"text") THEN 'pagamento_nao_registrado'::"text"
            WHEN ("a"."alert_type" = 'high_unofficial_ratio'::"text") THEN 'pagamento_nao_registrado'::"text"
            WHEN ("a"."alert_type" = 'provider_no_contract'::"text") THEN 'vinculo_trabalhista'::"text"
            WHEN ("a"."alert_type" = 'provider_overdue_invoice'::"text") THEN 'terceirizacao'::"text"
            WHEN ("a"."alert_type" = 'provider_no_mei'::"text") THEN 'vinculo_trabalhista'::"text"
            ELSE 'vinculo_trabalhista'::"text"
        END AS "risk_type",
    "rsm"."solution_codes",
    "rsm"."ai_recommendation",
    "a"."entity_type",
    "a"."entity_id",
    "a"."entity_name"
   FROM ("public"."labor_alerts" "a"
     LEFT JOIN "public"."risk_solution_mapping" "rsm" ON (("rsm"."risk_type" =
        CASE
            WHEN ("a"."alert_type" = 'unofficial_salary'::"text") THEN 'pagamento_nao_registrado'::"text"
            WHEN ("a"."alert_type" = 'high_unofficial_ratio'::"text") THEN 'pagamento_nao_registrado'::"text"
            WHEN ("a"."alert_type" = 'provider_no_contract'::"text") THEN 'vinculo_trabalhista'::"text"
            WHEN ("a"."alert_type" = 'provider_overdue_invoice'::"text") THEN 'terceirizacao'::"text"
            WHEN ("a"."alert_type" = 'provider_no_mei'::"text") THEN 'vinculo_trabalhista'::"text"
            ELSE 'vinculo_trabalhista'::"text"
        END)))
  WHERE (NOT "a"."is_resolved")
  ORDER BY
        CASE "a"."severity"
            WHEN 'critical'::"text" THEN 1
            WHEN 'high'::"text" THEN 2
            WHEN 'medium'::"text" THEN 3
            ELSE 4
        END;


ALTER VIEW "public"."vw_labor_risks_with_solutions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_person_labor_analysis" WITH ("security_invoker"='true') AS
 WITH "employee_data" AS (
         SELECT "employees"."id",
            "employees"."name",
            'employee'::"text" AS "person_type",
            "employees"."role",
            "employees"."official_salary",
            "employees"."unofficial_salary",
            ((("employees"."unofficial_salary")::numeric / NULLIF(("employees"."official_salary" + "employees"."unofficial_salary"), (0)::numeric)) * (100)::numeric) AS "unofficial_ratio",
            "employees"."hire_date",
            "employees"."work_area"
           FROM "public"."employees"
          WHERE "employees"."is_active"
        ), "provider_data" AS (
         SELECT "service_providers"."id",
            "service_providers"."name",
            'provider'::"text" AS "person_type",
            "service_providers"."services_description" AS "role",
            "service_providers"."monthly_value" AS "official_salary",
            0 AS "unofficial_salary",
            0 AS "unofficial_ratio",
            "service_providers"."contract_start_date" AS "hire_date",
            'Terceirizado'::"text" AS "work_area"
           FROM "public"."service_providers"
          WHERE "service_providers"."is_active"
        )
 SELECT "id",
    "name",
    "person_type",
    "role",
    "official_salary",
    "unofficial_salary",
    "unofficial_ratio",
    "hire_date",
    "work_area",
        CASE
            WHEN ("unofficial_ratio" > (50)::numeric) THEN 'critical'::"text"
            WHEN ("unofficial_ratio" > (30)::numeric) THEN 'high'::"text"
            WHEN ("unofficial_ratio" > (0)::numeric) THEN 'medium'::"text"
            ELSE 'low'::"text"
        END AS "risk_level",
        CASE
            WHEN ("unofficial_ratio" > (0)::numeric) THEN ARRAY['CLT_REGULARIZATION'::"text", 'PARTNER_INTEGRATION'::"text"]
            WHEN ("person_type" = 'provider'::"text") THEN ARRAY['MEI_FORMALIZATION'::"text", 'SERVICE_COMPANY'::"text"]
            ELSE ARRAY[]::"text"[]
        END AS "suggested_solutions"
   FROM ( SELECT "employee_data"."id",
            "employee_data"."name",
            "employee_data"."person_type",
            "employee_data"."role",
            "employee_data"."official_salary",
            "employee_data"."unofficial_salary",
            "employee_data"."unofficial_ratio",
            "employee_data"."hire_date",
            "employee_data"."work_area"
           FROM "employee_data"
        UNION ALL
         SELECT "provider_data"."id",
            "provider_data"."name",
            "provider_data"."person_type",
            "provider_data"."role",
            "provider_data"."official_salary",
            "provider_data"."unofficial_salary",
            "provider_data"."unofficial_ratio",
            "provider_data"."hire_date",
            "provider_data"."work_area"
           FROM "provider_data") "e";


ALTER VIEW "public"."vw_person_labor_analysis" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_ai_labor_context" WITH ("security_invoker"='true') AS
 SELECT "json_build_object"('agents', ( SELECT "json_agg"("row_to_json"("a".*)) AS "json_agg"
           FROM "public"."ai_agents" "a"
          WHERE "a"."is_active"), 'active_risks', ( SELECT "json_agg"("row_to_json"("r".*)) AS "json_agg"
           FROM "public"."vw_labor_risks_with_solutions" "r"), 'persons_analysis', ( SELECT "json_agg"("row_to_json"("p".*)) AS "json_agg"
           FROM "public"."vw_person_labor_analysis" "p"), 'available_strategies', ( SELECT "json_agg"("row_to_json"("s".*)) AS "json_agg"
           FROM "public"."labor_solution_strategies" "s"), 'risk_mappings', ( SELECT "json_agg"("row_to_json"("m".*)) AS "json_agg"
           FROM "public"."risk_solution_mapping" "m")) AS "context";


ALTER VIEW "public"."vw_ai_labor_context" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_balancete" WITH ("security_invoker"='true') AS
 SELECT "coa"."code" AS "codigo_conta",
    "coa"."name" AS "nome_conta",
    "coa"."account_type" AS "tipo_conta",
    "coa"."nature" AS "natureza",
    COALESCE("sum"("aei"."debit"), (0)::numeric) AS "total_debito",
    COALESCE("sum"("aei"."credit"), (0)::numeric) AS "total_credito",
        CASE
            WHEN (("coa"."nature")::"text" = 'DEVEDORA'::"text") THEN (COALESCE("sum"("aei"."debit"), (0)::numeric) - COALESCE("sum"("aei"."credit"), (0)::numeric))
            ELSE (COALESCE("sum"("aei"."credit"), (0)::numeric) - COALESCE("sum"("aei"."debit"), (0)::numeric))
        END AS "saldo"
   FROM (("public"."chart_of_accounts" "coa"
     LEFT JOIN "public"."accounting_entry_items" "aei" ON (("coa"."id" = "aei"."account_id")))
     LEFT JOIN "public"."accounting_entries" "ae" ON ((("aei"."entry_id" = "ae"."id") AND ("ae"."is_draft" = false))))
  WHERE ("coa"."is_analytical" = true)
  GROUP BY "coa"."id", "coa"."code", "coa"."name", "coa"."account_type", "coa"."nature"
  ORDER BY "coa"."code";


ALTER VIEW "public"."vw_balancete" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_business_maturity_summary" WITH ("security_invoker"='true') AS
 SELECT "analysis_period",
    "maturity_score",
    "maturity_level",
    "accounting_score",
    "labor_risks_count",
    "is_profitable",
    "can_implement_plr",
    "can_implement_incentives",
    "can_implement_referrals",
    "can_attract_investors",
    "jsonb_array_length"("blockers") AS "blockers_count",
    "jsonb_array_length"("recommendations") AS "recommendations_count",
    "cicero_diagnosis",
    "milton_diagnosis",
    "advocato_diagnosis",
    "created_at"
   FROM "public"."business_maturity_analysis" "bma"
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."vw_business_maturity_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_clients_variable_fees" WITH ("security_invoker"='true') AS
 SELECT "c"."id" AS "client_id",
    "c"."name" AS "client_name",
    "c"."nome_fantasia",
    "cvf"."fee_name",
    "cvf"."percentage_rate",
    "cvf"."due_day",
    "cvf"."calculation_base",
    "cvf"."is_active"
   FROM ("public"."clients" "c"
     JOIN "public"."client_variable_fees" "cvf" ON (("cvf"."client_id" = "c"."id")))
  WHERE ("cvf"."is_active" = true);


ALTER VIEW "public"."vw_clients_variable_fees" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_content_metrics" WITH ("security_invoker"='true') AS
 SELECT "ct"."target_platform",
    "ct"."content_type",
    "count"(*) AS "total_gerados",
    "count"(*) FILTER (WHERE ("gc"."status" = 'published'::"text")) AS "publicados",
    "sum"("gc"."views_count") AS "total_views",
    "sum"("gc"."engagement_count") AS "total_engagement",
    "avg"("gc"."tokens_used") AS "media_tokens",
    "sum"("gc"."cost_estimated") AS "custo_total"
   FROM ("public"."generated_content" "gc"
     JOIN "public"."content_templates" "ct" ON (("ct"."id" = "gc"."template_id")))
  GROUP BY "ct"."target_platform", "ct"."content_type";


ALTER VIEW "public"."vw_content_metrics" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_content_to_publish" WITH ("security_invoker"='true') AS
 SELECT "gc"."id",
    "gc"."template_code",
    "ct"."template_name",
    "ct"."target_platform",
    "gc"."content_generated",
    "gc"."status",
    "gc"."created_at",
    "cpq"."scheduled_at",
    "cpq"."status" AS "queue_status"
   FROM (("public"."generated_content" "gc"
     JOIN "public"."content_templates" "ct" ON (("ct"."id" = "gc"."template_id")))
     LEFT JOIN "public"."content_publish_queue" "cpq" ON (("cpq"."content_id" = "gc"."id")))
  WHERE ("gc"."status" = 'approved'::"text")
  ORDER BY "cpq"."scheduled_at";


ALTER VIEW "public"."vw_content_to_publish" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_cost_center_with_accounts" WITH ("security_invoker"='true') AS
 SELECT "cc"."id" AS "cost_center_id",
    "cc"."code" AS "cost_center_code",
    "cc"."name" AS "cost_center_name",
    "cc"."description" AS "cost_center_description",
    "array_agg"("coa"."id") FILTER (WHERE ("coa"."id" IS NOT NULL)) AS "account_ids",
    "array_agg"("coa"."code") FILTER (WHERE ("coa"."code" IS NOT NULL)) AS "account_codes",
    "array_agg"("coa"."name") FILTER (WHERE ("coa"."name" IS NOT NULL)) AS "account_names"
   FROM (("public"."cost_centers" "cc"
     LEFT JOIN "public"."cost_center_accounts" "cca" ON (("cc"."id" = "cca"."cost_center_id")))
     LEFT JOIN "public"."chart_of_accounts" "coa" ON (("cca"."chart_account_id" = "coa"."id")))
  WHERE ("cc"."is_active" = true)
  GROUP BY "cc"."id", "cc"."code", "cc"."name", "cc"."description"
  ORDER BY "cc"."code";


ALTER VIEW "public"."vw_cost_center_with_accounts" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_cost_center_with_accounts" IS 'Centros de custo com todas as contas pai vinculadas';



CREATE OR REPLACE VIEW "public"."vw_costs_by_department" WITH ("security_invoker"='true') AS
 SELECT "cc"."id" AS "cost_center_id",
    "cc"."code" AS "department_code",
    "cc"."name" AS "department_name",
    "date_trunc"('month'::"text", ("ae"."entry_date")::timestamp with time zone) AS "month",
    "ae"."entry_type",
    "count"(*) AS "total_entries",
    "sum"("ae"."total_debit") AS "total_amount"
   FROM ("public"."accounting_entries" "ae"
     LEFT JOIN "public"."cost_centers" "cc" ON (("ae"."cost_center_id" = "cc"."id")))
  WHERE (("ae"."entry_type")::"text" = ANY (ARRAY[('despesa'::character varying)::"text", ('pagamento_despesa'::character varying)::"text"]))
  GROUP BY "cc"."id", "cc"."code", "cc"."name", ("date_trunc"('month'::"text", ("ae"."entry_date")::timestamp with time zone)), "ae"."entry_type"
  ORDER BY ("date_trunc"('month'::"text", ("ae"."entry_date")::timestamp with time zone)) DESC, "cc"."name";


ALTER VIEW "public"."vw_costs_by_department" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_costs_by_department" IS 'Custos mensais agrupados por departamento';



CREATE OR REPLACE VIEW "public"."vw_economic_group_members" WITH ("security_invoker"='true') AS
 SELECT "eg"."group_name",
    "eg"."group_code",
    "egm"."company_name",
    "egm"."cnpj",
    "egm"."relationship_type",
    "egm"."ownership_percent",
    "egm"."billing_share_percent",
    "egm"."is_active",
    "egm"."joined_at"
   FROM ("public"."economic_group_members" "egm"
     JOIN "public"."economic_groups" "eg" ON (("eg"."id" = "egm"."group_id")))
  ORDER BY "eg"."group_name", "egm"."relationship_type" DESC;


ALTER VIEW "public"."vw_economic_group_members" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_economic_groups_summary" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"text" AS "group_name",
    NULL::"text" AS "group_code",
    NULL::"text" AS "main_company_name",
    NULL::bigint AS "total_empresas",
    NULL::bigint AS "empresas_ativas",
    NULL::boolean AS "consolidate_billing",
    NULL::numeric(5,2) AS "shared_discount_percent",
    NULL::"text" AS "account_manager",
    NULL::boolean AS "is_active";


ALTER VIEW "public"."vw_economic_groups_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_employee_sales_ranking" WITH ("security_invoker"='true') AS
 SELECT "employee_name",
    "employee_area",
    "count"(*) FILTER (WHERE ("status" = 'won'::"text")) AS "vendas_fechadas",
    "count"(*) FILTER (WHERE ("status" = ANY (ARRAY['lead'::"text", 'contacted'::"text", 'meeting'::"text", 'proposal'::"text", 'negotiation'::"text"]))) AS "em_andamento",
    "count"(*) FILTER (WHERE ("status" = 'lost'::"text")) AS "perdidas",
    "sum"("commission_value") FILTER (WHERE ("status" = 'won'::"text")) AS "total_comissoes",
    "sum"("commission_value") FILTER (WHERE (("status" = 'won'::"text") AND ("commission_paid" = false))) AS "comissoes_pendentes",
    "sum"("monthly_fee") FILTER (WHERE ("status" = 'won'::"text")) AS "receita_gerada",
    "max"("close_date") AS "ultima_venda"
   FROM "public"."employee_sales"
  GROUP BY "employee_name", "employee_area"
  ORDER BY ("count"(*) FILTER (WHERE ("status" = 'won'::"text"))) DESC, ("sum"("commission_value") FILTER (WHERE ("status" = 'won'::"text"))) DESC;


ALTER VIEW "public"."vw_employee_sales_ranking" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_employee_sales_ranking" IS 'Ranking de vendedores';



CREATE OR REPLACE VIEW "public"."vw_evolution_metrics" WITH ("security_invoker"='true') AS
 SELECT "count"(*) FILTER (WHERE ("status" = 'pending'::"text")) AS "pendentes",
    "count"(*) FILTER (WHERE ("status" = 'analyzing'::"text")) AS "em_analise",
    "count"(*) FILTER (WHERE ("status" = 'approved'::"text")) AS "aprovadas",
    "count"(*) FILTER (WHERE ("status" = 'in_development'::"text")) AS "em_desenvolvimento",
    "count"(*) FILTER (WHERE ("status" = 'deployed'::"text")) AS "implementadas",
    "count"(*) FILTER (WHERE ("status" = 'rejected'::"text")) AS "rejeitadas",
    "count"(*) AS "total",
    "avg"(
        CASE
            WHEN ("status" = 'deployed'::"text") THEN "user_satisfaction"
            ELSE NULL::integer
        END) AS "satisfacao_media",
    "avg"((EXTRACT(epoch FROM ("deployed_at" - "created_at")) / (86400)::numeric)) FILTER (WHERE ("deployed_at" IS NOT NULL)) AS "dias_medio_implementacao"
   FROM "public"."feature_requests";


ALTER VIEW "public"."vw_evolution_metrics" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_expenses_by_cost_center" WITH ("security_invoker"='true') AS
 SELECT "e"."id",
    "cc"."code" AS "cost_center_code",
    "cc"."name" AS "cost_center_name",
    COALESCE("pcc"."name", "cc"."name") AS "parent_name",
    "e"."description",
    "e"."amount",
    "e"."due_date",
    "e"."payment_date",
    "e"."category",
    "e"."status"
   FROM (("public"."expenses" "e"
     LEFT JOIN "public"."cost_centers" "cc" ON (("e"."cost_center_id" = "cc"."id")))
     LEFT JOIN "public"."cost_centers" "pcc" ON (("cc"."parent_id" = "pcc"."id")))
  ORDER BY "cc"."code", "e"."due_date" DESC;


ALTER VIEW "public"."vw_expenses_by_cost_center" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_expenses_by_cost_center" IS 'Despesas agrupadas por centro de custo';



CREATE OR REPLACE VIEW "public"."vw_expenses_with_accounts" WITH ("security_invoker"='true') AS
 SELECT "e"."id",
    "e"."description",
    "e"."amount",
    "e"."due_date",
    "e"."payment_date",
    "e"."status",
    "cc"."code" AS "cost_center_code",
    "cc"."name" AS "cost_center_name",
    "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    "coa"."account_type",
    COALESCE("coa"."code", (("cc"."default_chart_account_id")::"text")::character varying) AS "effective_account_code",
    "e"."competence",
    "e"."created_at",
    "e"."updated_at"
   FROM (("public"."expenses" "e"
     LEFT JOIN "public"."cost_centers" "cc" ON (("e"."cost_center_id" = "cc"."id")))
     LEFT JOIN "public"."chart_of_accounts" "coa" ON (("e"."account_id" = "coa"."id")))
  ORDER BY "e"."due_date" DESC;


ALTER VIEW "public"."vw_expenses_with_accounts" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_expenses_with_accounts" IS 'Despesas com rastreabilidade completa: centro de custo + plano de contas';



CREATE OR REPLACE VIEW "public"."vw_growth_opportunities" WITH ("security_invoker"='true') AS
 SELECT 'upsell'::"text" AS "opportunity_type",
    "c"."id" AS "client_id",
    "c"."name",
    "c"."monthly_fee" AS "current_fee",
    'Cliente com poucos servi├ºos contratados'::"text" AS "opportunity",
    'Apresentar consultoria ou BPO'::"text" AS "suggested_action",
    'vendedor'::"text" AS "assigned_agent"
   FROM "public"."clients" "c"
  WHERE (("c"."status" = 'Ativo'::"text") AND ("c"."monthly_fee" < (1000)::numeric))
UNION ALL
 SELECT 'retention'::"text" AS "opportunity_type",
    "c"."id" AS "client_id",
    "c"."name",
    "c"."monthly_fee" AS "current_fee",
    'Cliente com pagamentos atrasados'::"text" AS "opportunity",
    'Contatar para entender situa├º├úo e reter'::"text" AS "suggested_action",
    'vendedor'::"text" AS "assigned_agent"
   FROM "public"."clients" "c"
  WHERE ("c"."status" = 'Ativo'::"text")
UNION ALL
 SELECT 'referral'::"text" AS "opportunity_type",
    NULL::"uuid" AS "client_id",
    "referral_program"."referred_name" AS "name",
    "referral_program"."estimated_monthly_fee" AS "current_fee",
    'Indica├º├úo aguardando contato'::"text" AS "opportunity",
    'Entrar em contato e agendar reuni├úo'::"text" AS "suggested_action",
    'vendedor'::"text" AS "assigned_agent"
   FROM "public"."referral_program"
  WHERE ("referral_program"."status" = ANY (ARRAY['pending'::"text", 'contacted'::"text"]))
  ORDER BY 4 DESC NULLS LAST;


ALTER VIEW "public"."vw_growth_opportunities" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_irpf_summary" WITH ("security_invoker"='true') AS
 SELECT "calendar_year",
    "fiscal_year",
    "count"(*) AS "total_declarations",
    "count"(*) FILTER (WHERE (("status")::"text" = 'pendente'::"text")) AS "pending",
    "count"(*) FILTER (WHERE (("status")::"text" = 'documentos_solicitados'::"text")) AS "awaiting_docs",
    "count"(*) FILTER (WHERE (("status")::"text" = 'em_elaboracao'::"text")) AS "in_progress",
    "count"(*) FILTER (WHERE (("status")::"text" = ANY (ARRAY[('enviada'::character varying)::"text", ('concluida'::character varying)::"text"]))) AS "completed",
    "sum"("fee_amount") AS "total_fees",
    "sum"("fee_amount") FILTER (WHERE (("payment_status")::"text" = 'paid'::"text")) AS "fees_received"
   FROM "public"."irpf_declarations"
  GROUP BY "calendar_year", "fiscal_year"
  ORDER BY "calendar_year" DESC;


ALTER VIEW "public"."vw_irpf_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_jurisprudence_by_risk" WITH ("security_invoker"='true') AS
 SELECT "risk_type",
    "json_agg"("json_build_object"('court', "court", 'case_number', "case_number", 'date', "decision_date", 'summary', "summary", 'outcome', "outcome", 'key_arguments', "key_arguments", 'relevance', "relevance_score") ORDER BY "relevance_score" DESC) AS "decisions"
   FROM "public"."labor_jurisprudence"
  GROUP BY "risk_type";


ALTER VIEW "public"."vw_jurisprudence_by_risk" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_labor_risk_summary" WITH ("security_invoker"='true') AS
 SELECT "id",
    "name",
    "department",
    "role",
    "contract_type",
    "official_salary",
    "unofficial_salary",
    (COALESCE("official_salary", (0)::numeric) + COALESCE("unofficial_salary", (0)::numeric)) AS "total_salary",
        CASE
            WHEN ("unofficial_salary" > (0)::numeric) THEN 'ALTO'::"text"
            WHEN (("contract_type" = 'Aut├┤nomo'::"text") AND ("is_per_production" = false)) THEN 'M├ëDIO'::"text"
            ELSE 'BAIXO'::"text"
        END AS "risk_level",
    "labor_risk_notes",
    "hire_date",
    EXTRACT(year FROM "age"((CURRENT_DATE)::timestamp with time zone, ("hire_date")::timestamp with time zone)) AS "years_worked"
   FROM "public"."employees" "e"
  WHERE ("is_active" = true)
  ORDER BY
        CASE
            WHEN ("unofficial_salary" > (0)::numeric) THEN 1
            WHEN ("contract_type" = 'Aut├┤nomo'::"text") THEN 2
            ELSE 3
        END, "name";


ALTER VIEW "public"."vw_labor_risk_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_labor_risk_summary" IS 'Resumo de riscos trabalhistas por funcion├írio';



CREATE OR REPLACE VIEW "public"."vw_livro_diario" WITH ("security_invoker"='true') AS
 SELECT "ae"."entry_number" AS "numero_lancamento",
    "ae"."entry_date" AS "data_lancamento",
    "ae"."competence_date" AS "data_competencia",
    "ae"."description" AS "descricao",
    "ae"."entry_type" AS "tipo_lancamento",
    "ae"."document_number" AS "numero_documento",
    "aei"."account_id",
    "coa"."code" AS "codigo_conta",
    "coa"."name" AS "nome_conta",
    "aei"."debit" AS "debito",
    "aei"."credit" AS "credito",
    "aei"."history" AS "historico",
    "c"."name" AS "cliente_nome",
    "ae"."created_at"
   FROM ((("public"."accounting_entries" "ae"
     JOIN "public"."accounting_entry_items" "aei" ON (("ae"."id" = "aei"."entry_id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("aei"."account_id" = "coa"."id")))
     LEFT JOIN "public"."clients" "c" ON (("aei"."client_id" = "c"."id")))
  WHERE ("ae"."is_draft" = false)
  ORDER BY "ae"."entry_number", "ae"."entry_date", "coa"."code";


ALTER VIEW "public"."vw_livro_diario" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_livro_razao" WITH ("security_invoker"='true') AS
 SELECT "coa"."id" AS "account_id",
    "coa"."code" AS "codigo_conta",
    "coa"."name" AS "nome_conta",
    "coa"."nature" AS "natureza",
    "ae"."entry_date" AS "data_lancamento",
    "ae"."entry_number" AS "numero_lancamento",
    "ae"."description" AS "descricao",
    "aei"."debit" AS "debito",
    "aei"."credit" AS "credito",
    "aei"."history" AS "historico",
    "c"."name" AS "cliente_nome"
   FROM ((("public"."chart_of_accounts" "coa"
     LEFT JOIN "public"."accounting_entry_items" "aei" ON (("coa"."id" = "aei"."account_id")))
     LEFT JOIN "public"."accounting_entries" "ae" ON ((("aei"."entry_id" = "ae"."id") AND ("ae"."is_draft" = false))))
     LEFT JOIN "public"."clients" "c" ON (("aei"."client_id" = "c"."id")))
  WHERE ("coa"."is_analytical" = true)
  ORDER BY "coa"."code", "ae"."entry_date", "ae"."entry_number";


ALTER VIEW "public"."vw_livro_razao" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_low_stock_products" WITH ("security_invoker"='true') AS
 SELECT "id",
    "code",
    "name",
    "brand",
    "category",
    "current_stock",
    "minimum_stock",
    "ideal_stock",
    "unit",
    "last_price",
    "last_price_date",
    "preferred_supplier",
    GREATEST((0)::numeric, ("ideal_stock" - "current_stock")) AS "quantity_to_buy",
    "round"((GREATEST((0)::numeric, ("ideal_stock" - "current_stock")) * COALESCE("last_price", (0)::numeric)), 2) AS "estimated_value",
        CASE
            WHEN ("current_stock" <= (0)::numeric) THEN 'URGENTE'::"text"
            WHEN ("current_stock" < "minimum_stock") THEN 'ALTO'::"text"
            WHEN ("current_stock" < "ideal_stock") THEN 'NORMAL'::"text"
            ELSE 'OK'::"text"
        END AS "priority"
   FROM "public"."office_products" "p"
  WHERE (("is_active" = true) AND ("current_stock" < "ideal_stock"))
  ORDER BY
        CASE
            WHEN ("current_stock" <= (0)::numeric) THEN 1
            WHEN ("current_stock" < "minimum_stock") THEN 2
            ELSE 3
        END, "category", "name";


ALTER VIEW "public"."vw_low_stock_products" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_low_stock_products" IS 'Produtos com estoque abaixo do ideal - para gerar lista de compras';



CREATE OR REPLACE VIEW "public"."vw_nfse_tomadas_detalhada" WITH ("security_invoker"='true') AS
 SELECT "nt"."id",
    "nt"."numero_nfse",
    "nt"."codigo_verificacao",
    "nt"."data_emissao",
    "nt"."competencia",
    "nt"."prestador_cnpj",
    "nt"."prestador_cpf",
    "nt"."prestador_razao_social",
    "nt"."prestador_inscricao_municipal",
    "nt"."prestador_endereco",
    "nt"."prestador_municipio",
    "nt"."prestador_uf",
    "nt"."tomador_cnpj",
    "nt"."tomador_razao_social",
    "nt"."valor_servicos",
    "nt"."valor_deducoes",
    "nt"."valor_pis",
    "nt"."valor_cofins",
    "nt"."valor_inss",
    "nt"."valor_ir",
    "nt"."valor_csll",
    "nt"."valor_iss",
    "nt"."outras_retencoes",
    "nt"."aliquota",
    "nt"."valor_liquido",
    "nt"."discriminacao",
    "nt"."item_lista_servico",
    "nt"."codigo_cnae",
    "nt"."codigo_municipio",
    "nt"."xml_nfse",
    "nt"."status",
    "nt"."conta_pagar_id",
    "nt"."supplier_id",
    "nt"."created_at",
    "nt"."updated_at",
    "nt"."created_by",
    "s"."name" AS "supplier_name",
    "s"."email" AS "supplier_email",
    "ap"."due_date" AS "conta_pagar_vencimento",
    "ap"."status" AS "conta_pagar_status",
    "ap"."amount" AS "conta_pagar_valor"
   FROM (("public"."nfse_tomadas" "nt"
     LEFT JOIN "public"."suppliers" "s" ON (("nt"."supplier_id" = "s"."id")))
     LEFT JOIN "public"."accounts_payable" "ap" ON (("nt"."conta_pagar_id" = "ap"."id")));


ALTER VIEW "public"."vw_nfse_tomadas_detalhada" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_partner_advances_summary" WITH ("security_invoker"='true') AS
 SELECT "cc"."name" AS "partner_name",
    "ec"."name" AS "category_name",
    "count"("e"."id") AS "total_expenses",
    "sum"("e"."amount") AS "total_amount",
    "max"("e"."due_date") AS "last_expense_date"
   FROM (("public"."expense_categories" "ec"
     LEFT JOIN "public"."expenses" "e" ON (("e"."category" = "ec"."code")))
     LEFT JOIN "public"."cost_centers" "cc" ON (("ec"."cost_center_id" = "cc"."id")))
  WHERE ("cc"."code" ~~ 'SERGIO%'::"text")
  GROUP BY "cc"."name", "ec"."name"
  ORDER BY "cc"."name", ("sum"("e"."amount")) DESC NULLS LAST;


ALTER VIEW "public"."vw_partner_advances_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_partner_advances_summary" IS 'Resumo de adiantamentos por s├│cio e categoria';



CREATE OR REPLACE VIEW "public"."vw_partner_groups" WITH ("security_barrier"='true', "security_invoker"='true') AS
 WITH "partner_companies" AS (
         SELECT COALESCE("client_partners"."cpf", ("client_partners"."name")::character varying) AS "partner_key",
            "client_partners"."name" AS "partner_name",
            "client_partners"."cpf",
            "client_partners"."client_id",
            "client_partners"."percentage"
           FROM "public"."client_partners"
        ), "partner_stats" AS (
         SELECT "partner_companies"."partner_key",
            "max"("partner_companies"."partner_name") AS "partner_name",
            "max"(("partner_companies"."cpf")::"text") AS "cpf",
            "count"(DISTINCT "partner_companies"."client_id") AS "companies_count",
            "array_agg"(DISTINCT "partner_companies"."client_id") AS "company_ids"
           FROM "partner_companies"
          GROUP BY "partner_companies"."partner_key"
         HAVING ("count"(DISTINCT "partner_companies"."client_id") > 1)
        )
 SELECT "partner_key",
    "partner_name",
    "cpf",
    "companies_count",
    "company_ids",
    ARRAY( SELECT "c"."name"
           FROM "public"."clients" "c"
          WHERE ("c"."id" = ANY ("ps"."company_ids"))) AS "company_names"
   FROM "partner_stats" "ps"
  ORDER BY "companies_count" DESC, "partner_name";


ALTER VIEW "public"."vw_partner_groups" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_partner_groups" IS 'S├│cios que participam de m├║ltiplas empresas - security_barrier ativo para respeitar RLS das tabelas base (client_partners e clients)';



CREATE OR REPLACE VIEW "public"."vw_payroll_events_detailed" WITH ("security_invoker"='true') AS
 SELECT "p"."competencia",
    "e"."name" AS "funcionario",
    "r"."codigo" AS "cod_rubrica",
    "pe"."descricao",
    "r"."natureza",
        CASE
            WHEN "pe"."is_oficial" THEN 'OFICIAL'::"text"
            ELSE 'POR FORA'::"text"
        END AS "tipo_pagamento",
        CASE
            WHEN "pe"."is_desconto" THEN 'D'::"text"
            ELSE 'P'::"text"
        END AS "P/D",
    "pe"."referencia",
    "pe"."valor",
    "pe"."observacao"
   FROM ((("public"."payroll_events" "pe"
     JOIN "public"."payroll" "p" ON (("p"."id" = "pe"."payroll_id")))
     JOIN "public"."employees" "e" ON (("e"."id" = "p"."employee_id")))
     JOIN "public"."esocial_rubricas" "r" ON (("r"."codigo" = "pe"."rubrica_codigo")))
  ORDER BY "p"."competencia" DESC, "e"."name", "pe"."is_oficial" DESC, "pe"."is_desconto", "r"."codigo";


ALTER VIEW "public"."vw_payroll_events_detailed" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_payroll_summary" WITH ("security_invoker"='true') AS
 SELECT "p"."competencia",
    "e"."name" AS "funcionario",
    "e"."role" AS "cargo",
    "p"."total_proventos_oficial" AS "proventos",
    "p"."total_descontos_oficial" AS "descontos",
    "p"."liquido_oficial",
    "p"."total_por_fora",
    "p"."liquido_total_real" AS "liquido_real",
    "p"."fgts_valor" AS "fgts",
    "p"."provisao_ferias",
    "p"."provisao_13",
    "p"."custo_total_empresa",
    "p"."status",
        CASE
            WHEN ("p"."total_por_fora" > (0)::numeric) THEN 'ÔÜá´©Å H├í valores por fora'::"text"
            ELSE 'Ô£à Folha regular'::"text"
        END AS "alerta",
    "round"((("p"."total_por_fora" * (100)::numeric) / NULLIF("p"."liquido_total_real", (0)::numeric)), 1) AS "percentual_por_fora"
   FROM ("public"."payroll" "p"
     JOIN "public"."employees" "e" ON (("e"."id" = "p"."employee_id")))
  ORDER BY "p"."competencia" DESC, "e"."name";


ALTER VIEW "public"."vw_payroll_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_payroll_summary" IS 'Resumo da folha com alertas de valores por fora';



CREATE OR REPLACE VIEW "public"."vw_pending_classification" WITH ("security_invoker"='true') AS
 SELECT "id",
    "transaction_date",
    "description",
    "amount",
    "transaction_type",
    "ai_suggestion",
    "created_at"
   FROM "public"."bank_transactions"
  WHERE ("ai_suggestion" ~~ '%PENDENTE%'::"text")
  ORDER BY ("abs"("amount")) DESC, "transaction_date" DESC;


ALTER VIEW "public"."vw_pending_classification" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_pending_classification" IS 'Transa├º├Áes que entraram no sistema mas n├úo puderam ser classificadas automaticamente.
Dr. C├¡cero monitora esta view e alerta quando h├í itens pendentes.';



CREATE OR REPLACE VIEW "public"."vw_pending_commissions" WITH ("security_invoker"='true') AS
 SELECT "rp"."name" AS "partner_name",
    "rp"."pix_key",
    "rp"."pix_key_type",
    "c"."name" AS "client_name",
    "cr"."commission_percentage",
    "cr"."commission_months",
    "cr"."months_paid",
    ("cr"."commission_months" - "cr"."months_paid") AS "months_remaining",
    "c"."monthly_fee",
    (("c"."monthly_fee" * "cr"."commission_percentage") / (100)::numeric) AS "next_commission_amount"
   FROM (("public"."client_referrals" "cr"
     JOIN "public"."referral_partners" "rp" ON (("rp"."id" = "cr"."referral_partner_id")))
     JOIN "public"."clients" "c" ON (("c"."id" = "cr"."client_id")))
  WHERE ((("cr"."status")::"text" = 'active'::"text") AND ("cr"."months_paid" < "cr"."commission_months"));


ALTER VIEW "public"."vw_pending_commissions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_pending_feature_requests" WITH ("security_invoker"='true') AS
 SELECT "id",
    "title",
    "requested_by",
    "department",
    "category",
    "complexity",
    "priority_score",
    "assigned_agent",
        CASE "assigned_agent"
            WHEN 'cicero'::"text" THEN 'Dr. C├¡cero'::"text"
            WHEN 'milton'::"text" THEN 'Prof. Milton'::"text"
            WHEN 'helena'::"text" THEN 'Dra. Helena'::"text"
            WHEN 'atlas'::"text" THEN 'Atlas'::"text"
            WHEN 'advocato'::"text" THEN 'Dr. Advocato'::"text"
            WHEN 'empresario'::"text" THEN 'Sr. Empres├írio'::"text"
            WHEN 'vendedor'::"text" THEN 'Sr. Vendedor'::"text"
            WHEN 'marketing'::"text" THEN 'Sra. Marketing'::"text"
            ELSE 'N├úo atribu├¡do'::"text"
        END AS "agent_name",
    "status",
    "created_at",
    "age"("now"(), "created_at") AS "tempo_espera"
   FROM "public"."feature_requests" "fr"
  WHERE ("status" <> ALL (ARRAY['deployed'::"text", 'rejected'::"text"]))
  ORDER BY "priority_score" DESC, "created_at";


ALTER VIEW "public"."vw_pending_feature_requests" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_plr_by_employee" WITH ("security_invoker"='true') AS
 SELECT "p"."program_name",
    "p"."reference_year",
    "pes"."employee_name",
    "pes"."total_score",
    ("pes"."share_percent" * (100)::numeric) AS "percentual_pool",
    "pes"."base_value",
    "pes"."bonus_value",
    "pes"."final_value",
    "pes"."paid",
    "pes"."paid_date"
   FROM ("public"."plr_employee_share" "pes"
     JOIN "public"."plr_programs" "p" ON (("p"."id" = "pes"."program_id")))
  ORDER BY "pes"."final_value" DESC;


ALTER VIEW "public"."vw_plr_by_employee" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_plr_summary" WITH ("security_invoker"='true') AS
 SELECT "p"."program_name",
    "p"."reference_year",
    "p"."plr_pool_value" AS "pool_total",
    "count"("pes"."id") AS "funcionarios",
    "sum"("pes"."final_value") AS "total_distribuido",
    "avg"("pes"."final_value") AS "media_por_funcionario",
    "max"("pes"."final_value") AS "maior_valor",
    "min"("pes"."final_value") FILTER (WHERE ("pes"."final_value" > (0)::numeric)) AS "menor_valor"
   FROM ("public"."plr_programs" "p"
     LEFT JOIN "public"."plr_employee_share" "pes" ON (("pes"."program_id" = "p"."id")))
  GROUP BY "p"."id", "p"."program_name", "p"."reference_year", "p"."plr_pool_value";


ALTER VIEW "public"."vw_plr_summary" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_product_price_history" WITH ("security_invoker"='true') AS
 SELECT "p"."id" AS "product_id",
    "p"."code",
    "p"."name",
    "p"."brand",
    "pp"."purchase_date",
    "pp"."quantity",
    "pp"."unit_price",
    "pp"."supplier",
    "lag"("pp"."unit_price") OVER (PARTITION BY "p"."id" ORDER BY "pp"."purchase_date") AS "previous_price",
    "round"(((("pp"."unit_price" - "lag"("pp"."unit_price") OVER (PARTITION BY "p"."id" ORDER BY "pp"."purchase_date")) / NULLIF("lag"("pp"."unit_price") OVER (PARTITION BY "p"."id" ORDER BY "pp"."purchase_date"), (0)::numeric)) * (100)::numeric), 2) AS "price_change_percent"
   FROM ("public"."office_products" "p"
     JOIN "public"."product_purchases" "pp" ON (("p"."id" = "pp"."product_id")))
  ORDER BY "p"."name", "pp"."purchase_date" DESC;


ALTER VIEW "public"."vw_product_price_history" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_product_price_history" IS 'Hist├│rico de pre├ºos com varia├º├úo percentual';



CREATE OR REPLACE VIEW "public"."vw_program_readiness" WITH ("security_invoker"='true') AS
 SELECT "pp"."program_code",
    "pp"."program_name",
    "pp"."min_maturity_score",
    "bma"."maturity_score" AS "current_score",
        CASE
            WHEN ("bma"."maturity_score" >= "pp"."min_maturity_score") THEN 'Ô£à Score OK'::"text"
            ELSE ((('ÔØî Score '::"text" || "bma"."maturity_score") || '/'::"text") || "pp"."min_maturity_score")
        END AS "score_status",
        CASE "pp"."program_code"
            WHEN 'PLR'::"text" THEN "bma"."can_implement_plr"
            WHEN 'EMPLOYEE_INCENTIVES'::"text" THEN "bma"."can_implement_incentives"
            WHEN 'REFERRAL_PROGRAM'::"text" THEN "bma"."can_implement_referrals"
            WHEN 'INVESTOR_READY'::"text" THEN "bma"."can_attract_investors"
            ELSE NULL::boolean
        END AS "is_ready",
    "pp"."risks_if_premature"
   FROM ("public"."program_prerequisites" "pp"
     CROSS JOIN ( SELECT "business_maturity_analysis"."id",
            "business_maturity_analysis"."analysis_period",
            "business_maturity_analysis"."analysis_date",
            "business_maturity_analysis"."analyzed_by",
            "business_maturity_analysis"."has_updated_balancete",
            "business_maturity_analysis"."balancete_date",
            "business_maturity_analysis"."total_assets",
            "business_maturity_analysis"."total_liabilities",
            "business_maturity_analysis"."equity",
            "business_maturity_analysis"."current_ratio",
            "business_maturity_analysis"."debt_ratio",
            "business_maturity_analysis"."revenue_ytd",
            "business_maturity_analysis"."expenses_ytd",
            "business_maturity_analysis"."profit_ytd",
            "business_maturity_analysis"."profit_margin",
            "business_maturity_analysis"."is_profitable",
            "business_maturity_analysis"."months_profitable",
            "business_maturity_analysis"."cash_balance",
            "business_maturity_analysis"."average_monthly_revenue",
            "business_maturity_analysis"."average_monthly_expenses",
            "business_maturity_analysis"."runway_months",
            "business_maturity_analysis"."has_cash_flow_issues",
            "business_maturity_analysis"."chart_of_accounts_complete",
            "business_maturity_analysis"."opening_balance_done",
            "business_maturity_analysis"."reconciliation_updated",
            "business_maturity_analysis"."pending_entries",
            "business_maturity_analysis"."accounting_score",
            "business_maturity_analysis"."labor_risks_count",
            "business_maturity_analysis"."labor_risk_value",
            "business_maturity_analysis"."contracts_pending",
            "business_maturity_analysis"."tax_compliance_score",
            "business_maturity_analysis"."partners_registered",
            "business_maturity_analysis"."capital_structure_clear",
            "business_maturity_analysis"."succession_plan",
            "business_maturity_analysis"."maturity_score",
            "business_maturity_analysis"."maturity_level",
            "business_maturity_analysis"."cicero_diagnosis",
            "business_maturity_analysis"."milton_diagnosis",
            "business_maturity_analysis"."helena_diagnosis",
            "business_maturity_analysis"."advocato_diagnosis",
            "business_maturity_analysis"."empresario_diagnosis",
            "business_maturity_analysis"."recommendations",
            "business_maturity_analysis"."blockers",
            "business_maturity_analysis"."next_steps",
            "business_maturity_analysis"."can_implement_plr",
            "business_maturity_analysis"."can_implement_incentives",
            "business_maturity_analysis"."can_implement_referrals",
            "business_maturity_analysis"."can_attract_investors",
            "business_maturity_analysis"."created_at"
           FROM "public"."business_maturity_analysis"
          ORDER BY "business_maturity_analysis"."created_at" DESC
         LIMIT 1) "bma")
  WHERE "pp"."is_active"
  ORDER BY "pp"."min_maturity_score";


ALTER VIEW "public"."vw_program_readiness" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_provider_compliance" WITH ("security_invoker"='true') AS
 SELECT "id",
    "name",
    "service_area",
    "contract_type",
    "has_mei",
    "mei_cnpj",
    "contract_signed",
    "requires_invoice",
    "last_invoice_date",
    "compliance_status",
    "labor_risk_notes",
        CASE
            WHEN ("contract_signed" = false) THEN 1
            ELSE 0
        END AS "pending_contract",
        CASE
            WHEN ("requires_invoice" AND ("last_invoice_date" IS NULL)) THEN 1
            WHEN ("requires_invoice" AND ("last_invoice_date" < (CURRENT_DATE - '45 days'::interval))) THEN 1
            ELSE 0
        END AS "pending_invoice",
        CASE
            WHEN (("has_mei" = true) AND ("mei_cnpj" IS NULL)) THEN 1
            ELSE 0
        END AS "pending_mei_data",
        CASE
            WHEN ("contract_signed" = false) THEN 'CR├ìTICO: Sem contrato'::"text"
            WHEN ("requires_invoice" AND ("last_invoice_date" IS NULL)) THEN 'ALERTA: Nunca emitiu NF'::"text"
            WHEN ("requires_invoice" AND ("last_invoice_date" < (CURRENT_DATE - '45 days'::interval))) THEN 'ALERTA: NF atrasada'::"text"
            ELSE 'REGULAR'::"text"
        END AS "status_description"
   FROM "public"."service_providers" "sp"
  WHERE ("is_active" = true)
  ORDER BY
        CASE
            WHEN ("contract_signed" = false) THEN 1
            ELSE 2
        END, "name";


ALTER VIEW "public"."vw_provider_compliance" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_provider_compliance" IS 'Status de compliance dos prestadores de servi├ºo';



CREATE OR REPLACE VIEW "public"."vw_salary_comparison" WITH ("security_invoker"='true') AS
 SELECT "name" AS "funcionario",
    "role" AS "cargo",
    "hire_date" AS "admissao",
    "official_salary" AS "salario_carteira",
    "unofficial_salary" AS "valor_por_fora",
    ("official_salary" + "unofficial_salary") AS "remuneracao_total",
    "round"((("unofficial_salary" * (100)::numeric) / NULLIF(("official_salary" + "unofficial_salary"), (0)::numeric)), 1) AS "percentual_por_fora",
    ("salary_details" ->> 'justificativa_por_fora'::"text") AS "justificativa",
    ("salary_details" ->> 'forma_pagamento_por_fora'::"text") AS "forma_pagamento_extra",
        CASE
            WHEN ("unofficial_salary" = (0)::numeric) THEN 'Ô£à Regular'::"text"
            WHEN ((("unofficial_salary" * (100)::numeric) / NULLIF(("official_salary" + "unofficial_salary"), (0)::numeric)) > (50)::numeric) THEN '­ƒö┤ CR├ìTICO'::"text"
            WHEN ((("unofficial_salary" * (100)::numeric) / NULLIF(("official_salary" + "unofficial_salary"), (0)::numeric)) > (30)::numeric) THEN '­ƒƒá ALTO'::"text"
            ELSE '­ƒƒí MODERADO'::"text"
        END AS "nivel_risco",
    "round"((("official_salary" + "unofficial_salary") * 1.68), 2) AS "custo_se_regularizar",
    "round"(((("official_salary" + "unofficial_salary") * 1.68) - (("official_salary" * 1.68) + "unofficial_salary")), 2) AS "diferenca_custo"
   FROM "public"."employees" "e"
  WHERE ("is_active" AND ("contract_type" = 'clt'::"text"))
  ORDER BY (("unofficial_salary" * (100)::numeric) / NULLIF(("official_salary" + "unofficial_salary"), (0)::numeric)) DESC NULLS LAST;


ALTER VIEW "public"."vw_salary_comparison" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_salary_comparison" IS 'Comparativo entre valor na carteira e valor por fora';



CREATE OR REPLACE VIEW "public"."vw_sergio_advances_balance" WITH ("security_invoker"='true') AS
 WITH "expense_totals" AS (
         SELECT "cc"."id" AS "cost_center_id",
            "cc"."code" AS "cost_center_code",
            "cc"."name" AS "cost_center_name",
            COALESCE("pcc"."name", "cc"."name") AS "parent_name",
            "sum"(
                CASE
                    WHEN ("e"."status" = ANY (ARRAY['paid'::"text", 'pending'::"text", 'overdue'::"text"])) THEN "e"."amount"
                    ELSE (0)::numeric
                END) AS "total_advances"
           FROM (("public"."cost_centers" "cc"
             LEFT JOIN "public"."cost_centers" "pcc" ON (("cc"."parent_id" = "pcc"."id")))
             LEFT JOIN "public"."expenses" "e" ON (("e"."cost_center_id" = "cc"."id")))
          WHERE ("cc"."code" ~~ 'SERGIO%'::"text")
          GROUP BY "cc"."id", "cc"."code", "cc"."name", "pcc"."name"
        )
 SELECT "cost_center_code",
    "cost_center_name",
    "parent_name",
    "total_advances",
    '1.1.3.04.01'::"text" AS "account_code",
    'Adiantamentos - Sergio Carneiro Le├úo'::"text" AS "account_name"
   FROM "expense_totals"
  WHERE ("total_advances" > (0)::numeric)
  ORDER BY "parent_name", "cost_center_name";


ALTER VIEW "public"."vw_sergio_advances_balance" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_sergio_advances_balance" IS 'Saldo de adiantamentos por centro de custo do S├®rgio para reconcilia├º├úo mensal';



CREATE OR REPLACE VIEW "public"."vw_sora_queue_status" WITH ("security_invoker"='true') AS
 SELECT "sgq"."id" AS "queue_id",
    "svp"."project_name",
    "svp"."project_type",
    "sgq"."status",
    "sgq"."priority",
    "sgq"."attempts",
    "sgq"."queued_at",
    "sgq"."started_at",
        CASE
            WHEN ("sgq"."status" = 'processing'::"text") THEN (EXTRACT(epoch FROM ("now"() - "sgq"."started_at")))::integer
            ELSE NULL::integer
        END AS "processing_seconds",
    "sgq"."error_message"
   FROM ("public"."sora_generation_queue" "sgq"
     JOIN "public"."sora_video_projects" "svp" ON (("svp"."id" = "sgq"."project_id")))
  ORDER BY "sgq"."priority", "sgq"."queued_at";


ALTER VIEW "public"."vw_sora_queue_status" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_sora_videos_ready" WITH ("security_invoker"='true') AS
 SELECT "id",
    "project_name",
    "project_type",
    "duration_seconds",
    "video_url",
    "thumbnail_url",
    "status",
    "created_at",
    "approved_at",
        CASE
            WHEN (("video_url" IS NOT NULL) AND ("approved_at" IS NOT NULL)) THEN 'ready_to_publish'::"text"
            WHEN ("video_url" IS NOT NULL) THEN 'pending_approval'::"text"
            ELSE 'generating'::"text"
        END AS "publish_status"
   FROM "public"."sora_video_projects" "svp"
  WHERE ("status" = ANY (ARRAY['ready'::"text", 'published'::"text"]))
  ORDER BY "created_at" DESC;


ALTER VIEW "public"."vw_sora_videos_ready" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_terminations_detailed" WITH ("security_invoker"='true') AS
 SELECT "t"."id",
    "t"."employee_id",
    "t"."termination_date",
    "t"."last_working_day",
    "t"."notice_start_date",
    "t"."payment_deadline",
    "t"."termination_type",
    "t"."termination_reason",
    "t"."notice_type",
    "t"."notice_days",
    "t"."salary_at_termination",
    "t"."months_worked",
    "t"."years_worked",
    "t"."vacation_days_balance",
    "t"."thirteenth_months_due",
    "t"."saldo_salario",
    "t"."aviso_previo",
    "t"."ferias_vencidas",
    "t"."ferias_proporcionais",
    "t"."terco_constitucional",
    "t"."decimo_terceiro_proporcional",
    "t"."multa_fgts",
    "t"."saldo_fgts",
    "t"."desconto_aviso",
    "t"."desconto_vale_transporte",
    "t"."desconto_vale_alimentacao",
    "t"."desconto_inss",
    "t"."desconto_irrf",
    "t"."outros_descontos",
    "t"."total_proventos",
    "t"."total_descontos",
    "t"."valor_liquido",
    "t"."guia_fgts_rescisorio",
    "t"."guia_darf_irrf",
    "t"."status",
    "t"."accounting_entry_id",
    "t"."advocato_consultation",
    "t"."advocato_warnings",
    "t"."documents",
    "t"."calculated_at",
    "t"."calculated_by",
    "t"."approved_at",
    "t"."approved_by",
    "t"."paid_at",
    "t"."paid_by",
    "t"."notes",
    "t"."created_at",
    "t"."updated_at",
    "e"."name" AS "employee_name",
    "e"."role" AS "employee_role",
    "e"."cpf" AS "employee_cpf",
    "e"."hire_date" AS "employee_hire_date",
        CASE "t"."termination_type"
            WHEN 'dispensa_sem_justa_causa'::"text" THEN 'Dispensa sem Justa Causa'::"text"
            WHEN 'dispensa_com_justa_causa'::"text" THEN 'Dispensa com Justa Causa'::"text"
            WHEN 'pedido_demissao'::"text" THEN 'Pedido de Demiss├úo'::"text"
            WHEN 'acordo_mutuo'::"text" THEN 'Acordo M├║tuo'::"text"
            WHEN 'termino_contrato'::"text" THEN 'T├®rmino de Contrato'::"text"
            WHEN 'aposentadoria'::"text" THEN 'Aposentadoria'::"text"
            WHEN 'falecimento'::"text" THEN 'Falecimento'::"text"
            WHEN 'rescisao_indireta'::"text" THEN 'Rescis├úo Indireta'::"text"
            ELSE NULL::"text"
        END AS "termination_type_label",
        CASE "t"."status"
            WHEN 'rascunho'::"text" THEN 'Rascunho'::"text"
            WHEN 'calculada'::"text" THEN 'Calculada'::"text"
            WHEN 'aprovada'::"text" THEN 'Aprovada'::"text"
            WHEN 'homologada'::"text" THEN 'Homologada'::"text"
            WHEN 'paga'::"text" THEN 'Paga'::"text"
            WHEN 'cancelada'::"text" THEN 'Cancelada'::"text"
            ELSE NULL::"text"
        END AS "status_label"
   FROM ("public"."employee_terminations" "t"
     JOIN "public"."employees" "e" ON (("e"."id" = "t"."employee_id")))
  ORDER BY "t"."created_at" DESC;


ALTER VIEW "public"."vw_terminations_detailed" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."vw_videos_to_show" WITH ("security_invoker"='true') AS
 SELECT "mv"."id",
    "mv"."title",
    "mv"."description",
    "mv"."video_type",
    "mv"."target_audience",
    "mv"."video_url",
    "mv"."thumbnail_url",
    "mv"."duration_seconds",
    "mv"."script",
    "mv"."slides",
    "mv"."show_on_tvs",
    "mv"."priority",
    "mv"."start_date",
    "mv"."end_date",
    "mv"."show_times",
    "mv"."tags",
    "mv"."status",
    "mv"."approved_by",
    "mv"."created_by",
    "mv"."created_at",
    "tv"."tv_location",
    "tv"."tv_name"
   FROM ("public"."marketing_videos" "mv"
     CROSS JOIN "public"."tv_playlist" "tv")
  WHERE (("mv"."status" = 'active'::"text") AND ("mv"."show_on_tvs" = true) AND (("mv"."start_date" IS NULL) OR ("mv"."start_date" <= CURRENT_DATE)) AND (("mv"."end_date" IS NULL) OR ("mv"."end_date" >= CURRENT_DATE)) AND ("tv"."is_active" = true) AND ((CURRENT_TIME >= ("tv"."active_start_time")::time with time zone) AND (CURRENT_TIME <= ("tv"."active_end_time")::time with time zone)) AND (EXTRACT(dow FROM CURRENT_DATE) = ANY (("tv"."active_days")::numeric[])))
  ORDER BY "mv"."priority" DESC, "mv"."created_at";


ALTER VIEW "public"."vw_videos_to_show" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_videos_to_show" IS 'V├¡deos para exibir agora nas TVs';



CREATE OR REPLACE VIEW "public"."vw_work_orders_with_details" WITH ("security_invoker"='true') AS
 SELECT "wo"."id",
    "wo"."client_id",
    "c"."name" AS "client_name",
    "c"."cnpj" AS "client_cnpj",
    "c"."email" AS "client_email",
    "c"."phone" AS "client_phone",
    "wo"."invoice_id",
    "i"."competence" AS "invoice_competence",
    "i"."amount" AS "invoice_amount",
    "i"."due_date" AS "invoice_due_date",
    "i"."status" AS "invoice_status",
    "wo"."assigned_to",
    "wo"."assigned_at",
    "wo"."priority",
    "wo"."status",
    "wo"."action_type",
    "wo"."description",
    "wo"."next_action_date",
    "wo"."resolved_at",
    "wo"."resolution_notes",
    "wo"."created_at",
    "wo"."updated_at",
    ( SELECT "count"(*) AS "count"
           FROM "public"."collection_work_order_logs"
          WHERE ("collection_work_order_logs"."work_order_id" = "wo"."id")) AS "logs_count",
    ( SELECT "collection_work_order_logs"."created_at"
           FROM "public"."collection_work_order_logs"
          WHERE ("collection_work_order_logs"."work_order_id" = "wo"."id")
          ORDER BY "collection_work_order_logs"."created_at" DESC
         LIMIT 1) AS "last_log_date"
   FROM (("public"."collection_work_orders" "wo"
     LEFT JOIN "public"."clients" "c" ON (("wo"."client_id" = "c"."id")))
     LEFT JOIN "public"."invoices" "i" ON (("wo"."invoice_id" = "i"."id")))
  ORDER BY
        CASE "wo"."priority"
            WHEN 'high'::"text" THEN 1
            WHEN 'medium'::"text" THEN 2
            WHEN 'low'::"text" THEN 3
            ELSE NULL::integer
        END, "wo"."next_action_date";


ALTER VIEW "public"."vw_work_orders_with_details" OWNER TO "postgres";


COMMENT ON VIEW "public"."vw_work_orders_with_details" IS 'View completa de ordens de servi├ºo com informa├º├Áes de clientes e faturas';



CREATE TABLE IF NOT EXISTS "public"."workflow_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "trigger_data" "jsonb",
    "status" "text" DEFAULT 'running'::"text" NOT NULL,
    "steps_completed" integer DEFAULT 0,
    "steps_total" integer DEFAULT 0,
    "result" "jsonb",
    "error_message" "text",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "logs" "jsonb" DEFAULT '[]'::"jsonb",
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."workflow_executions" OWNER TO "postgres";


COMMENT ON TABLE "public"."workflow_executions" IS 'Hist├│rico de execu├º├Áes de workflows';



CREATE TABLE IF NOT EXISTS "public"."workflows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "trigger_type" "text" NOT NULL,
    "trigger_config" "jsonb" DEFAULT '{}'::"jsonb",
    "actions" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "conditions" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "execution_count" integer DEFAULT 0,
    "last_execution_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tenant_id" "uuid" NOT NULL
);


ALTER TABLE "public"."workflows" OWNER TO "postgres";


COMMENT ON TABLE "public"."workflows" IS 'Workflows de automa├º├úo configur├íveis';



ALTER TABLE ONLY "public"."accounting_entries" ALTER COLUMN "entry_number" SET DEFAULT "nextval"('"public"."accounting_entries_entry_number_seq"'::"regclass");



ALTER TABLE ONLY "public"."codigos_servico_lc116" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."codigos_servico_lc116_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."journal_entries" ALTER COLUMN "entry_number" SET DEFAULT "nextval"('"public"."journal_entries_entry_number_seq"'::"regclass");



ALTER TABLE ONLY "public"."purchase_lists" ALTER COLUMN "list_number" SET DEFAULT "nextval"('"public"."purchase_lists_list_number_seq"'::"regclass");



ALTER TABLE ONLY "public"."account_balances"
    ADD CONSTRAINT "account_balances_account_id_period_year_period_month_key" UNIQUE ("account_id", "period_year", "period_month");



ALTER TABLE ONLY "public"."account_balances"
    ADD CONSTRAINT "account_balances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "accounting_contracts_contract_number_key" UNIQUE ("contract_number");



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "accounting_contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "accounting_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_entry_items"
    ADD CONSTRAINT "accounting_entry_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_entry_lines"
    ADD CONSTRAINT "accounting_entry_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_entry_tracking"
    ADD CONSTRAINT "accounting_entry_tracking_codigo_rastreamento_key" UNIQUE ("codigo_rastreamento");



ALTER TABLE ONLY "public"."accounting_entry_tracking"
    ADD CONSTRAINT "accounting_entry_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_office"
    ADD CONSTRAINT "accounting_office_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_year_month_key" UNIQUE ("year", "month");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "accounting_provisions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounts_payable"
    ADD CONSTRAINT "accounts_payable_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_commissions"
    ADD CONSTRAINT "agent_commissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_agents"
    ADD CONSTRAINT "ai_agents_agent_id_unique" UNIQUE ("agent_id");



ALTER TABLE ONLY "public"."ai_agents"
    ADD CONSTRAINT "ai_agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_automation_logs"
    ADD CONSTRAINT "ai_automation_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_classification_history"
    ADD CONSTRAINT "ai_classification_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_classification_patterns"
    ADD CONSTRAINT "ai_classification_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_executions"
    ADD CONSTRAINT "ai_executions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_known_entities"
    ADD CONSTRAINT "ai_known_entities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_labor_consultations"
    ADD CONSTRAINT "ai_labor_consultations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_learned_patterns"
    ADD CONSTRAINT "ai_learned_patterns_description_pattern_key" UNIQUE ("description_pattern");



ALTER TABLE ONLY "public"."ai_learned_patterns"
    ADD CONSTRAINT "ai_learned_patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_meetings"
    ADD CONSTRAINT "ai_meetings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_page_agents"
    ADD CONSTRAINT "ai_page_agents_page_path_key" UNIQUE ("page_path");



ALTER TABLE ONLY "public"."ai_page_agents"
    ADD CONSTRAINT "ai_page_agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_pending_questions"
    ADD CONSTRAINT "ai_pending_questions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_presentations"
    ADD CONSTRAINT "ai_presentations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_providers"
    ADD CONSTRAINT "ai_providers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_providers"
    ADD CONSTRAINT "ai_providers_provider_code_key" UNIQUE ("provider_code");



ALTER TABLE ONLY "public"."ai_validation_queue"
    ADD CONSTRAINT "ai_validation_queue_entry_id_key" UNIQUE ("entry_id");



ALTER TABLE ONLY "public"."ai_validation_queue"
    ADD CONSTRAINT "ai_validation_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."auditoria_achados"
    ADD CONSTRAINT "auditoria_achados_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."auditoria_execucoes"
    ADD CONSTRAINT "auditoria_execucoes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."automation_logs"
    ADD CONSTRAINT "automation_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."balance_sheet_lines"
    ADD CONSTRAINT "balance_sheet_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."balance_sheets"
    ADD CONSTRAINT "balance_sheets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_accounts"
    ADD CONSTRAINT "bank_accounts_bank_code_agency_account_number_account_digit_key" UNIQUE ("bank_code", "agency", "account_number", "account_digit");



ALTER TABLE ONLY "public"."bank_accounts"
    ADD CONSTRAINT "bank_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_balance"
    ADD CONSTRAINT "bank_balance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_imports"
    ADD CONSTRAINT "bank_imports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_opening_balances"
    ADD CONSTRAINT "bank_opening_balances_bank_account_id_year_month_key" UNIQUE ("bank_account_id", "year", "month");



ALTER TABLE ONLY "public"."bank_opening_balances"
    ADD CONSTRAINT "bank_opening_balances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_statement_imports"
    ADD CONSTRAINT "bank_statement_imports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "bank_transaction_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_bank_reference_key" UNIQUE ("bank_reference");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."banking_credentials"
    ADD CONSTRAINT "banking_credentials_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."barter_credits"
    ADD CONSTRAINT "barter_credits_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "boleto_payments_nosso_numero_key" UNIQUE ("nosso_numero");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "boleto_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "boleto_report_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."boleto_reports"
    ADD CONSTRAINT "boleto_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."business_maturity_analysis"
    ADD CONSTRAINT "business_maturity_analysis_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cash_entries"
    ADD CONSTRAINT "cash_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cash_flow_projections"
    ADD CONSTRAINT "cash_flow_projections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cash_flow_transactions"
    ADD CONSTRAINT "cash_flow_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."classification_learning"
    ADD CONSTRAINT "classification_learning_keyword_chart_account_id_key" UNIQUE ("keyword", "chart_account_id");



ALTER TABLE ONLY "public"."classification_learning"
    ADD CONSTRAINT "classification_learning_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_commission_agents"
    ADD CONSTRAINT "client_commission_agents_client_id_agent_id_key" UNIQUE ("client_id", "agent_id");



ALTER TABLE ONLY "public"."client_commission_agents"
    ADD CONSTRAINT "client_commission_agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "client_contracts_contract_number_key" UNIQUE ("contract_number");



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "client_contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_distract_number_key" UNIQUE ("distract_number");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_enrichment"
    ADD CONSTRAINT "client_enrichment_client_id_key" UNIQUE ("client_id");



ALTER TABLE ONLY "public"."client_enrichment"
    ADD CONSTRAINT "client_enrichment_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_ledger"
    ADD CONSTRAINT "client_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_client_id_reference_month_key" UNIQUE ("client_id", "reference_month");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_client_id_reference_year_reference_m_key" UNIQUE ("client_id", "reference_year", "reference_month");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_opening_balance_history"
    ADD CONSTRAINT "client_opening_balance_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_opening_balance"
    ADD CONSTRAINT "client_opening_balance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_partners"
    ADD CONSTRAINT "client_partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_partners_prospects"
    ADD CONSTRAINT "client_partners_prospects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_payers"
    ADD CONSTRAINT "client_payers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_referrals"
    ADD CONSTRAINT "client_referrals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_variable_fees"
    ADD CONSTRAINT "client_variable_fees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_cnpj_key" UNIQUE ("cnpj");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."codigos_servico_lc116"
    ADD CONSTRAINT "codigos_servico_lc116_codigo_key" UNIQUE ("codigo");



ALTER TABLE ONLY "public"."codigos_servico_lc116"
    ADD CONSTRAINT "codigos_servico_lc116_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."collection_rules"
    ADD CONSTRAINT "collection_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."collection_work_order_logs"
    ADD CONSTRAINT "collection_work_order_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."collection_work_orders"
    ADD CONSTRAINT "collection_work_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."commission_agents"
    ADD CONSTRAINT "commission_agents_cpf_key" UNIQUE ("cpf");



ALTER TABLE ONLY "public"."commission_agents"
    ADD CONSTRAINT "commission_agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_partners"
    ADD CONSTRAINT "company_partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_profile"
    ADD CONSTRAINT "company_profile_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_service_costs"
    ADD CONSTRAINT "company_service_costs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_services"
    ADD CONSTRAINT "company_services_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."content_publish_queue"
    ADD CONSTRAINT "content_publish_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."content_templates"
    ADD CONSTRAINT "content_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."content_templates"
    ADD CONSTRAINT "content_templates_template_code_key" UNIQUE ("template_code");



ALTER TABLE ONLY "public"."contract_addendums"
    ADD CONSTRAINT "contract_addendums_addendum_number_key" UNIQUE ("addendum_number");



ALTER TABLE ONLY "public"."contract_addendums"
    ADD CONSTRAINT "contract_addendums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contract_templates"
    ADD CONSTRAINT "contract_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "contract_terminations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "contract_terminations_termination_number_key" UNIQUE ("termination_number");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_contract_number_key" UNIQUE ("contract_number");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "cost_center_accounts_cost_center_id_chart_account_id_key" UNIQUE ("cost_center_id", "chart_account_id");



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "cost_center_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "cost_centers_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "cost_centers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crm_clientes"
    ADD CONSTRAINT "crm_clientes_empresa_id_key" UNIQUE ("empresa_id");



ALTER TABLE ONLY "public"."crm_clientes"
    ADD CONSTRAINT "crm_clientes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crm_interacoes"
    ADD CONSTRAINT "crm_interacoes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crm_oportunidades"
    ADD CONSTRAINT "crm_oportunidades_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crm_prospects"
    ADD CONSTRAINT "crm_prospects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crm_tarefas"
    ADD CONSTRAINT "crm_tarefas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."dashboard_widgets"
    ADD CONSTRAINT "dashboard_widgets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."debt_confession_installments"
    ADD CONSTRAINT "debt_confession_installments_confession_id_installment_numb_key" UNIQUE ("confession_id", "installment_number");



ALTER TABLE ONLY "public"."debt_confession_installments"
    ADD CONSTRAINT "debt_confession_installments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."debt_confessions"
    ADD CONSTRAINT "debt_confessions_confession_number_key" UNIQUE ("confession_number");



ALTER TABLE ONLY "public"."debt_confessions"
    ADD CONSTRAINT "debt_confessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "debt_negotiations_negotiation_number_key" UNIQUE ("negotiation_number");



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "debt_negotiations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."discount_approval_rules"
    ADD CONSTRAINT "discount_approval_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."document_templates"
    ADD CONSTRAINT "document_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."domain_events"
    ADD CONSTRAINT "domain_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."dr_cicero_knowledge"
    ADD CONSTRAINT "dr_cicero_knowledge_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."economic_group_members"
    ADD CONSTRAINT "economic_group_members_economic_group_id_client_id_key" UNIQUE ("economic_group_id", "client_id");



ALTER TABLE ONLY "public"."economic_group_members"
    ADD CONSTRAINT "economic_group_members_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."economic_groups"
    ADD CONSTRAINT "economic_groups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employee_incentive_policies"
    ADD CONSTRAINT "employee_incentive_policies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employee_sales"
    ADD CONSTRAINT "employee_sales_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employee_terminations"
    ADD CONSTRAINT "employee_terminations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."empresas"
    ADD CONSTRAINT "empresas_cnpj_key" UNIQUE ("cnpj");



ALTER TABLE ONLY "public"."empresas"
    ADD CONSTRAINT "empresas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."enrichment_logs"
    ADD CONSTRAINT "enrichment_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "esocial_rubricas_codigo_key" UNIQUE ("codigo");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "esocial_rubricas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."expense_categories"
    ADD CONSTRAINT "expense_categories_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."expense_categories"
    ADD CONSTRAINT "expense_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."feature_analysis_history"
    ADD CONSTRAINT "feature_analysis_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."feature_requests"
    ADD CONSTRAINT "feature_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."feature_templates"
    ADD CONSTRAINT "feature_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."feature_templates"
    ADD CONSTRAINT "feature_templates_template_code_key" UNIQUE ("template_code");



ALTER TABLE ONLY "public"."fee_adjustment_history"
    ADD CONSTRAINT "fee_adjustment_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."file_processing_queue"
    ADD CONSTRAINT "file_processing_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."financial_analysis"
    ADD CONSTRAINT "financial_analysis_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."financial_gap_solutions"
    ADD CONSTRAINT "financial_gap_solutions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_fiscal_year_key" UNIQUE ("fiscal_year");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."generated_content"
    ADD CONSTRAINT "generated_content_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."grupos_economicos"
    ADD CONSTRAINT "grupos_economicos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."holidays"
    ADD CONSTRAINT "holidays_date_state_code_municipality_code_key" UNIQUE ("date", "state_code", "municipality_code");



ALTER TABLE ONLY "public"."holidays"
    ADD CONSTRAINT "holidays_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."import_files"
    ADD CONSTRAINT "import_files_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."initial_load_control"
    ADD CONSTRAINT "initial_load_control_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."intelligence_rules"
    ADD CONSTRAINT "intelligence_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoice_generation_rules"
    ADD CONSTRAINT "invoice_generation_rules_client_id_key" UNIQUE ("client_id");



ALTER TABLE ONLY "public"."invoice_generation_rules"
    ADD CONSTRAINT "invoice_generation_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoice_status_audit"
    ADD CONSTRAINT "invoice_status_audit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "irpf_declarations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "irpf_declarations_taxpayer_cpf_calendar_year_key" UNIQUE ("taxpayer_cpf", "calendar_year");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."journal_entry_lines"
    ADD CONSTRAINT "journal_entry_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."labor_alerts"
    ADD CONSTRAINT "labor_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."labor_jurisprudence"
    ADD CONSTRAINT "labor_jurisprudence_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."labor_legislation"
    ADD CONSTRAINT "labor_legislation_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."labor_solution_strategies"
    ADD CONSTRAINT "labor_solution_strategies_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."labor_solution_strategies"
    ADD CONSTRAINT "labor_solution_strategies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."logs_erros"
    ADD CONSTRAINT "logs_erros_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."logs_sincronizacao"
    ADD CONSTRAINT "logs_sincronizacao_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."marketing_videos"
    ADD CONSTRAINT "marketing_videos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."materialized_view_refresh_log"
    ADD CONSTRAINT "materialized_view_refresh_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."meeting_default_participants"
    ADD CONSTRAINT "meeting_default_participants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."message_templates"
    ADD CONSTRAINT "message_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."metrics_snapshots"
    ADD CONSTRAINT "metrics_snapshots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."minimum_wage_history"
    ADD CONSTRAINT "minimum_wage_history_effective_date_key" UNIQUE ("effective_date");



ALTER TABLE ONLY "public"."minimum_wage_history"
    ADD CONSTRAINT "minimum_wage_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."monthly_closings"
    ADD CONSTRAINT "monthly_closings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."monthly_closings"
    ADD CONSTRAINT "monthly_closings_year_month_key" UNIQUE ("year", "month");



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "negotiation_contact_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."negotiation_installments"
    ADD CONSTRAINT "negotiation_installments_negotiation_id_installment_number_key" UNIQUE ("negotiation_id", "installment_number");



ALTER TABLE ONLY "public"."negotiation_installments"
    ADD CONSTRAINT "negotiation_installments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nfse_config"
    ADD CONSTRAINT "nfse_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nfse_log"
    ADD CONSTRAINT "nfse_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "nfse_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "nfse_tomadas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "nfse_tomadas_unique" UNIQUE ("numero_nfse", "prestador_cnpj");



ALTER TABLE ONLY "public"."notifications_log"
    ADD CONSTRAINT "notifications_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."office_products"
    ADD CONSTRAINT "office_products_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."office_products"
    ADD CONSTRAINT "office_products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."office_recurring_expenses"
    ADD CONSTRAINT "office_recurring_expenses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."office_settings"
    ADD CONSTRAINT "office_settings_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."office_settings"
    ADD CONSTRAINT "office_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "organization_users_organization_id_user_id_key" UNIQUE ("organization_id", "user_id");



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "organization_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_cnpj_key" UNIQUE ("cnpj");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."parametros_folha"
    ADD CONSTRAINT "parametros_folha_parametro_key" UNIQUE ("parametro");



ALTER TABLE ONLY "public"."parametros_folha"
    ADD CONSTRAINT "parametros_folha_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_family"
    ADD CONSTRAINT "partner_family_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_properties"
    ADD CONSTRAINT "partner_properties_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partner_vehicles"
    ADD CONSTRAINT "partner_vehicles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."partners"
    ADD CONSTRAINT "partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payroll_details"
    ADD CONSTRAINT "payroll_details_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payroll"
    ADD CONSTRAINT "payroll_employee_id_competencia_key" UNIQUE ("employee_id", "competencia");



ALTER TABLE ONLY "public"."payroll_events"
    ADD CONSTRAINT "payroll_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payroll_journal_entries"
    ADD CONSTRAINT "payroll_journal_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payroll_payments"
    ADD CONSTRAINT "payroll_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payroll"
    ADD CONSTRAINT "payroll_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payrolls"
    ADD CONSTRAINT "payrolls_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payrolls"
    ADD CONSTRAINT "payrolls_reference_code_key" UNIQUE ("reference_code");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."perdcomp_pedidos"
    ADD CONSTRAINT "perdcomp_pedidos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."period_close_history"
    ADD CONSTRAINT "period_close_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."period_reopen_requests"
    ADD CONSTRAINT "period_reopen_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plr_criteria"
    ADD CONSTRAINT "plr_criteria_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plr_employee_share"
    ADD CONSTRAINT "plr_employee_share_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plr_programs"
    ADD CONSTRAINT "plr_programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_consumption"
    ADD CONSTRAINT "product_consumption_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_purchases"
    ADD CONSTRAINT "product_purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_prerequisites"
    ADD CONSTRAINT "program_prerequisites_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_prerequisites"
    ADD CONSTRAINT "program_prerequisites_program_code_key" UNIQUE ("program_code");



ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."provider_invoices"
    ADD CONSTRAINT "provider_invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_list_items"
    ADD CONSTRAINT "purchase_list_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_lists"
    ADD CONSTRAINT "purchase_lists_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."reconciliation_rules"
    ADD CONSTRAINT "reconciliation_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recurring_expense_templates"
    ADD CONSTRAINT "recurring_expense_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recurring_expenses"
    ADD CONSTRAINT "recurring_expenses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recurring_payments"
    ADD CONSTRAINT "recurring_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_commission_payments"
    ADD CONSTRAINT "referral_commission_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_partners"
    ADD CONSTRAINT "referral_partners_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_policy"
    ADD CONSTRAINT "referral_policy_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_program"
    ADD CONSTRAINT "referral_program_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "responsibility_letters_letter_number_key" UNIQUE ("letter_number");



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "responsibility_letters_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."retencoes_tributarias"
    ADD CONSTRAINT "retencoes_tributarias_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."revenue_categories"
    ADD CONSTRAINT "revenue_categories_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."revenue_categories"
    ADD CONSTRAINT "revenue_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."revenue_types"
    ADD CONSTRAINT "revenue_types_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."risk_solution_mapping"
    ADD CONSTRAINT "risk_solution_mapping_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sales_training_modules"
    ADD CONSTRAINT "sales_training_modules_module_code_key" UNIQUE ("module_code");



ALTER TABLE ONLY "public"."sales_training_modules"
    ADD CONSTRAINT "sales_training_modules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sales_training_records"
    ADD CONSTRAINT "sales_training_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."serpro_caixa_postal"
    ADD CONSTRAINT "serpro_caixa_postal_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_proposals"
    ADD CONSTRAINT "service_proposals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."service_proposals"
    ADD CONSTRAINT "service_proposals_proposal_number_key" UNIQUE ("proposal_number");



ALTER TABLE ONLY "public"."service_providers"
    ADD CONSTRAINT "service_providers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."solution_templates"
    ADD CONSTRAINT "solution_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."solution_templates"
    ADD CONSTRAINT "solution_templates_solution_code_key" UNIQUE ("solution_code");



ALTER TABLE ONLY "public"."sora_generation_queue"
    ADD CONSTRAINT "sora_generation_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sora_video_projects"
    ADD CONSTRAINT "sora_video_projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sora_video_templates"
    ADD CONSTRAINT "sora_video_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sora_video_templates"
    ADD CONSTRAINT "sora_video_templates_template_code_key" UNIQUE ("template_code");



ALTER TABLE ONLY "public"."stored_documents"
    ADD CONSTRAINT "stored_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_users"
    ADD CONSTRAINT "system_users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."system_users"
    ADD CONSTRAINT "system_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tabela_inss"
    ADD CONSTRAINT "tabela_inss_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tabela_irrf"
    ADD CONSTRAINT "tabela_irrf_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_configurations"
    ADD CONSTRAINT "tax_configurations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_configurations"
    ADD CONSTRAINT "tax_configurations_tax_code_key" UNIQUE ("tax_code");



ALTER TABLE ONLY "public"."tax_installments"
    ADD CONSTRAINT "tax_installments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_obligations"
    ADD CONSTRAINT "tax_obligations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tenant_features"
    ADD CONSTRAINT "tenant_features_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tenant_features"
    ADD CONSTRAINT "tenant_features_tenant_id_feature_key_key" UNIQUE ("tenant_id", "feature_key");



ALTER TABLE ONLY "public"."tenant_users"
    ADD CONSTRAINT "tenant_users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tenant_users"
    ADD CONSTRAINT "tenant_users_tenant_id_user_id_key" UNIQUE ("tenant_id", "user_id");



ALTER TABLE ONLY "public"."tenants"
    ADD CONSTRAINT "tenants_cnpj_key" UNIQUE ("cnpj");



ALTER TABLE ONLY "public"."tenants"
    ADD CONSTRAINT "tenants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tenants"
    ADD CONSTRAINT "tenants_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."trial_balance_lines"
    ADD CONSTRAINT "trial_balance_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trial_balances"
    ADD CONSTRAINT "trial_balances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tv_playlist"
    ADD CONSTRAINT "tv_playlist_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tv_video_playlist"
    ADD CONSTRAINT "tv_video_playlist_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bank_statement_imports"
    ADD CONSTRAINT "unique_file_hash" UNIQUE ("file_hash");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "unique_invoice_per_client_competence" UNIQUE ("client_id", "competence");



ALTER TABLE ONLY "public"."bank_statement_imports"
    ADD CONSTRAINT "unique_period_per_account" UNIQUE ("bank_account_id", "period_start", "period_end");



ALTER TABLE ONLY "public"."plr_employee_share"
    ADD CONSTRAINT "unique_plr_employee" UNIQUE ("program_id", "employee_id");



ALTER TABLE ONLY "public"."user_office_access"
    ADD CONSTRAINT "user_office_access_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_office_access"
    ADD CONSTRAINT "user_office_access_user_id_office_id_key" UNIQUE ("user_id", "office_id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "variable_fee_calculations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "variable_fee_calculations_variable_fee_id_reference_month_key" UNIQUE ("variable_fee_id", "reference_month");



ALTER TABLE ONLY "public"."video_branding_config"
    ADD CONSTRAINT "video_branding_config_config_name_key" UNIQUE ("config_name");



ALTER TABLE ONLY "public"."video_branding_config"
    ADD CONSTRAINT "video_branding_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_executions"
    ADD CONSTRAINT "workflow_executions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflows"
    ADD CONSTRAINT "workflows_pkey" PRIMARY KEY ("id");



CREATE UNIQUE INDEX "clients_cnpj_normalized_unique" ON "public"."clients" USING "btree" ("regexp_replace"(COALESCE("cnpj", ''::"text"), '[^0-9]'::"text", ''::"text", 'g'::"text")) WHERE (("cnpj" IS NOT NULL) AND ("length"(TRIM(BOTH FROM "cnpj")) > 0));




-- ============================================================================
-- SECAO 6: INDICES
-- ============================================================================
-- 686 indices para otimizacao de consultas:
--
-- TIPOS DE INDICES:
--   - B-tree: Indices padrao para ordenacao e busca
--   - Unique: Garantem unicidade de valores
--   - Parciais (WHERE): Filtram subconjuntos de dados
--   - Compostos: Multiplas colunas para queries frequentes
--
-- PADROES DE NOMENCLATURA:
--   - idx_<tabela>_<coluna>: Indice simples
--   - idx_<tabela>_tenant_id: Indice multi-tenant (presente em todas as tabelas)
--   - idx_<tabela>_<col1>_<col2>: Indice composto
-- ============================================================================

CREATE INDEX "idx_acc_contracts_created_by" ON "public"."accounting_contracts" USING "btree" ("created_by");



CREATE INDEX "idx_acc_contracts_proposal_id" ON "public"."accounting_contracts" USING "btree" ("proposal_id");



CREATE INDEX "idx_acc_entries_created_by" ON "public"."accounting_entries" USING "btree" ("created_by");



CREATE INDEX "idx_acc_entry_lines_cost_center" ON "public"."accounting_entry_lines" USING "btree" ("cost_center_id");



CREATE INDEX "idx_acc_periods_closed_by" ON "public"."accounting_periods" USING "btree" ("closed_by");



CREATE INDEX "idx_acc_periods_locked_by" ON "public"."accounting_periods" USING "btree" ("locked_by");



CREATE INDEX "idx_acc_provisions_created_by" ON "public"."accounting_provisions" USING "btree" ("created_by");



CREATE INDEX "idx_acc_provisions_journal_id" ON "public"."accounting_provisions" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_acc_provisions_realization_id" ON "public"."accounting_provisions" USING "btree" ("realization_entry_id");



CREATE INDEX "idx_account_balances_account" ON "public"."account_balances" USING "btree" ("account_id");



CREATE INDEX "idx_account_balances_period" ON "public"."account_balances" USING "btree" ("period_year", "period_month");



CREATE INDEX "idx_account_balances_tenant_id" ON "public"."account_balances" USING "btree" ("tenant_id");



CREATE UNIQUE INDEX "idx_account_ledger_id" ON "public"."account_ledger" USING "btree" ("account_id");



CREATE INDEX "idx_accounting_contracts_client" ON "public"."accounting_contracts" USING "btree" ("client_id");



CREATE INDEX "idx_accounting_contracts_number" ON "public"."accounting_contracts" USING "btree" ("contract_number");



CREATE INDEX "idx_accounting_contracts_status" ON "public"."accounting_contracts" USING "btree" ("status");



CREATE INDEX "idx_accounting_contracts_tenant_id" ON "public"."accounting_contracts" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_entries_ai_result" ON "public"."accounting_entries" USING "btree" ("ai_validation_result");



CREATE INDEX "idx_accounting_entries_ai_validated" ON "public"."accounting_entries" USING "btree" ("ai_validated") WHERE ("ai_validated" = false);



CREATE INDEX "idx_accounting_entries_competence" ON "public"."accounting_entries" USING "btree" ("competence_date");



CREATE INDEX "idx_accounting_entries_cost_center" ON "public"."accounting_entries" USING "btree" ("cost_center_id");



CREATE INDEX "idx_accounting_entries_date" ON "public"."accounting_entries" USING "btree" ("entry_date");



CREATE UNIQUE INDEX "idx_accounting_entries_internal_code" ON "public"."accounting_entries" USING "btree" ("internal_code") WHERE ("internal_code" IS NOT NULL);



CREATE INDEX "idx_accounting_entries_invoice" ON "public"."accounting_entries" USING "btree" ("invoice_id");



CREATE INDEX "idx_accounting_entries_number" ON "public"."accounting_entries" USING "btree" ("entry_number");



CREATE INDEX "idx_accounting_entries_reference" ON "public"."accounting_entries" USING "btree" ("reference_type", "reference_id");



CREATE INDEX "idx_accounting_entries_source" ON "public"."accounting_entries" USING "btree" ("source_type", "source_id") WHERE ("source_id" IS NOT NULL);



CREATE INDEX "idx_accounting_entries_tenant_id" ON "public"."accounting_entries" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_entries_transaction" ON "public"."accounting_entries" USING "btree" ("transaction_id");



CREATE INDEX "idx_accounting_entries_type" ON "public"."accounting_entries" USING "btree" ("entry_type");



CREATE UNIQUE INDEX "idx_accounting_entries_unique_reference" ON "public"."accounting_entries" USING "btree" ("reference_type", "reference_id", "entry_type") WHERE ("reference_id" IS NOT NULL);



CREATE INDEX "idx_accounting_entry_items_client" ON "public"."accounting_entry_items" USING "btree" ("client_id") WHERE ("client_id" IS NOT NULL);



CREATE INDEX "idx_accounting_entry_items_tenant_id" ON "public"."accounting_entry_items" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_entry_lines_account" ON "public"."accounting_entry_lines" USING "btree" ("account_id");



CREATE INDEX "idx_accounting_entry_lines_entry" ON "public"."accounting_entry_lines" USING "btree" ("entry_id");



CREATE INDEX "idx_accounting_entry_lines_tenant_id" ON "public"."accounting_entry_lines" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_entry_tracking_tenant_id" ON "public"."accounting_entry_tracking" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_office_tenant_id" ON "public"."accounting_office" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_periods_tenant_id" ON "public"."accounting_periods" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounting_periods_year_month" ON "public"."accounting_periods" USING "btree" ("year", "month");



CREATE INDEX "idx_accounting_provisions_tenant_id" ON "public"."accounting_provisions" USING "btree" ("tenant_id");



CREATE INDEX "idx_accounts_payable_approved_by" ON "public"."accounts_payable" USING "btree" ("approved_by");



CREATE INDEX "idx_accounts_payable_created_by" ON "public"."accounts_payable" USING "btree" ("created_by");



CREATE INDEX "idx_accounts_payable_due_date" ON "public"."accounts_payable" USING "btree" ("due_date");



CREATE INDEX "idx_accounts_payable_fraud_score" ON "public"."accounts_payable" USING "btree" ("ai_fraud_score");



CREATE INDEX "idx_accounts_payable_nfse_tomada" ON "public"."accounts_payable" USING "btree" ("nfse_tomada_id");



CREATE INDEX "idx_accounts_payable_parent" ON "public"."accounts_payable" USING "btree" ("parent_expense_id") WHERE ("parent_expense_id" IS NOT NULL);



CREATE INDEX "idx_accounts_payable_recurring" ON "public"."accounts_payable" USING "btree" ("is_recurring", "status") WHERE ("is_recurring" = true);



CREATE INDEX "idx_accounts_payable_status" ON "public"."accounts_payable" USING "btree" ("status");



CREATE INDEX "idx_accounts_payable_tenant_id" ON "public"."accounts_payable" USING "btree" ("tenant_id");



CREATE INDEX "idx_agent_commissions_agent" ON "public"."agent_commissions" USING "btree" ("agent_id");



CREATE INDEX "idx_agent_commissions_client" ON "public"."agent_commissions" USING "btree" ("client_id");



CREATE INDEX "idx_agent_commissions_competence" ON "public"."agent_commissions" USING "btree" ("competence");



CREATE INDEX "idx_agent_commissions_status" ON "public"."agent_commissions" USING "btree" ("status");



CREATE INDEX "idx_agent_commissions_tenant_id" ON "public"."agent_commissions" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_agents_active" ON "public"."ai_agents" USING "btree" ("is_active");



CREATE INDEX "idx_ai_agents_created_by" ON "public"."ai_agents" USING "btree" ("created_by");



CREATE INDEX "idx_ai_agents_tenant_id" ON "public"."ai_agents" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_agents_type" ON "public"."ai_agents" USING "btree" ("type");



CREATE INDEX "idx_ai_auto_logs_client" ON "public"."ai_automation_logs" USING "btree" ("client_id");



CREATE INDEX "idx_ai_automation_logs_date" ON "public"."ai_automation_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_ai_automation_logs_status" ON "public"."ai_automation_logs" USING "btree" ("status");



CREATE INDEX "idx_ai_automation_logs_tenant_id" ON "public"."ai_automation_logs" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_automation_logs_type" ON "public"."ai_automation_logs" USING "btree" ("automation_type");



CREATE INDEX "idx_ai_class_hist_bank_tx" ON "public"."ai_classification_history" USING "btree" ("bank_transaction_id");



CREATE INDEX "idx_ai_class_hist_entity" ON "public"."ai_classification_history" USING "btree" ("entity_id");



CREATE INDEX "idx_ai_class_hist_reviewed_by" ON "public"."ai_classification_history" USING "btree" ("reviewed_by");



CREATE INDEX "idx_ai_class_patterns_created_by" ON "public"."ai_classification_patterns" USING "btree" ("created_by");



CREATE INDEX "idx_ai_class_patterns_entity" ON "public"."ai_classification_patterns" USING "btree" ("entity_id");



CREATE INDEX "idx_ai_classification_history_tenant_id" ON "public"."ai_classification_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_classification_patterns_active" ON "public"."ai_classification_patterns" USING "btree" ("is_active");



CREATE INDEX "idx_ai_classification_patterns_pattern" ON "public"."ai_classification_patterns" USING "btree" ("transaction_pattern");



CREATE INDEX "idx_ai_classification_patterns_tenant_id" ON "public"."ai_classification_patterns" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_exec_executed_by" ON "public"."ai_executions" USING "btree" ("executed_by");



CREATE INDEX "idx_ai_executions_agent" ON "public"."ai_executions" USING "btree" ("agent_id");



CREATE INDEX "idx_ai_executions_client" ON "public"."ai_executions" USING "btree" ("client_id");



CREATE INDEX "idx_ai_executions_executed" ON "public"."ai_executions" USING "btree" ("executed_at" DESC);



CREATE INDEX "idx_ai_executions_status" ON "public"."ai_executions" USING "btree" ("status");



CREATE INDEX "idx_ai_executions_tenant_id" ON "public"."ai_executions" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_known_ent_created_by" ON "public"."ai_known_entities" USING "btree" ("created_by");



CREATE INDEX "idx_ai_known_entities_pattern" ON "public"."ai_known_entities" USING "btree" ("normalized_pattern");



CREATE INDEX "idx_ai_known_entities_tenant_id" ON "public"."ai_known_entities" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_known_entities_type" ON "public"."ai_known_entities" USING "btree" ("entity_type");



CREATE INDEX "idx_ai_labor_consultations_tenant_id" ON "public"."ai_labor_consultations" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_learned_pat_created_by" ON "public"."ai_learned_patterns" USING "btree" ("created_by");



CREATE INDEX "idx_ai_learned_patterns_description" ON "public"."ai_learned_patterns" USING "btree" ("description_pattern");



CREATE INDEX "idx_ai_learned_patterns_entry_type" ON "public"."ai_learned_patterns" USING "btree" ("entry_type");



CREATE INDEX "idx_ai_learned_patterns_tenant_id" ON "public"."ai_learned_patterns" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_meetings_tenant_id" ON "public"."ai_meetings" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_page_agents_tenant_id" ON "public"."ai_page_agents" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_pend_quest_answered_by" ON "public"."ai_pending_questions" USING "btree" ("answered_by");



CREATE INDEX "idx_ai_pend_quest_bank_tx" ON "public"."ai_pending_questions" USING "btree" ("bank_transaction_id");



CREATE INDEX "idx_ai_pending_questions_import" ON "public"."ai_pending_questions" USING "btree" ("import_id");



CREATE INDEX "idx_ai_pending_questions_status" ON "public"."ai_pending_questions" USING "btree" ("status");



CREATE INDEX "idx_ai_pending_questions_tenant_id" ON "public"."ai_pending_questions" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_present_meeting_id" ON "public"."ai_presentations" USING "btree" ("meeting_id");



CREATE INDEX "idx_ai_presentations_tenant_id" ON "public"."ai_presentations" USING "btree" ("tenant_id");



CREATE INDEX "idx_ai_validation_queue_status" ON "public"."ai_validation_queue" USING "btree" ("status", "priority") WHERE ("status" = ANY (ARRAY['pending'::"text", 'retry'::"text"]));



CREATE INDEX "idx_ai_validation_queue_tenant_id" ON "public"."ai_validation_queue" USING "btree" ("tenant_id");



CREATE INDEX "idx_audit_logs_audit_type" ON "public"."audit_logs" USING "btree" ("audit_type");



CREATE INDEX "idx_audit_logs_created" ON "public"."audit_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_audit_logs_created_by" ON "public"."audit_logs" USING "btree" ("created_by");



CREATE INDEX "idx_audit_logs_entity" ON "public"."audit_logs" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_audit_logs_resolved" ON "public"."audit_logs" USING "btree" ("resolved");



CREATE INDEX "idx_audit_logs_severity" ON "public"."audit_logs" USING "btree" ("severity");



CREATE INDEX "idx_audit_logs_table" ON "public"."audit_logs" USING "btree" ("table_name");



CREATE INDEX "idx_audit_logs_tenant_id" ON "public"."audit_logs" USING "btree" ("tenant_id");



CREATE INDEX "idx_audit_logs_user" ON "public"."audit_logs" USING "btree" ("user_id");



CREATE INDEX "idx_auditoria_achados_empresa" ON "public"."auditoria_achados" USING "btree" ("empresa_id");



CREATE INDEX "idx_auditoria_achados_nivel" ON "public"."auditoria_achados" USING "btree" ("nivel_risco");



CREATE INDEX "idx_auditoria_achados_tenant_id" ON "public"."auditoria_achados" USING "btree" ("tenant_id");



CREATE INDEX "idx_auditoria_execucoes_tenant_id" ON "public"."auditoria_execucoes" USING "btree" ("tenant_id");



CREATE INDEX "idx_automation_logs_tenant_id" ON "public"."automation_logs" USING "btree" ("tenant_id");



CREATE INDEX "idx_balance_sheet_lines_account" ON "public"."balance_sheet_lines" USING "btree" ("account_id");



CREATE INDEX "idx_balance_sheet_lines_sheet" ON "public"."balance_sheet_lines" USING "btree" ("balance_sheet_id");



CREATE INDEX "idx_balance_sheet_lines_tenant_id" ON "public"."balance_sheet_lines" USING "btree" ("tenant_id");



CREATE INDEX "idx_balance_sheets_closing_id" ON "public"."balance_sheets" USING "btree" ("fiscal_year_closing_id");



CREATE INDEX "idx_balance_sheets_created_by" ON "public"."balance_sheets" USING "btree" ("created_by");



CREATE INDEX "idx_balance_sheets_tenant_id" ON "public"."balance_sheets" USING "btree" ("tenant_id");



CREATE INDEX "idx_balance_sheets_year" ON "public"."balance_sheets" USING "btree" ("fiscal_year");



CREATE INDEX "idx_bank_accounts_client" ON "public"."bank_accounts" USING "btree" ("client_id");



CREATE INDEX "idx_bank_accounts_created_by" ON "public"."bank_accounts" USING "btree" ("created_by");



CREATE INDEX "idx_bank_accounts_is_active" ON "public"."bank_accounts" USING "btree" ("is_active");



CREATE INDEX "idx_bank_accounts_sync" ON "public"."bank_accounts" USING "btree" ("sync_enabled", "is_active");



CREATE INDEX "idx_bank_accounts_tenant_id" ON "public"."bank_accounts" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_balance_balance_date" ON "public"."bank_balance" USING "btree" ("balance_date");



CREATE INDEX "idx_bank_balance_created_by" ON "public"."bank_balance" USING "btree" ("created_by");



CREATE INDEX "idx_bank_balance_is_active" ON "public"."bank_balance" USING "btree" ("is_active");



CREATE INDEX "idx_bank_balance_tenant_id" ON "public"."bank_balance" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_imports_bank_account_id" ON "public"."bank_imports" USING "btree" ("bank_account_id");



CREATE INDEX "idx_bank_imports_date" ON "public"."bank_imports" USING "btree" ("import_date" DESC);



CREATE INDEX "idx_bank_imports_status" ON "public"."bank_imports" USING "btree" ("status");



CREATE INDEX "idx_bank_imports_tenant_id" ON "public"."bank_imports" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_opening_balances_account" ON "public"."bank_opening_balances" USING "btree" ("bank_account_id");



CREATE INDEX "idx_bank_opening_balances_period" ON "public"."bank_opening_balances" USING "btree" ("year", "month");



CREATE INDEX "idx_bank_opening_balances_tenant_id" ON "public"."bank_opening_balances" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_opening_source_closing" ON "public"."bank_opening_balances" USING "btree" ("source_closing_id");



CREATE INDEX "idx_bank_recon_boleto_item" ON "public"."bank_reconciliation" USING "btree" ("boleto_item_id");



CREATE INDEX "idx_bank_recon_reconciled_by" ON "public"."bank_reconciliation" USING "btree" ("reconciled_by");



CREATE INDEX "idx_bank_reconciliation_tenant_id" ON "public"."bank_reconciliation" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_statement_imports_period" ON "public"."bank_statement_imports" USING "btree" ("bank_account_id", "period_start", "period_end");



CREATE INDEX "idx_bank_statement_imports_tenant_id" ON "public"."bank_statement_imports" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_transaction_matches_client_id" ON "public"."bank_transaction_matches" USING "btree" ("client_id");



CREATE INDEX "idx_bank_transaction_matches_invoice_id" ON "public"."bank_transaction_matches" USING "btree" ("invoice_id");



CREATE INDEX "idx_bank_transaction_matches_tenant_id" ON "public"."bank_transaction_matches" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_transaction_matches_transaction_id" ON "public"."bank_transaction_matches" USING "btree" ("bank_transaction_id");



CREATE INDEX "idx_bank_transactions_account_id" ON "public"."bank_transactions" USING "btree" ("bank_account_id");



CREATE INDEX "idx_bank_transactions_accounts_payable_id" ON "public"."bank_transactions" USING "btree" ("accounts_payable_id");



CREATE INDEX "idx_bank_transactions_cost_center" ON "public"."bank_transactions" USING "btree" ("cost_center_id");



CREATE INDEX "idx_bank_transactions_date" ON "public"."bank_transactions" USING "btree" ("transaction_date");



CREATE INDEX "idx_bank_transactions_expense_id" ON "public"."bank_transactions" USING "btree" ("expense_id");



CREATE INDEX "idx_bank_transactions_fitid" ON "public"."bank_transactions" USING "btree" ("fitid");



CREATE UNIQUE INDEX "idx_bank_transactions_fitid_unique" ON "public"."bank_transactions" USING "btree" ("bank_account_id", "fitid") WHERE ("fitid" IS NOT NULL);



CREATE INDEX "idx_bank_transactions_import" ON "public"."bank_transactions" USING "btree" ("import_id") WHERE ("import_id" IS NOT NULL);



CREATE UNIQUE INDEX "idx_bank_transactions_internal_code" ON "public"."bank_transactions" USING "btree" ("internal_code") WHERE ("internal_code" IS NOT NULL);



CREATE INDEX "idx_bank_transactions_invoice_id" ON "public"."bank_transactions" USING "btree" ("invoice_id");



CREATE INDEX "idx_bank_transactions_journal" ON "public"."bank_transactions" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_bank_transactions_matched" ON "public"."bank_transactions" USING "btree" ("matched");



CREATE INDEX "idx_bank_transactions_reconciled" ON "public"."bank_transactions" USING "btree" ("is_reconciled");



CREATE INDEX "idx_bank_transactions_tenant_id" ON "public"."bank_transactions" USING "btree" ("tenant_id");



CREATE INDEX "idx_bank_tx_chart_account" ON "public"."bank_transactions" USING "btree" ("chart_account_id");



CREATE INDEX "idx_bank_tx_created_by" ON "public"."bank_transactions" USING "btree" ("created_by");



CREATE INDEX "idx_bank_tx_matches_expense" ON "public"."bank_transaction_matches" USING "btree" ("expense_id");



CREATE INDEX "idx_bank_tx_pending_classification" ON "public"."bank_transactions" USING "btree" ("ai_suggestion") WHERE ("ai_suggestion" ~~ '%PENDENTE%'::"text");



CREATE INDEX "idx_banking_credentials_active" ON "public"."banking_credentials" USING "btree" ("is_active");



CREATE INDEX "idx_banking_credentials_bank" ON "public"."banking_credentials" USING "btree" ("bank_name");



CREATE INDEX "idx_banking_credentials_created_by" ON "public"."banking_credentials" USING "btree" ("created_by");



CREATE INDEX "idx_banking_credentials_tenant_id" ON "public"."banking_credentials" USING "btree" ("tenant_id");



CREATE INDEX "idx_barter_credits_client_id" ON "public"."barter_credits" USING "btree" ("client_id");



CREATE INDEX "idx_barter_credits_competence" ON "public"."barter_credits" USING "btree" ("competence");



CREATE INDEX "idx_barter_credits_reference_date" ON "public"."barter_credits" USING "btree" ("reference_date" DESC);



CREATE INDEX "idx_barter_credits_tenant_id" ON "public"."barter_credits" USING "btree" ("tenant_id");



CREATE INDEX "idx_boleto_items_status" ON "public"."boleto_report_items" USING "btree" ("status");



CREATE INDEX "idx_boleto_pay_invoice" ON "public"."boleto_payments" USING "btree" ("invoice_id");



CREATE INDEX "idx_boleto_payments_bank_tx" ON "public"."boleto_payments" USING "btree" ("bank_transaction_id");



CREATE INDEX "idx_boleto_payments_client" ON "public"."boleto_payments" USING "btree" ("client_id");



CREATE INDEX "idx_boleto_payments_cob" ON "public"."boleto_payments" USING "btree" ("cob");



CREATE INDEX "idx_boleto_payments_data_extrato" ON "public"."boleto_payments" USING "btree" ("data_extrato");



CREATE INDEX "idx_boleto_payments_tenant_id" ON "public"."boleto_payments" USING "btree" ("tenant_id");



CREATE INDEX "idx_boleto_rep_items_entry" ON "public"."boleto_report_items" USING "btree" ("accounting_entry_id");



CREATE INDEX "idx_boleto_rep_uploaded_by" ON "public"."boleto_reports" USING "btree" ("uploaded_by");



CREATE INDEX "idx_boleto_report_items_client_id" ON "public"."boleto_report_items" USING "btree" ("client_id");



CREATE INDEX "idx_boleto_report_items_invoice_id" ON "public"."boleto_report_items" USING "btree" ("invoice_id");



CREATE INDEX "idx_boleto_report_items_report_id" ON "public"."boleto_report_items" USING "btree" ("report_id");



CREATE INDEX "idx_boleto_report_items_tenant_id" ON "public"."boleto_report_items" USING "btree" ("tenant_id");



CREATE INDEX "idx_boleto_reports_created_at" ON "public"."boleto_reports" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_boleto_reports_period" ON "public"."boleto_reports" USING "btree" ("period_start", "period_end");



CREATE INDEX "idx_boleto_reports_status" ON "public"."boleto_reports" USING "btree" ("status");



CREATE INDEX "idx_boleto_reports_tenant_id" ON "public"."boleto_reports" USING "btree" ("tenant_id");



CREATE INDEX "idx_business_maturity_analysis_tenant_id" ON "public"."business_maturity_analysis" USING "btree" ("tenant_id");



CREATE INDEX "idx_caixa_data" ON "public"."serpro_caixa_postal" USING "btree" ("data_envio" DESC);



CREATE INDEX "idx_caixa_empresa" ON "public"."serpro_caixa_postal" USING "btree" ("empresa_id");



CREATE INDEX "idx_caixa_lida" ON "public"."serpro_caixa_postal" USING "btree" ("lida");



CREATE INDEX "idx_caixa_prioridade" ON "public"."serpro_caixa_postal" USING "btree" ("prioridade");



CREATE UNIQUE INDEX "idx_caixa_unico" ON "public"."serpro_caixa_postal" USING "btree" ("empresa_id", "numero_mensagem");



CREATE INDEX "idx_cash_entries_account" ON "public"."cash_entries" USING "btree" ("account_id");



CREATE INDEX "idx_cash_entries_cost_center" ON "public"."cash_entries" USING "btree" ("cost_center_id");



CREATE INDEX "idx_cash_entries_created_by" ON "public"."cash_entries" USING "btree" ("created_by");



CREATE INDEX "idx_cash_entries_entry_date" ON "public"."cash_entries" USING "btree" ("entry_date");



CREATE INDEX "idx_cash_entries_entry_type" ON "public"."cash_entries" USING "btree" ("entry_type");



CREATE INDEX "idx_cash_entries_tenant_id" ON "public"."cash_entries" USING "btree" ("tenant_id");



CREATE INDEX "idx_cash_flow_projections_active" ON "public"."cash_flow_projections" USING "btree" ("is_active");



CREATE INDEX "idx_cash_flow_projections_date" ON "public"."cash_flow_projections" USING "btree" ("projection_date");



CREATE INDEX "idx_cash_flow_projections_type" ON "public"."cash_flow_projections" USING "btree" ("projection_type");



CREATE INDEX "idx_cash_flow_transactions_created_by" ON "public"."cash_flow_transactions" USING "btree" ("created_by");



CREATE INDEX "idx_cash_flow_transactions_date" ON "public"."cash_flow_transactions" USING "btree" ("transaction_date");



CREATE INDEX "idx_cash_flow_transactions_status" ON "public"."cash_flow_transactions" USING "btree" ("status");



CREATE INDEX "idx_cash_flow_transactions_tenant_id" ON "public"."cash_flow_transactions" USING "btree" ("tenant_id");



CREATE INDEX "idx_cash_flow_transactions_type" ON "public"."cash_flow_transactions" USING "btree" ("transaction_type");



CREATE INDEX "idx_cash_flow_tx_bank_account" ON "public"."cash_flow_transactions" USING "btree" ("bank_account_id");



CREATE INDEX "idx_chart_accounts_code" ON "public"."chart_of_accounts" USING "btree" ("code");



CREATE INDEX "idx_chart_accounts_created_by" ON "public"."chart_of_accounts" USING "btree" ("created_by");



CREATE INDEX "idx_chart_accounts_parent" ON "public"."chart_of_accounts" USING "btree" ("parent_id");



CREATE INDEX "idx_chart_accounts_type" ON "public"."chart_of_accounts" USING "btree" ("account_type");



CREATE INDEX "idx_chart_of_accounts_tenant_id" ON "public"."chart_of_accounts" USING "btree" ("tenant_id");



CREATE INDEX "idx_class_learn_chart_account" ON "public"."classification_learning" USING "btree" ("chart_account_id");



CREATE INDEX "idx_classification_keyword" ON "public"."classification_learning" USING "btree" ("keyword");



CREATE INDEX "idx_classification_learning_tenant_id" ON "public"."classification_learning" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_commission_agents_agent" ON "public"."client_commission_agents" USING "btree" ("agent_id");



CREATE INDEX "idx_client_commission_agents_client" ON "public"."client_commission_agents" USING "btree" ("client_id");



CREATE INDEX "idx_client_commission_agents_tenant_id" ON "public"."client_commission_agents" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_contacts_client" ON "public"."client_contacts" USING "btree" ("client_id");



CREATE INDEX "idx_client_contacts_created_by" ON "public"."client_contacts" USING "btree" ("created_by");



CREATE INDEX "idx_client_contacts_tenant_id" ON "public"."client_contacts" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_contacts_type" ON "public"."client_contacts" USING "btree" ("contact_type");



CREATE INDEX "idx_client_contracts_client" ON "public"."client_contracts" USING "btree" ("client_id");



CREATE INDEX "idx_client_contracts_created_by" ON "public"."client_contracts" USING "btree" ("created_by");



CREATE INDEX "idx_client_contracts_status" ON "public"."client_contracts" USING "btree" ("status");



CREATE INDEX "idx_client_contracts_template" ON "public"."client_contracts" USING "btree" ("template_id");



CREATE INDEX "idx_client_contracts_tenant_id" ON "public"."client_contracts" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_distracts_client" ON "public"."client_distracts" USING "btree" ("client_id");



CREATE INDEX "idx_client_distracts_contract" ON "public"."client_distracts" USING "btree" ("contract_id");



CREATE INDEX "idx_client_distracts_created_by" ON "public"."client_distracts" USING "btree" ("created_by");



CREATE INDEX "idx_client_distracts_template" ON "public"."client_distracts" USING "btree" ("template_id");



CREATE INDEX "idx_client_distracts_tenant_id" ON "public"."client_distracts" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_enrichment_client_id" ON "public"."client_enrichment" USING "btree" ("client_id");



CREATE INDEX "idx_client_enrichment_cnpj" ON "public"."client_enrichment" USING "btree" ("cnpj");



CREATE INDEX "idx_client_enrichment_tenant_id" ON "public"."client_enrichment" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_ledger_client" ON "public"."client_ledger" USING "btree" ("client_id");



CREATE INDEX "idx_client_ledger_created_by" ON "public"."client_ledger" USING "btree" ("created_by");



CREATE INDEX "idx_client_ledger_date" ON "public"."client_ledger" USING "btree" ("transaction_date");



CREATE INDEX "idx_client_ledger_invoice" ON "public"."client_ledger" USING "btree" ("invoice_id");



CREATE INDEX "idx_client_ledger_tenant_id" ON "public"."client_ledger" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_m_rev_created_by" ON "public"."client_monthly_revenue" USING "btree" ("created_by");



CREATE INDEX "idx_client_m_rev_invoice" ON "public"."client_monthly_revenue" USING "btree" ("invoice_id");



CREATE INDEX "idx_client_monthly_revenue_client" ON "public"."client_monthly_revenue" USING "btree" ("client_id");



CREATE INDEX "idx_client_monthly_revenue_client_month" ON "public"."client_monthly_revenue" USING "btree" ("client_id", "reference_month");



CREATE INDEX "idx_client_monthly_revenue_month" ON "public"."client_monthly_revenue" USING "btree" ("reference_month");



CREATE INDEX "idx_client_monthly_revenue_tenant_id" ON "public"."client_monthly_revenue" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_open_bal_hist_client" ON "public"."client_opening_balance_history" USING "btree" ("client_id");



CREATE INDEX "idx_client_opening_balance_history_tenant_id" ON "public"."client_opening_balance_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_opening_balance_tenant_id" ON "public"."client_opening_balance" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_partners_client" ON "public"."client_partners" USING "btree" ("client_id");



CREATE INDEX "idx_client_partners_cpf" ON "public"."client_partners" USING "btree" ("cpf") WHERE ("cpf" IS NOT NULL);



CREATE INDEX "idx_client_partners_name" ON "public"."client_partners" USING "btree" ("name");



CREATE INDEX "idx_client_partners_partner" ON "public"."client_partners" USING "btree" ("partner_id");



CREATE INDEX "idx_client_partners_prospects_tenant_id" ON "public"."client_partners_prospects" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_partners_tenant_id" ON "public"."client_partners" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_payers_client_id" ON "public"."client_payers" USING "btree" ("client_id");



CREATE INDEX "idx_client_payers_document" ON "public"."client_payers" USING "btree" ("payer_document");



CREATE INDEX "idx_client_payers_name" ON "public"."client_payers" USING "gin" ("to_tsvector"('"portuguese"'::"regconfig", "payer_name"));



CREATE INDEX "idx_client_payers_tenant_id" ON "public"."client_payers" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_referrals_tenant_id" ON "public"."client_referrals" USING "btree" ("tenant_id");



CREATE INDEX "idx_client_var_fees_created_by" ON "public"."client_variable_fees" USING "btree" ("created_by");



CREATE INDEX "idx_client_variable_fees_tenant_id" ON "public"."client_variable_fees" USING "btree" ("tenant_id");



CREATE INDEX "idx_clients_account_id" ON "public"."clients" USING "btree" ("account_id");



CREATE INDEX "idx_clients_accounting_account" ON "public"."clients" USING "btree" ("accounting_account_id");



CREATE INDEX "idx_clients_active" ON "public"."clients" USING "btree" ("is_active");



CREATE INDEX "idx_clients_barter" ON "public"."clients" USING "btree" ("is_barter") WHERE ("is_barter" = true);



CREATE INDEX "idx_clients_cnpj" ON "public"."clients" USING "btree" ("cnpj");



CREATE UNIQUE INDEX "idx_clients_cnpj_normalized" ON "public"."clients" USING "btree" ("regexp_replace"("cnpj", '[^0-9]'::"text", ''::"text", 'g'::"text")) WHERE (("cnpj" IS NOT NULL) AND ("status" = 'active'::"text"));



CREATE INDEX "idx_clients_cnpj_root" ON "public"."clients" USING "btree" ("public"."get_cnpj_root"("cnpj")) WHERE (("cnpj" IS NOT NULL) AND ("btrim"("cnpj") <> ''::"text") AND ("status" = 'active'::"text"));



CREATE INDEX "idx_clients_cnpj_search" ON "public"."clients" USING "gin" ("to_tsvector"('"portuguese"'::"regconfig", "regexp_replace"("cnpj", '[^0-9]'::"text", ''::"text", 'g'::"text")));



CREATE INDEX "idx_clients_contract_dates" ON "public"."clients" USING "btree" ("contract_start_date", "contract_end_date");



CREATE INDEX "idx_clients_cpf" ON "public"."clients" USING "btree" ("cpf") WHERE ("cpf" IS NOT NULL);



CREATE INDEX "idx_clients_created_by" ON "public"."clients" USING "btree" ("created_by");



CREATE INDEX "idx_clients_is_internal" ON "public"."clients" USING "btree" ("is_internal") WHERE ("is_internal" = true);



CREATE INDEX "idx_clients_pro_bono" ON "public"."clients" USING "btree" ("is_pro_bono") WHERE ("is_pro_bono" = true);



CREATE INDEX "idx_clients_status" ON "public"."clients" USING "btree" ("status");



CREATE INDEX "idx_clients_tenant_id" ON "public"."clients" USING "btree" ("tenant_id");



CREATE INDEX "idx_codigos_servico_ativo" ON "public"."codigos_servico_lc116" USING "btree" ("ativo");



CREATE INDEX "idx_codigos_servico_codigo" ON "public"."codigos_servico_lc116" USING "btree" ("codigo");



CREATE INDEX "idx_coll_work_order_logs_created" ON "public"."collection_work_order_logs" USING "btree" ("created_by");



CREATE INDEX "idx_coll_work_orders_created_by" ON "public"."collection_work_orders" USING "btree" ("created_by");



CREATE INDEX "idx_collection_rules_active" ON "public"."collection_rules" USING "btree" ("is_active");



CREATE INDEX "idx_collection_rules_created_by" ON "public"."collection_rules" USING "btree" ("created_by");



CREATE INDEX "idx_collection_rules_template" ON "public"."collection_rules" USING "btree" ("template_id");



CREATE INDEX "idx_collection_rules_tenant_id" ON "public"."collection_rules" USING "btree" ("tenant_id");



CREATE INDEX "idx_collection_work_order_logs_tenant_id" ON "public"."collection_work_order_logs" USING "btree" ("tenant_id");



CREATE INDEX "idx_collection_work_orders_tenant_id" ON "public"."collection_work_orders" USING "btree" ("tenant_id");



CREATE INDEX "idx_commission_agents_cpf" ON "public"."commission_agents" USING "btree" ("cpf");



CREATE INDEX "idx_commission_agents_pix" ON "public"."commission_agents" USING "btree" ("pix_key");



CREATE INDEX "idx_commission_agents_tenant_id" ON "public"."commission_agents" USING "btree" ("tenant_id");



CREATE INDEX "idx_company_partners_company" ON "public"."company_partners" USING "btree" ("company_id");



CREATE INDEX "idx_company_partners_tenant_id" ON "public"."company_partners" USING "btree" ("tenant_id");



CREATE INDEX "idx_company_profile_tenant_id" ON "public"."company_profile" USING "btree" ("tenant_id");



CREATE INDEX "idx_company_service_costs_tenant_id" ON "public"."company_service_costs" USING "btree" ("tenant_id");



CREATE INDEX "idx_company_services_client" ON "public"."company_services" USING "btree" ("client_id");



CREATE INDEX "idx_company_services_created_by" ON "public"."company_services" USING "btree" ("created_by");



CREATE INDEX "idx_company_services_status" ON "public"."company_services" USING "btree" ("service_status");



CREATE INDEX "idx_company_services_tenant_id" ON "public"."company_services" USING "btree" ("tenant_id");



CREATE INDEX "idx_company_svc_costs_bank_tx" ON "public"."company_service_costs" USING "btree" ("bank_transaction_id");



CREATE INDEX "idx_company_svc_costs_service" ON "public"."company_service_costs" USING "btree" ("service_id");



CREATE INDEX "idx_contact_history_client" ON "public"."negotiation_contact_history" USING "btree" ("client_id");



CREATE INDEX "idx_contact_history_date" ON "public"."negotiation_contact_history" USING "btree" ("created_at");



CREATE INDEX "idx_contact_history_negotiation" ON "public"."negotiation_contact_history" USING "btree" ("negotiation_id");



CREATE INDEX "idx_content_publish_queue_tenant_id" ON "public"."content_publish_queue" USING "btree" ("tenant_id");



CREATE INDEX "idx_content_templates_tenant_id" ON "public"."content_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_contract_addendums_contract" ON "public"."contract_addendums" USING "btree" ("contract_id");



CREATE INDEX "idx_contract_addendums_created" ON "public"."contract_addendums" USING "btree" ("created_by");



CREATE INDEX "idx_contract_addendums_status" ON "public"."contract_addendums" USING "btree" ("status");



CREATE INDEX "idx_contract_addendums_tenant_id" ON "public"."contract_addendums" USING "btree" ("tenant_id");



CREATE INDEX "idx_contract_templates_tenant_id" ON "public"."contract_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_contract_terminations_client" ON "public"."contract_terminations" USING "btree" ("client_id");



CREATE INDEX "idx_contract_terminations_contract" ON "public"."contract_terminations" USING "btree" ("contract_id");



CREATE INDEX "idx_contract_terminations_status" ON "public"."contract_terminations" USING "btree" ("status");



CREATE INDEX "idx_contract_terminations_tenant_id" ON "public"."contract_terminations" USING "btree" ("tenant_id");



CREATE INDEX "idx_contract_terms_created_by" ON "public"."contract_terminations" USING "btree" ("created_by");



CREATE INDEX "idx_contracts_client" ON "public"."contracts" USING "btree" ("client_id");



CREATE INDEX "idx_contracts_created_by" ON "public"."contracts" USING "btree" ("created_by");



CREATE INDEX "idx_contracts_document_id" ON "public"."contracts" USING "btree" ("document_id");



CREATE INDEX "idx_contracts_proposal_id" ON "public"."contracts" USING "btree" ("proposal_id");



CREATE INDEX "idx_contracts_status" ON "public"."contracts" USING "btree" ("status");



CREATE INDEX "idx_contracts_tenant_id" ON "public"."contracts" USING "btree" ("tenant_id");



CREATE INDEX "idx_cost_center_acc_created_by" ON "public"."cost_center_accounts" USING "btree" ("created_by");



CREATE INDEX "idx_cost_center_accounts_chart_account" ON "public"."cost_center_accounts" USING "btree" ("chart_account_id");



CREATE INDEX "idx_cost_center_accounts_cost_center" ON "public"."cost_center_accounts" USING "btree" ("cost_center_id");



CREATE INDEX "idx_cost_center_accounts_tenant_id" ON "public"."cost_center_accounts" USING "btree" ("tenant_id");



CREATE INDEX "idx_cost_centers_default_account" ON "public"."cost_centers" USING "btree" ("default_chart_account_id");



CREATE INDEX "idx_cost_centers_parent" ON "public"."cost_centers" USING "btree" ("parent_id");



CREATE INDEX "idx_cost_centers_tenant_id" ON "public"."cost_centers" USING "btree" ("tenant_id");



CREATE INDEX "idx_crm_clientes_tenant_id" ON "public"."crm_clientes" USING "btree" ("tenant_id");



CREATE INDEX "idx_crm_interacoes_tenant_id" ON "public"."crm_interacoes" USING "btree" ("tenant_id");



CREATE INDEX "idx_crm_oportunidades_tenant_id" ON "public"."crm_oportunidades" USING "btree" ("tenant_id");



CREATE INDEX "idx_crm_prospects_empresa" ON "public"."crm_prospects" USING "btree" ("empresa_id");



CREATE INDEX "idx_crm_prospects_status" ON "public"."crm_prospects" USING "btree" ("status");



CREATE INDEX "idx_crm_prospects_tenant_id" ON "public"."crm_prospects" USING "btree" ("tenant_id");



CREATE INDEX "idx_crm_tarefas_tenant_id" ON "public"."crm_tarefas" USING "btree" ("tenant_id");



CREATE INDEX "idx_dashboard_widgets_tenant_id" ON "public"."dashboard_widgets" USING "btree" ("tenant_id");



CREATE INDEX "idx_dashboard_widgets_user" ON "public"."dashboard_widgets" USING "btree" ("user_id");



CREATE INDEX "idx_debt_confession_installments_confession" ON "public"."debt_confession_installments" USING "btree" ("confession_id");



CREATE INDEX "idx_debt_confession_installments_due_date" ON "public"."debt_confession_installments" USING "btree" ("due_date");



CREATE INDEX "idx_debt_confession_installments_tenant_id" ON "public"."debt_confession_installments" USING "btree" ("tenant_id");



CREATE INDEX "idx_debt_confessions_client" ON "public"."debt_confessions" USING "btree" ("client_id");



CREATE INDEX "idx_debt_confessions_number" ON "public"."debt_confessions" USING "btree" ("confession_number");



CREATE INDEX "idx_debt_confessions_status" ON "public"."debt_confessions" USING "btree" ("status");



CREATE INDEX "idx_debt_confessions_tenant_id" ON "public"."debt_confessions" USING "btree" ("tenant_id");



CREATE INDEX "idx_debt_negotiations_client" ON "public"."debt_negotiations" USING "btree" ("client_id");



CREATE INDEX "idx_debt_negotiations_number" ON "public"."debt_negotiations" USING "btree" ("negotiation_number");



CREATE INDEX "idx_debt_negotiations_status" ON "public"."debt_negotiations" USING "btree" ("status");



CREATE INDEX "idx_debt_negotiations_tenant_id" ON "public"."debt_negotiations" USING "btree" ("tenant_id");



CREATE INDEX "idx_discount_approval_rules_tenant_id" ON "public"."discount_approval_rules" USING "btree" ("tenant_id");



CREATE INDEX "idx_document_templates_tenant_id" ON "public"."document_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_documents_client" ON "public"."documents" USING "btree" ("client_id");



CREATE INDEX "idx_documents_expense_id" ON "public"."documents" USING "btree" ("expense_id");



CREATE INDEX "idx_documents_invoice" ON "public"."documents" USING "btree" ("invoice_id");



CREATE INDEX "idx_documents_ocr" ON "public"."documents" USING "btree" ("ocr_processed");



CREATE INDEX "idx_documents_tenant_id" ON "public"."documents" USING "btree" ("tenant_id");



CREATE INDEX "idx_documents_type" ON "public"."documents" USING "btree" ("type");



CREATE INDEX "idx_documents_uploaded_by" ON "public"."documents" USING "btree" ("uploaded_by");



CREATE INDEX "idx_domain_events_aggregate" ON "public"."domain_events" USING "btree" ("aggregate_type", "aggregate_id");



CREATE INDEX "idx_domain_events_correlation" ON "public"."domain_events" USING "btree" ("correlation_id");



CREATE INDEX "idx_domain_events_pending" ON "public"."domain_events" USING "btree" ("processed_at") WHERE ("processed_at" IS NULL);



CREATE INDEX "idx_domain_events_tenant" ON "public"."domain_events" USING "btree" ("tenant_id", "created_at" DESC);



CREATE INDEX "idx_domain_events_tenant_id" ON "public"."domain_events" USING "btree" ("tenant_id");



CREATE INDEX "idx_domain_events_user_id" ON "public"."domain_events" USING "btree" ("user_id");



CREATE INDEX "idx_dr_cicero_knowledge_tenant_id" ON "public"."dr_cicero_knowledge" USING "btree" ("tenant_id");



CREATE INDEX "idx_dr_cicero_knowledge_topic" ON "public"."dr_cicero_knowledge" USING "btree" ("topic");



CREATE INDEX "idx_economic_group_members_client_id" ON "public"."economic_group_members" USING "btree" ("client_id");



CREATE INDEX "idx_economic_group_members_group_id" ON "public"."economic_group_members" USING "btree" ("economic_group_id");



CREATE INDEX "idx_economic_group_members_tenant_id" ON "public"."economic_group_members" USING "btree" ("tenant_id");



CREATE INDEX "idx_economic_groups_main_payer" ON "public"."economic_groups" USING "btree" ("main_payer_client_id");



CREATE INDEX "idx_economic_groups_tenant_id" ON "public"."economic_groups" USING "btree" ("tenant_id");



CREATE INDEX "idx_employee_incentive_policies_tenant_id" ON "public"."employee_incentive_policies" USING "btree" ("tenant_id");



CREATE INDEX "idx_employee_sales_tenant_id" ON "public"."employee_sales" USING "btree" ("tenant_id");



CREATE INDEX "idx_employee_terminations_tenant_id" ON "public"."employee_terminations" USING "btree" ("tenant_id");



CREATE INDEX "idx_employees_tenant_id" ON "public"."employees" USING "btree" ("tenant_id");



CREATE INDEX "idx_empresas_tenant_id" ON "public"."empresas" USING "btree" ("tenant_id");



CREATE INDEX "idx_enrichment_logs_tenant_id" ON "public"."enrichment_logs" USING "btree" ("tenant_id");



CREATE INDEX "idx_entry_items_account" ON "public"."accounting_entry_items" USING "btree" ("account_id");



CREATE INDEX "idx_entry_items_client" ON "public"."accounting_entry_items" USING "btree" ("client_id");



CREATE INDEX "idx_entry_items_entry" ON "public"."accounting_entry_items" USING "btree" ("entry_id");



CREATE INDEX "idx_esocial_rubricas_tenant_id" ON "public"."esocial_rubricas" USING "btree" ("tenant_id");



CREATE INDEX "idx_expense_cat_chart_account" ON "public"."expense_categories" USING "btree" ("chart_account_id");



CREATE INDEX "idx_expense_cat_cost_center" ON "public"."expense_categories" USING "btree" ("cost_center_id");



CREATE INDEX "idx_expense_categories_display_order" ON "public"."expense_categories" USING "btree" ("display_order");



CREATE INDEX "idx_expense_categories_tenant_id" ON "public"."expense_categories" USING "btree" ("tenant_id");



CREATE INDEX "idx_expenses_account_id" ON "public"."expenses" USING "btree" ("account_id");



CREATE INDEX "idx_expenses_category_id" ON "public"."expenses" USING "btree" ("category_id");



CREATE INDEX "idx_expenses_chart_account" ON "public"."expenses" USING "btree" ("chart_account_id");



CREATE INDEX "idx_expenses_client_status" ON "public"."expenses" USING "btree" ("client_id", "status");



CREATE INDEX "idx_expenses_competence" ON "public"."expenses" USING "btree" ("competence");



CREATE INDEX "idx_expenses_cost_center" ON "public"."expenses" USING "btree" ("cost_center");



CREATE INDEX "idx_expenses_cost_center_account" ON "public"."expenses" USING "btree" ("cost_center_id", "account_id");



CREATE INDEX "idx_expenses_cost_center_id" ON "public"."expenses" USING "btree" ("cost_center_id");



CREATE INDEX "idx_expenses_created_by" ON "public"."expenses" USING "btree" ("created_by");



CREATE INDEX "idx_expenses_is_paused" ON "public"."expenses" USING "btree" ("is_paused") WHERE (("is_recurring" = true) AND ("is_paused" = true));



CREATE INDEX "idx_expenses_is_recurring" ON "public"."expenses" USING "btree" ("is_recurring") WHERE ("is_recurring" = true);



CREATE INDEX "idx_expenses_journal" ON "public"."expenses" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_expenses_parent_id" ON "public"."expenses" USING "btree" ("parent_expense_id") WHERE ("parent_expense_id" IS NOT NULL);



CREATE INDEX "idx_expenses_recurrence_start_date" ON "public"."expenses" USING "btree" ("recurrence_start_date");



CREATE INDEX "idx_expenses_recurring_frequency" ON "public"."expenses" USING "btree" ("recurrence_frequency");



CREATE INDEX "idx_expenses_status" ON "public"."expenses" USING "btree" ("status");



CREATE INDEX "idx_expenses_status_due" ON "public"."expenses" USING "btree" ("status", "due_date") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_expenses_supplier" ON "public"."expenses" USING "btree" ("supplier_id");



CREATE INDEX "idx_expenses_tenant_id" ON "public"."expenses" USING "btree" ("tenant_id");



CREATE UNIQUE INDEX "idx_expenses_unique" ON "public"."expenses" USING "btree" ("description", "amount", "due_date", "client_id") WHERE ("status" <> 'cancelled'::"text");



CREATE INDEX "idx_feature_analysis_history_tenant_id" ON "public"."feature_analysis_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_feature_requests_tenant_id" ON "public"."feature_requests" USING "btree" ("tenant_id");



CREATE INDEX "idx_feature_templates_tenant_id" ON "public"."feature_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_fee_adjustment_client" ON "public"."fee_adjustment_history" USING "btree" ("client_id", "adjustment_date" DESC);



CREATE INDEX "idx_fee_adjustment_history_tenant_id" ON "public"."fee_adjustment_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_file_processing_queue_status" ON "public"."file_processing_queue" USING "btree" ("status");



CREATE INDEX "idx_file_processing_queue_tenant_id" ON "public"."file_processing_queue" USING "btree" ("tenant_id");



CREATE INDEX "idx_file_processing_queue_uploaded_at" ON "public"."file_processing_queue" USING "btree" ("uploaded_at");



CREATE INDEX "idx_financial_analysis_tenant_id" ON "public"."financial_analysis" USING "btree" ("tenant_id");



CREATE INDEX "idx_financial_gap_solutions_tenant_id" ON "public"."financial_gap_solutions" USING "btree" ("tenant_id");



CREATE INDEX "idx_fiscal_closings_created_by" ON "public"."fiscal_year_closings" USING "btree" ("created_by");



CREATE INDEX "idx_fiscal_closings_journal" ON "public"."fiscal_year_closings" USING "btree" ("closing_journal_entry_id");



CREATE INDEX "idx_fiscal_closings_res_acc" ON "public"."fiscal_year_closings" USING "btree" ("result_account_id");



CREATE INDEX "idx_fiscal_closings_res_tx" ON "public"."fiscal_year_closings" USING "btree" ("result_transfer_entry_id");



CREATE INDEX "idx_fiscal_year_closings_tenant_id" ON "public"."fiscal_year_closings" USING "btree" ("tenant_id");



CREATE INDEX "idx_generated_content_tenant_id" ON "public"."generated_content" USING "btree" ("tenant_id");



CREATE INDEX "idx_grupos_economicos_tenant_id" ON "public"."grupos_economicos" USING "btree" ("tenant_id");



CREATE INDEX "idx_holidays_date" ON "public"."holidays" USING "btree" ("date");



CREATE INDEX "idx_holidays_recurring" ON "public"."holidays" USING "btree" ("is_recurring", "recurring_month", "recurring_day");



CREATE INDEX "idx_import_files_tenant_id" ON "public"."import_files" USING "btree" ("tenant_id");



CREATE INDEX "idx_import_files_uploaded_by" ON "public"."import_files" USING "btree" ("uploaded_by");



CREATE INDEX "idx_initial_load_control_tenant_id" ON "public"."initial_load_control" USING "btree" ("tenant_id");



CREATE INDEX "idx_initial_load_status" ON "public"."initial_load_control" USING "btree" ("status");



CREATE INDEX "idx_initial_load_year" ON "public"."initial_load_control" USING "btree" ("fiscal_year", "competence");



CREATE INDEX "idx_intelligence_rules_tenant_id" ON "public"."intelligence_rules" USING "btree" ("tenant_id");



CREATE INDEX "idx_inventory_movements_tenant_id" ON "public"."inventory_movements" USING "btree" ("tenant_id");



CREATE INDEX "idx_invoice_audit_changed_by" ON "public"."invoice_status_audit" USING "btree" ("changed_by");



CREATE INDEX "idx_invoice_audit_date" ON "public"."invoice_status_audit" USING "btree" ("changed_at" DESC);



CREATE INDEX "idx_invoice_audit_invoice" ON "public"."invoice_status_audit" USING "btree" ("invoice_id");



CREATE INDEX "idx_invoice_gen_rules_created" ON "public"."invoice_generation_rules" USING "btree" ("created_by");



CREATE INDEX "idx_invoice_generation_rules_tenant_id" ON "public"."invoice_generation_rules" USING "btree" ("tenant_id");



CREATE INDEX "idx_invoice_status_audit_tenant_id" ON "public"."invoice_status_audit" USING "btree" ("tenant_id");



CREATE INDEX "idx_invoices_client" ON "public"."invoices" USING "btree" ("client_id");



CREATE INDEX "idx_invoices_client_status" ON "public"."invoices" USING "btree" ("client_id", "status");



CREATE INDEX "idx_invoices_competence" ON "public"."invoices" USING "btree" ("competence");



CREATE INDEX "idx_invoices_created_at" ON "public"."invoices" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_invoices_created_by" ON "public"."invoices" USING "btree" ("created_by");



CREATE INDEX "idx_invoices_due_date" ON "public"."invoices" USING "btree" ("due_date");



CREATE INDEX "idx_invoices_external_charge" ON "public"."invoices" USING "btree" ("external_charge_id");



CREATE INDEX "idx_invoices_journal" ON "public"."invoices" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_invoices_revenue_type" ON "public"."invoices" USING "btree" ("revenue_type_id");



CREATE INDEX "idx_invoices_status" ON "public"."invoices" USING "btree" ("status");



CREATE INDEX "idx_invoices_status_due" ON "public"."invoices" USING "btree" ("status", "due_date") WHERE (("status")::"text" = 'pending'::"text");



CREATE INDEX "idx_invoices_tenant_id" ON "public"."invoices" USING "btree" ("tenant_id");



CREATE INDEX "idx_invoices_updated_at" ON "public"."invoices" USING "btree" ("updated_at" DESC);



CREATE INDEX "idx_irpf_cpf" ON "public"."irpf_declarations" USING "btree" ("taxpayer_cpf");



CREATE INDEX "idx_irpf_decl_client_id" ON "public"."irpf_declarations" USING "btree" ("client_id");



CREATE INDEX "idx_irpf_decl_created_by" ON "public"."irpf_declarations" USING "btree" ("created_by");



CREATE INDEX "idx_irpf_decl_invoice_id" ON "public"."irpf_declarations" USING "btree" ("invoice_id");



CREATE INDEX "idx_irpf_declarations_tenant_id" ON "public"."irpf_declarations" USING "btree" ("tenant_id");



CREATE INDEX "idx_irpf_year" ON "public"."irpf_declarations" USING "btree" ("calendar_year");



CREATE INDEX "idx_journal_entries_competence" ON "public"."journal_entries" USING "btree" ("competence");



CREATE INDEX "idx_journal_entries_date" ON "public"."journal_entries" USING "btree" ("entry_date");



CREATE INDEX "idx_journal_entries_fiscal_year" ON "public"."journal_entries" USING "btree" ("fiscal_year");



CREATE INDEX "idx_journal_entries_tenant_id" ON "public"."journal_entries" USING "btree" ("tenant_id");



CREATE INDEX "idx_journal_entry_lines_account" ON "public"."journal_entry_lines" USING "btree" ("account_id");



CREATE INDEX "idx_journal_entry_lines_entry" ON "public"."journal_entry_lines" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_journal_entry_lines_tenant_id" ON "public"."journal_entry_lines" USING "btree" ("tenant_id");



CREATE INDEX "idx_labor_alerts_tenant_id" ON "public"."labor_alerts" USING "btree" ("tenant_id");



CREATE INDEX "idx_labor_jurisprudence_tenant_id" ON "public"."labor_jurisprudence" USING "btree" ("tenant_id");



CREATE INDEX "idx_labor_legislation_tenant_id" ON "public"."labor_legislation" USING "btree" ("tenant_id");



CREATE INDEX "idx_labor_solution_strategies_tenant_id" ON "public"."labor_solution_strategies" USING "btree" ("tenant_id");



CREATE INDEX "idx_logs_erros_tenant_id" ON "public"."logs_erros" USING "btree" ("tenant_id");



CREATE INDEX "idx_logs_sincronizacao_tenant_id" ON "public"."logs_sincronizacao" USING "btree" ("tenant_id");



CREATE INDEX "idx_marketing_videos_tenant_id" ON "public"."marketing_videos" USING "btree" ("tenant_id");



CREATE INDEX "idx_materialized_view_refresh_log_tenant_id" ON "public"."materialized_view_refresh_log" USING "btree" ("tenant_id");



CREATE INDEX "idx_meeting_default_participants_tenant_id" ON "public"."meeting_default_participants" USING "btree" ("tenant_id");



CREATE INDEX "idx_message_templates_channel" ON "public"."message_templates" USING "btree" ("channel");



CREATE INDEX "idx_message_templates_tenant_id" ON "public"."message_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_message_templates_type" ON "public"."message_templates" USING "btree" ("type");



CREATE INDEX "idx_metrics_date" ON "public"."metrics_snapshots" USING "btree" ("snapshot_date" DESC);



CREATE INDEX "idx_metrics_snapshots_tenant_id" ON "public"."metrics_snapshots" USING "btree" ("tenant_id");



CREATE INDEX "idx_metrics_type" ON "public"."metrics_snapshots" USING "btree" ("metric_type");



CREATE INDEX "idx_minimum_wage_date" ON "public"."minimum_wage_history" USING "btree" ("effective_date" DESC);



CREATE INDEX "idx_minimum_wage_history_tenant_id" ON "public"."minimum_wage_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_monthly_closings_period" ON "public"."monthly_closings" USING "btree" ("year", "month");



CREATE INDEX "idx_monthly_closings_status" ON "public"."monthly_closings" USING "btree" ("status");



CREATE INDEX "idx_monthly_closings_tenant_id" ON "public"."monthly_closings" USING "btree" ("tenant_id");



CREATE INDEX "idx_monthly_revenue_client_period" ON "public"."client_monthly_revenue" USING "btree" ("client_id", "reference_year", "reference_month");



CREATE INDEX "idx_mv_cash_flow_date" ON "public"."mv_cash_flow" USING "btree" ("date");



CREATE INDEX "idx_mv_coa_balances_code" ON "public"."mv_coa_balances" USING "btree" ("code");



CREATE UNIQUE INDEX "idx_mv_coa_balances_id" ON "public"."mv_coa_balances" USING "btree" ("id");



CREATE UNIQUE INDEX "idx_mv_dashboard_kpis_refresh" ON "public"."mv_dashboard_kpis" USING "btree" ("last_updated");



CREATE INDEX "idx_mv_dre_monthly_month" ON "public"."mv_dre_monthly" USING "btree" ("month");



CREATE UNIQUE INDEX "idx_mv_trial_balance_id" ON "public"."mv_trial_balance" USING "btree" ("account_id");



CREATE INDEX "idx_negotiation_contact_history_tenant_id" ON "public"."negotiation_contact_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_negotiation_installments_due_date" ON "public"."negotiation_installments" USING "btree" ("due_date");



CREATE INDEX "idx_negotiation_installments_negotiation" ON "public"."negotiation_installments" USING "btree" ("negotiation_id");



CREATE INDEX "idx_negotiation_installments_status" ON "public"."negotiation_installments" USING "btree" ("status");



CREATE INDEX "idx_negotiation_installments_tenant_id" ON "public"."negotiation_installments" USING "btree" ("tenant_id");



CREATE INDEX "idx_nfse_cancelled_by" ON "public"."nfse" USING "btree" ("cancelled_by");



CREATE INDEX "idx_nfse_client" ON "public"."nfse" USING "btree" ("client_id");



CREATE INDEX "idx_nfse_competencia" ON "public"."nfse" USING "btree" ("competencia");



CREATE INDEX "idx_nfse_config_tenant_id" ON "public"."nfse_config" USING "btree" ("tenant_id");



CREATE INDEX "idx_nfse_created_by" ON "public"."nfse" USING "btree" ("created_by");



CREATE INDEX "idx_nfse_invoice" ON "public"."nfse" USING "btree" ("invoice_id");



CREATE INDEX "idx_nfse_log_nfse" ON "public"."nfse_log" USING "btree" ("nfse_id");



CREATE INDEX "idx_nfse_log_operacao" ON "public"."nfse_log" USING "btree" ("operacao");



CREATE INDEX "idx_nfse_log_tenant_id" ON "public"."nfse_log" USING "btree" ("tenant_id");



CREATE INDEX "idx_nfse_numero" ON "public"."nfse" USING "btree" ("numero_nfse");



CREATE INDEX "idx_nfse_prestador" ON "public"."nfse" USING "btree" ("prestador_cnpj");



CREATE INDEX "idx_nfse_protocolo" ON "public"."nfse" USING "btree" ("protocolo");



CREATE INDEX "idx_nfse_status" ON "public"."nfse" USING "btree" ("status");



CREATE INDEX "idx_nfse_tenant_id" ON "public"."nfse" USING "btree" ("tenant_id");



CREATE INDEX "idx_nfse_tomadas_conta_pagar" ON "public"."nfse_tomadas" USING "btree" ("conta_pagar_id");



CREATE INDEX "idx_nfse_tomadas_created_by" ON "public"."nfse_tomadas" USING "btree" ("created_by");



CREATE INDEX "idx_nfse_tomadas_data" ON "public"."nfse_tomadas" USING "btree" ("data_emissao");



CREATE INDEX "idx_nfse_tomadas_prestador" ON "public"."nfse_tomadas" USING "btree" ("prestador_cnpj");



CREATE INDEX "idx_nfse_tomadas_status" ON "public"."nfse_tomadas" USING "btree" ("status");



CREATE INDEX "idx_nfse_tomadas_supplier" ON "public"."nfse_tomadas" USING "btree" ("supplier_id");



CREATE INDEX "idx_nfse_tomadas_tenant_id" ON "public"."nfse_tomadas" USING "btree" ("tenant_id");



CREATE INDEX "idx_nfse_tomadas_tomador" ON "public"."nfse_tomadas" USING "btree" ("tomador_cnpj");



CREATE INDEX "idx_nfse_tomador" ON "public"."nfse" USING "btree" ("tomador_cnpj");



CREATE INDEX "idx_notifications_client" ON "public"."notifications_log" USING "btree" ("client_id");



CREATE INDEX "idx_notifications_created" ON "public"."notifications_log" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_notifications_invoice" ON "public"."notifications_log" USING "btree" ("invoice_id");



CREATE INDEX "idx_notifications_log_tenant_id" ON "public"."notifications_log" USING "btree" ("tenant_id");



CREATE INDEX "idx_notifications_status" ON "public"."notifications_log" USING "btree" ("status");



CREATE INDEX "idx_office_products_tenant_id" ON "public"."office_products" USING "btree" ("tenant_id");



CREATE INDEX "idx_office_recurring_expenses_tenant_id" ON "public"."office_recurring_expenses" USING "btree" ("tenant_id");



CREATE INDEX "idx_office_settings_tenant_id" ON "public"."office_settings" USING "btree" ("tenant_id");



CREATE INDEX "idx_opening_balance_client" ON "public"."client_opening_balance" USING "btree" ("client_id");



CREATE INDEX "idx_opening_balance_client_year_type" ON "public"."client_opening_balance" USING "btree" ("client_id", "fee_type", SUBSTRING("competence" FROM 4 FOR 4));



CREATE INDEX "idx_opening_balance_competence" ON "public"."client_opening_balance" USING "btree" ("competence");



CREATE INDEX "idx_opening_balance_created_at" ON "public"."client_opening_balance" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_opening_balance_due_date" ON "public"."client_opening_balance" USING "btree" ("due_date");



CREATE INDEX "idx_opening_balance_fee_type" ON "public"."client_opening_balance" USING "btree" ("fee_type");



CREATE INDEX "idx_opening_balance_journal" ON "public"."client_opening_balance" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_opening_balance_status" ON "public"."client_opening_balance" USING "btree" ("status");



CREATE INDEX "idx_org_users_org" ON "public"."organization_users" USING "btree" ("organization_id");



CREATE INDEX "idx_org_users_user" ON "public"."organization_users" USING "btree" ("user_id");



CREATE INDEX "idx_organization_users_tenant_id" ON "public"."organization_users" USING "btree" ("tenant_id");



CREATE INDEX "idx_organizations_active" ON "public"."organizations" USING "btree" ("is_active");



CREATE INDEX "idx_organizations_tenant_id" ON "public"."organizations" USING "btree" ("tenant_id");



CREATE INDEX "idx_parametros_folha_tenant_id" ON "public"."parametros_folha" USING "btree" ("tenant_id");



CREATE INDEX "idx_partner_family_tenant_id" ON "public"."partner_family" USING "btree" ("tenant_id");



CREATE INDEX "idx_partner_properties_tenant_id" ON "public"."partner_properties" USING "btree" ("tenant_id");



CREATE INDEX "idx_partner_vehicles_tenant_id" ON "public"."partner_vehicles" USING "btree" ("tenant_id");



CREATE INDEX "idx_partners_client_id" ON "public"."partners" USING "btree" ("client_id");



CREATE INDEX "idx_partners_cpf" ON "public"."partners" USING "btree" ("cpf");



CREATE INDEX "idx_partners_tenant_id" ON "public"."partners" USING "btree" ("tenant_id");



CREATE INDEX "idx_payroll_details_employee" ON "public"."payroll_details" USING "btree" ("employee_id");



CREATE INDEX "idx_payroll_details_employee_cpf" ON "public"."payroll_details" USING "btree" ("employee_cpf");



CREATE INDEX "idx_payroll_details_payroll" ON "public"."payroll_details" USING "btree" ("payroll_id");



CREATE INDEX "idx_payroll_details_tenant_id" ON "public"."payroll_details" USING "btree" ("tenant_id");



CREATE INDEX "idx_payroll_events_tenant_id" ON "public"."payroll_events" USING "btree" ("tenant_id");



CREATE INDEX "idx_payroll_journal_entries_tenant_id" ON "public"."payroll_journal_entries" USING "btree" ("tenant_id");



CREATE INDEX "idx_payroll_payments_payroll" ON "public"."payroll_payments" USING "btree" ("payroll_id");



CREATE INDEX "idx_payroll_payments_status" ON "public"."payroll_payments" USING "btree" ("status");



CREATE INDEX "idx_payroll_payments_tenant_id" ON "public"."payroll_payments" USING "btree" ("tenant_id");



CREATE INDEX "idx_payroll_payments_tracking" ON "public"."payroll_payments" USING "btree" ("tracking_codigo");



CREATE INDEX "idx_payroll_payments_type" ON "public"."payroll_payments" USING "btree" ("payment_type");



CREATE INDEX "idx_payroll_tenant_id" ON "public"."payroll" USING "btree" ("tenant_id");



CREATE INDEX "idx_payrolls_company" ON "public"."payrolls" USING "btree" ("company_id");



CREATE INDEX "idx_payrolls_reference" ON "public"."payrolls" USING "btree" ("reference_code");



CREATE INDEX "idx_payrolls_status" ON "public"."payrolls" USING "btree" ("status");



CREATE INDEX "idx_payrolls_tenant_id" ON "public"."payrolls" USING "btree" ("tenant_id");



CREATE INDEX "idx_payrolls_year_month" ON "public"."payrolls" USING "btree" ("year", "month");



CREATE INDEX "idx_pending_reconciliations_bank_account" ON "public"."pending_reconciliations" USING "btree" ("bank_account_id");



CREATE INDEX "idx_pending_reconciliations_invoice" ON "public"."pending_reconciliations" USING "btree" ("invoice_id");



CREATE INDEX "idx_pending_reconciliations_status" ON "public"."pending_reconciliations" USING "btree" ("status");



CREATE INDEX "idx_pending_reconciliations_tenant_id" ON "public"."pending_reconciliations" USING "btree" ("tenant_id");



CREATE INDEX "idx_perdcomp_empresa" ON "public"."perdcomp_pedidos" USING "btree" ("empresa_id");



CREATE INDEX "idx_perdcomp_pedidos_tenant_id" ON "public"."perdcomp_pedidos" USING "btree" ("tenant_id");



CREATE INDEX "idx_perdcomp_status" ON "public"."perdcomp_pedidos" USING "btree" ("status");



CREATE INDEX "idx_perdcomp_tipo" ON "public"."perdcomp_pedidos" USING "btree" ("tipo");



CREATE INDEX "idx_period_close_history_tenant_id" ON "public"."period_close_history" USING "btree" ("tenant_id");



CREATE INDEX "idx_period_reopen_requests_status" ON "public"."period_reopen_requests" USING "btree" ("status");



CREATE INDEX "idx_period_reopen_requests_tenant_id" ON "public"."period_reopen_requests" USING "btree" ("tenant_id");



CREATE INDEX "idx_plr_criteria_tenant_id" ON "public"."plr_criteria" USING "btree" ("tenant_id");



CREATE INDEX "idx_plr_employee_share_tenant_id" ON "public"."plr_employee_share" USING "btree" ("tenant_id");



CREATE INDEX "idx_plr_programs_tenant_id" ON "public"."plr_programs" USING "btree" ("tenant_id");



CREATE INDEX "idx_product_consumption_tenant_id" ON "public"."product_consumption" USING "btree" ("tenant_id");



CREATE INDEX "idx_product_purchases_tenant_id" ON "public"."product_purchases" USING "btree" ("tenant_id");



CREATE INDEX "idx_profiles_tenant_id" ON "public"."profiles" USING "btree" ("tenant_id");



CREATE INDEX "idx_program_prerequisites_tenant_id" ON "public"."program_prerequisites" USING "btree" ("tenant_id");



CREATE INDEX "idx_proposals_client" ON "public"."proposals" USING "btree" ("client_id");



CREATE INDEX "idx_proposals_status" ON "public"."proposals" USING "btree" ("status");



CREATE INDEX "idx_proposals_tenant_id" ON "public"."proposals" USING "btree" ("tenant_id");



CREATE INDEX "idx_provider_invoices_provider" ON "public"."provider_invoices" USING "btree" ("provider_id");



CREATE INDEX "idx_provider_invoices_tenant_id" ON "public"."provider_invoices" USING "btree" ("tenant_id");



CREATE INDEX "idx_provisions_client" ON "public"."accounting_provisions" USING "btree" ("client_id");



CREATE INDEX "idx_provisions_competence" ON "public"."accounting_provisions" USING "btree" ("competence");



CREATE INDEX "idx_purchase_list_items_list" ON "public"."purchase_list_items" USING "btree" ("list_id");



CREATE INDEX "idx_purchase_list_items_prod" ON "public"."purchase_list_items" USING "btree" ("product_id");



CREATE INDEX "idx_purchase_list_items_tenant_id" ON "public"."purchase_list_items" USING "btree" ("tenant_id");



CREATE INDEX "idx_purchase_lists_tenant_id" ON "public"."purchase_lists" USING "btree" ("tenant_id");



CREATE INDEX "idx_reconciliation_entry" ON "public"."bank_reconciliation" USING "btree" ("accounting_entry_id");



CREATE INDEX "idx_reconciliation_invoice" ON "public"."bank_reconciliation" USING "btree" ("invoice_id");



CREATE INDEX "idx_reconciliation_rules_tenant_id" ON "public"."reconciliation_rules" USING "btree" ("tenant_id");



CREATE INDEX "idx_reconciliation_transaction" ON "public"."bank_reconciliation" USING "btree" ("transaction_id");



CREATE INDEX "idx_recurring_expense_templates_tenant_id" ON "public"."recurring_expense_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_recurring_expenses_tenant_id" ON "public"."recurring_expenses" USING "btree" ("tenant_id");



CREATE INDEX "idx_recurring_payments_active" ON "public"."recurring_payments" USING "btree" ("is_active");



CREATE INDEX "idx_recurring_payments_due_day" ON "public"."recurring_payments" USING "btree" ("due_day");



CREATE INDEX "idx_recurring_payments_personal" ON "public"."recurring_payments" USING "btree" ("is_personal");



CREATE INDEX "idx_recurring_payments_tenant_id" ON "public"."recurring_payments" USING "btree" ("tenant_id");



CREATE INDEX "idx_referral_commission_payments_tenant_id" ON "public"."referral_commission_payments" USING "btree" ("tenant_id");



CREATE INDEX "idx_referral_partners_tenant_id" ON "public"."referral_partners" USING "btree" ("tenant_id");



CREATE INDEX "idx_referral_policy_tenant_id" ON "public"."referral_policy" USING "btree" ("tenant_id");



CREATE INDEX "idx_referral_program_tenant_id" ON "public"."referral_program" USING "btree" ("tenant_id");



CREATE INDEX "idx_referrals_client" ON "public"."client_referrals" USING "btree" ("client_id");



CREATE INDEX "idx_referrals_partner" ON "public"."client_referrals" USING "btree" ("referral_partner_id");



CREATE INDEX "idx_responsibility_letters_client" ON "public"."responsibility_letters" USING "btree" ("client_id");



CREATE INDEX "idx_responsibility_letters_contract" ON "public"."responsibility_letters" USING "btree" ("contract_id");



CREATE INDEX "idx_responsibility_letters_status" ON "public"."responsibility_letters" USING "btree" ("status");



CREATE INDEX "idx_responsibility_letters_tenant_id" ON "public"."responsibility_letters" USING "btree" ("tenant_id");



CREATE INDEX "idx_responsibility_letters_year" ON "public"."responsibility_letters" USING "btree" ("reference_year");



CREATE INDEX "idx_retencoes_tributarias_tenant_id" ON "public"."retencoes_tributarias" USING "btree" ("tenant_id");



CREATE INDEX "idx_revenue_categories_display_order" ON "public"."revenue_categories" USING "btree" ("display_order");



CREATE INDEX "idx_revenue_categories_tenant_id" ON "public"."revenue_categories" USING "btree" ("tenant_id");



CREATE INDEX "idx_risk_solution_mapping_tenant_id" ON "public"."risk_solution_mapping" USING "btree" ("tenant_id");



CREATE INDEX "idx_sales_training_modules_tenant_id" ON "public"."sales_training_modules" USING "btree" ("tenant_id");



CREATE INDEX "idx_sales_training_records_tenant_id" ON "public"."sales_training_records" USING "btree" ("tenant_id");



CREATE INDEX "idx_serpro_caixa_postal_tenant_id" ON "public"."serpro_caixa_postal" USING "btree" ("tenant_id");



CREATE INDEX "idx_service_proposals_client" ON "public"."service_proposals" USING "btree" ("client_id");



CREATE INDEX "idx_service_proposals_created" ON "public"."service_proposals" USING "btree" ("created_by");



CREATE INDEX "idx_service_proposals_number" ON "public"."service_proposals" USING "btree" ("proposal_number");



CREATE INDEX "idx_service_proposals_status" ON "public"."service_proposals" USING "btree" ("status");



CREATE INDEX "idx_service_proposals_tenant_id" ON "public"."service_proposals" USING "btree" ("tenant_id");



CREATE INDEX "idx_service_providers_company" ON "public"."service_providers" USING "btree" ("company_id");



CREATE INDEX "idx_service_providers_tenant_id" ON "public"."service_providers" USING "btree" ("tenant_id");



CREATE INDEX "idx_solution_templates_tenant_id" ON "public"."solution_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_sora_gen_queue_project" ON "public"."sora_generation_queue" USING "btree" ("project_id");



CREATE INDEX "idx_sora_generation_queue_tenant_id" ON "public"."sora_generation_queue" USING "btree" ("tenant_id");



CREATE INDEX "idx_sora_video_projects_tenant_id" ON "public"."sora_video_projects" USING "btree" ("tenant_id");



CREATE INDEX "idx_sora_video_templates_tenant_id" ON "public"."sora_video_templates" USING "btree" ("tenant_id");



CREATE INDEX "idx_stored_docs_created_by" ON "public"."stored_documents" USING "btree" ("created_by");



CREATE INDEX "idx_stored_documents_client" ON "public"."stored_documents" USING "btree" ("client_id");



CREATE INDEX "idx_stored_documents_entity" ON "public"."stored_documents" USING "btree" ("entity_type", "entity_id");



CREATE INDEX "idx_stored_documents_tenant_id" ON "public"."stored_documents" USING "btree" ("tenant_id");



CREATE INDEX "idx_suppliers_account_id" ON "public"."suppliers" USING "btree" ("account_id");



CREATE INDEX "idx_suppliers_tenant_id" ON "public"."suppliers" USING "btree" ("tenant_id");



CREATE INDEX "idx_system_users_email" ON "public"."system_users" USING "btree" ("email");



CREATE INDEX "idx_system_users_employee" ON "public"."system_users" USING "btree" ("employee_id");



CREATE INDEX "idx_system_users_role" ON "public"."system_users" USING "btree" ("role");



CREATE INDEX "idx_system_users_tenant_id" ON "public"."system_users" USING "btree" ("tenant_id");



CREATE INDEX "idx_tax_configurations_tenant_id" ON "public"."tax_configurations" USING "btree" ("tenant_id");



CREATE INDEX "idx_tax_installments_tenant_id" ON "public"."tax_installments" USING "btree" ("tenant_id");



CREATE INDEX "idx_tax_oblig_responsible" ON "public"."tax_obligations" USING "btree" ("responsible_user_id");



CREATE INDEX "idx_tax_obligations_client" ON "public"."tax_obligations" USING "btree" ("client_id");



CREATE INDEX "idx_tax_obligations_due" ON "public"."tax_obligations" USING "btree" ("due_date");



CREATE INDEX "idx_tax_obligations_status" ON "public"."tax_obligations" USING "btree" ("status");



CREATE INDEX "idx_tax_obligations_tenant_id" ON "public"."tax_obligations" USING "btree" ("tenant_id");



CREATE INDEX "idx_tenant_features_tenant_id" ON "public"."tenant_features" USING "btree" ("tenant_id");



CREATE INDEX "idx_tenant_users_user_id" ON "public"."tenant_users" USING "btree" ("user_id");



CREATE INDEX "idx_terminations_date" ON "public"."employee_terminations" USING "btree" ("termination_date");



CREATE INDEX "idx_terminations_employee" ON "public"."employee_terminations" USING "btree" ("employee_id");



CREATE INDEX "idx_terminations_status" ON "public"."employee_terminations" USING "btree" ("status");



CREATE INDEX "idx_terminations_type" ON "public"."employee_terminations" USING "btree" ("termination_type");



CREATE INDEX "idx_tracking_codigo" ON "public"."accounting_entry_tracking" USING "btree" ("codigo_rastreamento");



CREATE INDEX "idx_tracking_competencia" ON "public"."accounting_entry_tracking" USING "btree" ("competencia_ano", "competencia_mes");



CREATE INDEX "idx_tracking_duplicado" ON "public"."accounting_entry_tracking" USING "btree" ("foi_duplicado");



CREATE INDEX "idx_tracking_entry_id" ON "public"."accounting_entry_tracking" USING "btree" ("entry_id");



CREATE INDEX "idx_tracking_payroll_id" ON "public"."accounting_entry_tracking" USING "btree" ("payroll_id");



CREATE INDEX "idx_tracking_tipo" ON "public"."accounting_entry_tracking" USING "btree" ("tipo");



CREATE INDEX "idx_trial_balance_lines_balance" ON "public"."trial_balance_lines" USING "btree" ("trial_balance_id");



CREATE INDEX "idx_trial_balance_lines_tenant_id" ON "public"."trial_balance_lines" USING "btree" ("tenant_id");



CREATE INDEX "idx_trial_balances_period" ON "public"."trial_balances" USING "btree" ("period_type", "competence");



CREATE INDEX "idx_trial_balances_tenant_id" ON "public"."trial_balances" USING "btree" ("tenant_id");



CREATE INDEX "idx_tv_playlist_tenant_id" ON "public"."tv_playlist" USING "btree" ("tenant_id");



CREATE INDEX "idx_tv_video_playlist_tenant_id" ON "public"."tv_video_playlist" USING "btree" ("tenant_id");



CREATE INDEX "idx_user_office_access_office" ON "public"."user_office_access" USING "btree" ("office_id");



CREATE INDEX "idx_user_office_access_tenant_id" ON "public"."user_office_access" USING "btree" ("tenant_id");



CREATE INDEX "idx_user_office_access_user" ON "public"."user_office_access" USING "btree" ("user_id");



CREATE INDEX "idx_user_roles_tenant_id" ON "public"."user_roles" USING "btree" ("tenant_id");



CREATE INDEX "idx_variable_fee_calc_client" ON "public"."variable_fee_calculations" USING "btree" ("client_id");



CREATE INDEX "idx_variable_fee_calc_fee" ON "public"."variable_fee_calculations" USING "btree" ("variable_fee_id");



CREATE INDEX "idx_variable_fee_calc_month" ON "public"."variable_fee_calculations" USING "btree" ("reference_month");



CREATE INDEX "idx_variable_fee_calc_status" ON "public"."variable_fee_calculations" USING "btree" ("status");



CREATE INDEX "idx_variable_fee_calculations_tenant_id" ON "public"."variable_fee_calculations" USING "btree" ("tenant_id");



CREATE INDEX "idx_variable_fees_client" ON "public"."client_variable_fees" USING "btree" ("client_id");



CREATE INDEX "idx_video_branding_config_tenant_id" ON "public"."video_branding_config" USING "btree" ("tenant_id");



CREATE INDEX "idx_work_order_logs_created" ON "public"."collection_work_order_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_work_order_logs_order" ON "public"."collection_work_order_logs" USING "btree" ("work_order_id");



CREATE INDEX "idx_work_orders_assigned" ON "public"."collection_work_orders" USING "btree" ("assigned_to");



CREATE INDEX "idx_work_orders_client" ON "public"."collection_work_orders" USING "btree" ("client_id");



CREATE INDEX "idx_work_orders_created" ON "public"."collection_work_orders" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_work_orders_invoice" ON "public"."collection_work_orders" USING "btree" ("invoice_id");



CREATE INDEX "idx_work_orders_next_action" ON "public"."collection_work_orders" USING "btree" ("next_action_date");



CREATE INDEX "idx_work_orders_priority" ON "public"."collection_work_orders" USING "btree" ("priority");



CREATE INDEX "idx_work_orders_status" ON "public"."collection_work_orders" USING "btree" ("status");



CREATE INDEX "idx_workflow_executions_started" ON "public"."workflow_executions" USING "btree" ("started_at" DESC);



CREATE INDEX "idx_workflow_executions_status" ON "public"."workflow_executions" USING "btree" ("status");



CREATE INDEX "idx_workflow_executions_tenant_id" ON "public"."workflow_executions" USING "btree" ("tenant_id");



CREATE INDEX "idx_workflow_executions_workflow" ON "public"."workflow_executions" USING "btree" ("workflow_id");



CREATE INDEX "idx_workflows_active" ON "public"."workflows" USING "btree" ("is_active");



CREATE INDEX "idx_workflows_created_by" ON "public"."workflows" USING "btree" ("created_by");



CREATE INDEX "idx_workflows_tenant_id" ON "public"."workflows" USING "btree" ("tenant_id");



CREATE INDEX "idx_workflows_trigger" ON "public"."workflows" USING "btree" ("trigger_type");



CREATE UNIQUE INDEX "ux_bank_imports_account_statement" ON "public"."bank_imports" USING "btree" ("bank_account_id", "statement_key");



CREATE UNIQUE INDEX "ux_clients_cnpj_full_normalized_active" ON "public"."clients" USING "btree" ("regexp_replace"("cnpj", '[^0-9]'::"text", ''::"text", 'g'::"text")) WHERE (("cnpj" IS NOT NULL) AND ("btrim"("cnpj") <> ''::"text") AND ("status" = 'active'::"text"));



CREATE UNIQUE INDEX "ux_clients_cpf_normalized_active" ON "public"."clients" USING "btree" ("regexp_replace"(("cpf")::"text", '[^0-9]'::"text", ''::"text", 'g'::"text")) WHERE (("cpf" IS NOT NULL) AND ("btrim"(("cpf")::"text") <> ''::"text") AND ("status" = 'active'::"text"));



CREATE OR REPLACE VIEW "public"."vw_economic_groups_summary" WITH ("security_invoker"='true') AS
 SELECT "eg"."id",
    "eg"."group_name",
    "eg"."group_code",
    "eg"."main_company_name",
    "count"("egm"."id") AS "total_empresas",
    "sum"(
        CASE
            WHEN "egm"."is_active" THEN 1
            ELSE 0
        END) AS "empresas_ativas",
    "eg"."consolidate_billing",
    "eg"."shared_discount_percent",
    "eg"."account_manager",
    "eg"."is_active"
   FROM ("public"."economic_groups" "eg"
     LEFT JOIN "public"."economic_group_members" "egm" ON (("egm"."group_id" = "eg"."id")))
  GROUP BY "eg"."id";



CREATE OR REPLACE TRIGGER "audit_invoice_status" AFTER UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."audit_invoice_status_change"();



CREATE OR REPLACE TRIGGER "auto_update_work_order_status" AFTER INSERT ON "public"."collection_work_order_logs" FOR EACH ROW EXECUTE FUNCTION "public"."update_work_order_status_on_log"();



CREATE OR REPLACE TRIGGER "bank_transaction_balance_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_update_bank_balance"();



CREATE OR REPLACE TRIGGER "capture_events_accounting_entries" AFTER INSERT OR DELETE OR UPDATE ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."capture_domain_event"();



CREATE OR REPLACE TRIGGER "capture_events_bank_transactions" AFTER INSERT OR DELETE OR UPDATE ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."capture_domain_event"();



CREATE OR REPLACE TRIGGER "capture_events_clients" AFTER INSERT OR DELETE OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."capture_domain_event"();



CREATE OR REPLACE TRIGGER "capture_events_expenses" AFTER INSERT OR DELETE OR UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."capture_domain_event"();



CREATE OR REPLACE TRIGGER "capture_events_invoices" AFTER INSERT OR DELETE OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."capture_domain_event"();



CREATE OR REPLACE TRIGGER "check_period_before_entry_trigger" BEFORE INSERT OR UPDATE ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."check_period_before_entry"();



CREATE OR REPLACE TRIGGER "handle_updated_at_import_files" BEFORE UPDATE ON "public"."import_files" FOR EACH ROW EXECUTE FUNCTION "extensions"."moddatetime"('updated_at');



CREATE OR REPLACE TRIGGER "payroll_details_total_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."payroll_details" FOR EACH ROW EXECUTE FUNCTION "public"."update_payroll_totals"();



CREATE OR REPLACE TRIGGER "payroll_details_validation_trigger" BEFORE INSERT OR UPDATE ON "public"."payroll_details" FOR EACH ROW EXECUTE FUNCTION "public"."validate_payroll_details"();



CREATE OR REPLACE TRIGGER "payrolls_updated_at_trigger" BEFORE UPDATE ON "public"."payrolls" FOR EACH ROW EXECUTE FUNCTION "public"."update_payrolls_updated_at"();



CREATE OR REPLACE TRIGGER "tr_auto_consultation" AFTER INSERT ON "public"."labor_alerts" FOR EACH ROW WHEN (("new"."severity" = ANY (ARRAY['critical'::"text", 'high'::"text"]))) EXECUTE FUNCTION "public"."create_auto_consultation"();



CREATE OR REPLACE TRIGGER "tr_auto_entry_bank_transaction" AFTER INSERT ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_bank_transaction_entry"();



CREATE OR REPLACE TRIGGER "tr_auto_entry_invoice" AFTER INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_invoice_entry"();



CREATE OR REPLACE TRIGGER "tr_auto_payroll" AFTER INSERT ON "public"."employees" FOR EACH ROW EXECUTE FUNCTION "public"."auto_generate_payroll"();



CREATE OR REPLACE TRIGGER "tr_learn_classification" AFTER UPDATE OF "chart_account_id" ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."fn_learn_from_classification"();



CREATE OR REPLACE TRIGGER "tr_payroll_event_accounting" AFTER INSERT ON "public"."payroll_events" FOR EACH ROW EXECUTE FUNCTION "public"."gerar_lancamento_contabil_folha"();



CREATE OR REPLACE TRIGGER "tr_payroll_journal" AFTER UPDATE ON "public"."payroll" FOR EACH ROW EXECUTE FUNCTION "public"."tr_payroll_generate_entries"();



CREATE OR REPLACE TRIGGER "tr_predict_classification" BEFORE INSERT ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."fn_predict_classification"();



CREATE OR REPLACE TRIGGER "tr_set_bank_tx_internal_code" BEFORE INSERT ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."set_bank_tx_internal_code"();



CREATE OR REPLACE TRIGGER "tr_set_internal_code" BEFORE INSERT ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."set_internal_code"();



CREATE OR REPLACE TRIGGER "trg_ai_learned_patterns_updated" BEFORE UPDATE ON "public"."ai_learned_patterns" FOR EACH ROW EXECUTE FUNCTION "public"."update_ai_learned_patterns_updated_at"();



CREATE OR REPLACE TRIGGER "trg_auto_accounting_expense_insert" AFTER INSERT ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_accounting_expense_provision"();



CREATE OR REPLACE TRIGGER "trg_auto_accounting_invoice" AFTER INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."create_invoice_accounting_entry"();



CREATE OR REPLACE TRIGGER "trg_auto_accounting_invoice_insert" AFTER INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_accounting_invoice_provision"();



CREATE OR REPLACE TRIGGER "trg_auto_accounting_reconciliation" AFTER INSERT ON "public"."bank_reconciliation" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_accounting_reconciliation"();



CREATE OR REPLACE TRIGGER "trg_auto_classify_pro_bono" BEFORE INSERT OR UPDATE OF "monthly_fee", "is_pro_bono" ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."auto_classify_pro_bono"();



CREATE OR REPLACE TRIGGER "trg_bank_imports_continuity" BEFORE INSERT ON "public"."bank_imports" FOR EACH ROW EXECUTE FUNCTION "public"."guard_bank_imports_continuity"();



CREATE OR REPLACE TRIGGER "trg_bank_imports_immutable" BEFORE UPDATE ON "public"."bank_imports" FOR EACH ROW EXECUTE FUNCTION "public"."guard_bank_imports_immutable"();



CREATE OR REPLACE TRIGGER "trg_bank_imports_set_statement_key" BEFORE INSERT OR UPDATE ON "public"."bank_imports" FOR EACH ROW EXECUTE FUNCTION "public"."bank_imports_set_statement_key"();



CREATE OR REPLACE TRIGGER "trg_blindagem_invoices" AFTER INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_contabilizar_invoice"();



CREATE OR REPLACE TRIGGER "trg_calculate_referral_end_date" BEFORE INSERT OR UPDATE ON "public"."client_referrals" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_referral_end_date"();



CREATE OR REPLACE TRIGGER "trg_check_analytical_account" BEFORE INSERT OR UPDATE ON "public"."accounting_entry_items" FOR EACH ROW EXECUTE FUNCTION "public"."check_analytical_account_only"();



CREATE OR REPLACE TRIGGER "trg_classify_transaction_on_insert" BEFORE INSERT ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."classify_transaction_on_insert"();



CREATE OR REPLACE TRIGGER "trg_create_client_account" BEFORE INSERT ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."fn_create_client_account"();



CREATE OR REPLACE TRIGGER "trg_create_supplier_account" BEFORE INSERT ON "public"."suppliers" FOR EACH ROW EXECUTE FUNCTION "public"."fn_create_supplier_account"();



CREATE OR REPLACE TRIGGER "trg_expense_delete" BEFORE DELETE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."trg_expense_delete"();



CREATE OR REPLACE TRIGGER "trg_expense_insert" AFTER INSERT ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."trg_expense_insert"();



CREATE OR REPLACE TRIGGER "trg_expense_update" AFTER UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."trg_expense_update"();



CREATE OR REPLACE TRIGGER "trg_generate_contract_on_client" AFTER INSERT ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_generate_contract_on_client"();



CREATE OR REPLACE TRIGGER "trg_generate_distract_on_status" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_generate_distract_on_status_change"();



CREATE OR REPLACE TRIGGER "trg_generate_negotiation_number" BEFORE INSERT ON "public"."debt_negotiations" FOR EACH ROW EXECUTE FUNCTION "public"."generate_negotiation_number"();



CREATE OR REPLACE TRIGGER "trg_invoice_delete" BEFORE DELETE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."trg_invoice_delete"();



CREATE OR REPLACE TRIGGER "trg_invoice_insert" AFTER INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."trg_invoice_insert"();



CREATE OR REPLACE TRIGGER "trg_invoice_update" AFTER UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."trg_invoice_update"();



CREATE OR REPLACE TRIGGER "trg_mark_transaction_reconciled" AFTER INSERT ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."mark_transaction_reconciled_on_entry"();



CREATE OR REPLACE TRIGGER "trg_nfse_updated_at" BEFORE UPDATE ON "public"."nfse" FOR EACH ROW EXECUTE FUNCTION "public"."update_nfse_updated_at"();



CREATE OR REPLACE TRIGGER "trg_queue_ai_validation" AFTER INSERT ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_queue_new_entry_for_validation"();



CREATE OR REPLACE TRIGGER "trg_recalc_journal" AFTER INSERT OR DELETE OR UPDATE ON "public"."journal_entry_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_recalc_journal_totals"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_accounting_contracts" BEFORE INSERT ON "public"."accounting_contracts" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_accounting_entries" BEFORE INSERT ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_accounting_entry_lines" BEFORE INSERT ON "public"."accounting_entry_lines" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_client_contracts" BEFORE INSERT ON "public"."client_contracts" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_client_opening_balance" BEFORE INSERT ON "public"."client_opening_balance" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_clients" BEFORE INSERT ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_contracts" BEFORE INSERT ON "public"."client_contracts" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_invoices" BEFORE INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_set_tenant_suppliers" BEFORE INSERT ON "public"."suppliers" FOR EACH ROW EXECUTE FUNCTION "public"."fn_auto_set_tenant_id"();



CREATE OR REPLACE TRIGGER "trg_update_balances_on_entry" AFTER INSERT OR UPDATE ON "public"."accounting_entry_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_account_balances"();



CREATE OR REPLACE TRIGGER "trg_update_entity_usage" AFTER INSERT ON "public"."ai_classification_history" FOR EACH ROW EXECUTE FUNCTION "public"."update_entity_usage"();



CREATE OR REPLACE TRIGGER "trg_update_ledger" AFTER INSERT OR DELETE OR UPDATE ON "public"."journal_entry_lines" FOR EACH STATEMENT EXECUTE FUNCTION "public"."trigger_update_ledger_after_journal"();



CREATE OR REPLACE TRIGGER "trg_update_pattern_usage" AFTER INSERT ON "public"."ai_classification_history" FOR EACH ROW EXECUTE FUNCTION "public"."update_pattern_usage"();



CREATE OR REPLACE TRIGGER "trg_update_service_costs" AFTER INSERT OR DELETE OR UPDATE ON "public"."company_service_costs" FOR EACH ROW EXECUTE FUNCTION "public"."update_service_total_costs"();



CREATE OR REPLACE TRIGGER "trg_update_stock_after_consumption" AFTER INSERT ON "public"."product_consumption" FOR EACH ROW EXECUTE FUNCTION "public"."update_stock_after_consumption"();



CREATE OR REPLACE TRIGGER "trg_update_stock_after_purchase" AFTER INSERT ON "public"."product_purchases" FOR EACH ROW EXECUTE FUNCTION "public"."update_stock_after_purchase"();



CREATE OR REPLACE TRIGGER "trg_validar_honorarios" BEFORE INSERT OR UPDATE ON "public"."client_opening_balance" FOR EACH ROW EXECUTE FUNCTION "public"."fn_validar_honorarios_mensais"();



CREATE OR REPLACE TRIGGER "trigger_auto_reconcile_expense" AFTER UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."auto_reconcile_expense_payment"();



CREATE OR REPLACE TRIGGER "trigger_auto_reconcile_invoice" AFTER UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."auto_reconcile_invoice_payment"();



CREATE OR REPLACE TRIGGER "trigger_auto_reconcile_transaction" BEFORE INSERT ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."auto_reconcile_new_transaction"();



CREATE OR REPLACE TRIGGER "trigger_check_hire_date_payroll" BEFORE INSERT OR UPDATE ON "public"."payroll" FOR EACH ROW EXECUTE FUNCTION "public"."check_employee_hire_date_for_payroll"();



CREATE OR REPLACE TRIGGER "trigger_create_confession_installments" AFTER INSERT OR UPDATE ON "public"."debt_confessions" FOR EACH ROW EXECUTE FUNCTION "public"."create_confession_installments"();



CREATE OR REPLACE TRIGGER "trigger_nfse_tomadas_updated_at" BEFORE UPDATE ON "public"."nfse_tomadas" FOR EACH ROW EXECUTE FUNCTION "public"."update_nfse_tomadas_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_opening_balance_timestamp" BEFORE UPDATE ON "public"."client_opening_balance" FOR EACH ROW EXECUTE FUNCTION "public"."update_opening_balance_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_protect_accounting_entry_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."accounting_entries" FOR EACH ROW EXECUTE FUNCTION "public"."protect_accounting_entry_in_closed_period"();



CREATE OR REPLACE TRIGGER "trigger_protect_accounting_entry_line_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."accounting_entry_lines" FOR EACH ROW EXECUTE FUNCTION "public"."protect_accounting_entry_line_in_closed_period"();



CREATE OR REPLACE TRIGGER "trigger_protect_bank_transaction_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."bank_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."protect_bank_transaction_in_closed_period"();



CREATE OR REPLACE TRIGGER "trigger_protect_expense_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."protect_expense_in_closed_period"();



CREATE OR REPLACE TRIGGER "trigger_protect_invoice_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."protect_invoice_in_closed_period"();



CREATE OR REPLACE TRIGGER "trigger_set_addendum_number" BEFORE INSERT ON "public"."contract_addendums" FOR EACH ROW EXECUTE FUNCTION "public"."set_addendum_number"();



CREATE OR REPLACE TRIGGER "trigger_set_cash_flow_projection_tenant_id" BEFORE INSERT ON "public"."cash_flow_projections" FOR EACH ROW EXECUTE FUNCTION "public"."set_cash_flow_projection_tenant_id"();



CREATE OR REPLACE TRIGGER "trigger_set_confession_number" BEFORE INSERT ON "public"."debt_confessions" FOR EACH ROW EXECUTE FUNCTION "public"."set_confession_number"();



CREATE OR REPLACE TRIGGER "trigger_set_contract_number" BEFORE INSERT ON "public"."accounting_contracts" FOR EACH ROW EXECUTE FUNCTION "public"."set_contract_number"();



CREATE OR REPLACE TRIGGER "trigger_set_letter_number" BEFORE INSERT ON "public"."responsibility_letters" FOR EACH ROW EXECUTE FUNCTION "public"."set_letter_number"();



CREATE OR REPLACE TRIGGER "trigger_set_proposal_number" BEFORE INSERT ON "public"."service_proposals" FOR EACH ROW EXECUTE FUNCTION "public"."set_proposal_number"();



CREATE OR REPLACE TRIGGER "trigger_set_termination_number" BEFORE INSERT ON "public"."contract_terminations" FOR EACH ROW EXECUTE FUNCTION "public"."set_termination_number"();



CREATE OR REPLACE TRIGGER "trigger_sync_category_name" AFTER UPDATE ON "public"."expense_categories" FOR EACH ROW EXECUTE FUNCTION "public"."sync_category_name_to_expenses"();



CREATE OR REPLACE TRIGGER "trigger_update_cash_entries_updated_at" BEFORE UPDATE ON "public"."cash_entries" FOR EACH ROW EXECUTE FUNCTION "public"."update_cash_entries_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_cash_flow_projections_updated_at" BEFORE UPDATE ON "public"."cash_flow_projections" FOR EACH ROW EXECUTE FUNCTION "public"."update_cash_flow_projections_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_opening_balance" AFTER INSERT OR DELETE OR UPDATE ON "public"."client_opening_balance" FOR EACH ROW EXECUTE FUNCTION "public"."update_client_opening_balance"();



CREATE OR REPLACE TRIGGER "trigger_update_work_order_status" AFTER INSERT ON "public"."collection_work_order_logs" FOR EACH ROW EXECUTE FUNCTION "public"."update_work_order_status_on_log"();



CREATE OR REPLACE TRIGGER "trigger_validate_client_before_insert" BEFORE INSERT OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."validate_client_before_insert"();



CREATE OR REPLACE TRIGGER "update_accounts_payable_updated_at" BEFORE UPDATE ON "public"."accounts_payable" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_ai_agents_updated_at" BEFORE UPDATE ON "public"."ai_agents" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_bank_accounts_updated_at" BEFORE UPDATE ON "public"."bank_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_bank_balance_updated_at" BEFORE UPDATE ON "public"."bank_balance" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_banking_credentials_updated_at" BEFORE UPDATE ON "public"."banking_credentials" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_caixa_postal_timestamp" BEFORE UPDATE ON "public"."serpro_caixa_postal" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_cash_flow_transactions_updated_at" BEFORE UPDATE ON "public"."cash_flow_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_chart_of_accounts_updated_at" BEFORE UPDATE ON "public"."chart_of_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_client_monthly_revenue_updated_at" BEFORE UPDATE ON "public"."client_monthly_revenue" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_client_partners_updated_at" BEFORE UPDATE ON "public"."client_partners" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_client_payers_updated_at" BEFORE UPDATE ON "public"."client_payers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_clients_updated_at" BEFORE UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_collection_rules_updated_at" BEFORE UPDATE ON "public"."collection_rules" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_contracts_updated_at" BEFORE UPDATE ON "public"."contracts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_dashboard_widgets_updated_at" BEFORE UPDATE ON "public"."dashboard_widgets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_economic_groups_updated_at_trigger" BEFORE UPDATE ON "public"."economic_groups" FOR EACH ROW EXECUTE FUNCTION "public"."update_economic_groups_updated_at"();



CREATE OR REPLACE TRIGGER "update_expenses_updated_at" BEFORE UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invoices_updated_at" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_message_templates_updated_at" BEFORE UPDATE ON "public"."message_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_organizations_updated_at" BEFORE UPDATE ON "public"."organizations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_proposals_updated_at" BEFORE UPDATE ON "public"."proposals" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_revenue_types_updated_at" BEFORE UPDATE ON "public"."revenue_types" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_roles_updated_at" BEFORE UPDATE ON "public"."roles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_tax_obligations_updated_at" BEFORE UPDATE ON "public"."tax_obligations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_work_orders_updated_at" BEFORE UPDATE ON "public"."collection_work_orders" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_workflows_updated_at" BEFORE UPDATE ON "public"."workflows" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "validate_client_document_trigger" BEFORE INSERT OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."validate_client_document"();



CREATE OR REPLACE TRIGGER "validate_invoice_due_date" BEFORE INSERT ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."validate_due_date"();



ALTER TABLE ONLY "public"."account_balances"
    ADD CONSTRAINT "account_balances_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "accounting_contracts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "accounting_contracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "accounting_contracts_proposal_id_fkey" FOREIGN KEY ("proposal_id") REFERENCES "public"."service_proposals"("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "accounting_entries_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "accounting_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "accounting_entries_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "accounting_entries_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."accounting_entry_items"
    ADD CONSTRAINT "accounting_entry_items_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."accounting_entry_items"
    ADD CONSTRAINT "accounting_entry_items_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."accounting_entry_items"
    ADD CONSTRAINT "accounting_entry_items_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."accounting_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."accounting_entry_lines"
    ADD CONSTRAINT "accounting_entry_lines_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."accounting_entry_lines"
    ADD CONSTRAINT "accounting_entry_lines_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."accounting_entry_lines"
    ADD CONSTRAINT "accounting_entry_lines_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."accounting_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."accounting_entry_tracking"
    ADD CONSTRAINT "accounting_entry_tracking_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."accounting_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."accounting_entry_tracking"
    ADD CONSTRAINT "accounting_entry_tracking_payroll_id_fkey" FOREIGN KEY ("payroll_id") REFERENCES "public"."payrolls"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_closed_by_fkey" FOREIGN KEY ("closed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_locked_by_fkey" FOREIGN KEY ("locked_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "accounting_provisions_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "accounting_provisions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "accounting_provisions_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "accounting_provisions_realization_entry_id_fkey" FOREIGN KEY ("realization_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."accounts_payable"
    ADD CONSTRAINT "accounts_payable_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."accounts_payable"
    ADD CONSTRAINT "accounts_payable_nfse_tomada_id_fkey" FOREIGN KEY ("nfse_tomada_id") REFERENCES "public"."nfse_tomadas"("id");



ALTER TABLE ONLY "public"."accounts_payable"
    ADD CONSTRAINT "accounts_payable_parent_expense_id_fkey" FOREIGN KEY ("parent_expense_id") REFERENCES "public"."accounts_payable"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."agent_commissions"
    ADD CONSTRAINT "agent_commissions_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."commission_agents"("id");



ALTER TABLE ONLY "public"."agent_commissions"
    ADD CONSTRAINT "agent_commissions_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."ai_agents"
    ADD CONSTRAINT "ai_agents_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_automation_logs"
    ADD CONSTRAINT "ai_automation_logs_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."ai_classification_history"
    ADD CONSTRAINT "ai_classification_history_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."ai_classification_history"
    ADD CONSTRAINT "ai_classification_history_entity_id_fkey" FOREIGN KEY ("entity_id") REFERENCES "public"."ai_known_entities"("id");



ALTER TABLE ONLY "public"."ai_classification_history"
    ADD CONSTRAINT "ai_classification_history_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_classification_patterns"
    ADD CONSTRAINT "ai_classification_patterns_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_classification_patterns"
    ADD CONSTRAINT "ai_classification_patterns_entity_id_fkey" FOREIGN KEY ("entity_id") REFERENCES "public"."ai_known_entities"("id");



ALTER TABLE ONLY "public"."ai_executions"
    ADD CONSTRAINT "ai_executions_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."ai_agents"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ai_executions"
    ADD CONSTRAINT "ai_executions_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ai_executions"
    ADD CONSTRAINT "ai_executions_executed_by_fkey" FOREIGN KEY ("executed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_known_entities"
    ADD CONSTRAINT "ai_known_entities_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_learned_patterns"
    ADD CONSTRAINT "ai_learned_patterns_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_pending_questions"
    ADD CONSTRAINT "ai_pending_questions_answered_by_fkey" FOREIGN KEY ("answered_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_pending_questions"
    ADD CONSTRAINT "ai_pending_questions_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."ai_pending_questions"
    ADD CONSTRAINT "ai_pending_questions_import_id_fkey" FOREIGN KEY ("import_id") REFERENCES "public"."bank_imports"("id");



ALTER TABLE ONLY "public"."ai_presentations"
    ADD CONSTRAINT "ai_presentations_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."ai_meetings"("id");



ALTER TABLE ONLY "public"."ai_validation_queue"
    ADD CONSTRAINT "ai_validation_queue_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."accounting_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."balance_sheet_lines"
    ADD CONSTRAINT "balance_sheet_lines_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."balance_sheet_lines"
    ADD CONSTRAINT "balance_sheet_lines_balance_sheet_id_fkey" FOREIGN KEY ("balance_sheet_id") REFERENCES "public"."balance_sheets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."balance_sheets"
    ADD CONSTRAINT "balance_sheets_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."balance_sheets"
    ADD CONSTRAINT "balance_sheets_fiscal_year_closing_id_fkey" FOREIGN KEY ("fiscal_year_closing_id") REFERENCES "public"."fiscal_year_closings"("id");



ALTER TABLE ONLY "public"."bank_accounts"
    ADD CONSTRAINT "bank_accounts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bank_accounts"
    ADD CONSTRAINT "bank_accounts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."bank_imports"
    ADD CONSTRAINT "bank_imports_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bank_opening_balances"
    ADD CONSTRAINT "bank_opening_balances_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bank_opening_balances"
    ADD CONSTRAINT "bank_opening_balances_source_closing_id_fkey" FOREIGN KEY ("source_closing_id") REFERENCES "public"."monthly_closings"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_accounting_entry_id_fkey" FOREIGN KEY ("accounting_entry_id") REFERENCES "public"."accounting_entries"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_boleto_item_id_fkey" FOREIGN KEY ("boleto_item_id") REFERENCES "public"."boleto_report_items"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_reconciled_by_fkey" FOREIGN KEY ("reconciled_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "bank_reconciliation_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."bank_statement_imports"
    ADD CONSTRAINT "bank_statement_imports_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id");



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "bank_transaction_matches_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "bank_transaction_matches_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "bank_transaction_matches_expense_id_fkey" FOREIGN KEY ("expense_id") REFERENCES "public"."expenses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "bank_transaction_matches_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_accounts_payable_id_fkey" FOREIGN KEY ("accounts_payable_id") REFERENCES "public"."accounts_payable"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_chart_account_id_fkey" FOREIGN KEY ("chart_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_expense_id_fkey" FOREIGN KEY ("expense_id") REFERENCES "public"."expenses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_import_id_fkey" FOREIGN KEY ("import_id") REFERENCES "public"."bank_statement_imports"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "bank_transactions_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."accounting_entries"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."banking_credentials"
    ADD CONSTRAINT "banking_credentials_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."barter_credits"
    ADD CONSTRAINT "barter_credits_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."barter_credits"
    ADD CONSTRAINT "barter_credits_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "boleto_payments_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "boleto_payments_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "boleto_payments_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "boleto_report_items_accounting_entry_id_fkey" FOREIGN KEY ("accounting_entry_id") REFERENCES "public"."accounting_entries"("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "boleto_report_items_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "boleto_report_items_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "boleto_report_items_report_id_fkey" FOREIGN KEY ("report_id") REFERENCES "public"."boleto_reports"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."boleto_reports"
    ADD CONSTRAINT "boleto_reports_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cash_entries"
    ADD CONSTRAINT "cash_entries_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."cash_entries"
    ADD CONSTRAINT "cash_entries_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."cash_entries"
    ADD CONSTRAINT "cash_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cash_flow_projections"
    ADD CONSTRAINT "cash_flow_projections_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cash_flow_transactions"
    ADD CONSTRAINT "cash_flow_transactions_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_balance"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."classification_learning"
    ADD CONSTRAINT "classification_learning_chart_account_id_fkey" FOREIGN KEY ("chart_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."client_commission_agents"
    ADD CONSTRAINT "client_commission_agents_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."commission_agents"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_commission_agents"
    ADD CONSTRAINT "client_commission_agents_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "client_contracts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "client_contracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "client_contracts_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."document_templates"("id");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_contract_id_fkey" FOREIGN KEY ("contract_id") REFERENCES "public"."client_contracts"("id");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "client_distracts_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."document_templates"("id");



ALTER TABLE ONLY "public"."client_enrichment"
    ADD CONSTRAINT "client_enrichment_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_ledger"
    ADD CONSTRAINT "client_ledger_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_ledger"
    ADD CONSTRAINT "client_ledger_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_ledger"
    ADD CONSTRAINT "client_ledger_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "client_monthly_revenue_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."client_opening_balance"
    ADD CONSTRAINT "client_opening_balance_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_opening_balance_history"
    ADD CONSTRAINT "client_opening_balance_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."client_opening_balance"
    ADD CONSTRAINT "client_opening_balance_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."client_partners"
    ADD CONSTRAINT "client_partners_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_partners"
    ADD CONSTRAINT "client_partners_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "public"."partners"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_payers"
    ADD CONSTRAINT "client_payers_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_referrals"
    ADD CONSTRAINT "client_referrals_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_referrals"
    ADD CONSTRAINT "client_referrals_referral_partner_id_fkey" FOREIGN KEY ("referral_partner_id") REFERENCES "public"."referral_partners"("id");



ALTER TABLE ONLY "public"."client_variable_fees"
    ADD CONSTRAINT "client_variable_fees_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_variable_fees"
    ADD CONSTRAINT "client_variable_fees_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_accounting_account_id_fkey" FOREIGN KEY ("accounting_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."collection_rules"
    ADD CONSTRAINT "collection_rules_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."collection_rules"
    ADD CONSTRAINT "collection_rules_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."message_templates"("id");



ALTER TABLE ONLY "public"."collection_work_order_logs"
    ADD CONSTRAINT "collection_work_order_logs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."collection_work_order_logs"
    ADD CONSTRAINT "collection_work_order_logs_work_order_id_fkey" FOREIGN KEY ("work_order_id") REFERENCES "public"."collection_work_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."collection_work_orders"
    ADD CONSTRAINT "collection_work_orders_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."collection_work_orders"
    ADD CONSTRAINT "collection_work_orders_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."collection_work_orders"
    ADD CONSTRAINT "collection_work_orders_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."company_partners"
    ADD CONSTRAINT "company_partners_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."company_profile"("id");



ALTER TABLE ONLY "public"."company_service_costs"
    ADD CONSTRAINT "company_service_costs_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."company_service_costs"
    ADD CONSTRAINT "company_service_costs_service_id_fkey" FOREIGN KEY ("service_id") REFERENCES "public"."company_services"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_services"
    ADD CONSTRAINT "company_services_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."company_services"
    ADD CONSTRAINT "company_services_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."content_publish_queue"
    ADD CONSTRAINT "content_publish_queue_content_id_fkey" FOREIGN KEY ("content_id") REFERENCES "public"."generated_content"("id");



ALTER TABLE ONLY "public"."contract_addendums"
    ADD CONSTRAINT "contract_addendums_contract_id_fkey" FOREIGN KEY ("contract_id") REFERENCES "public"."accounting_contracts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contract_addendums"
    ADD CONSTRAINT "contract_addendums_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "contract_terminations_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "contract_terminations_contract_id_fkey" FOREIGN KEY ("contract_id") REFERENCES "public"."accounting_contracts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "contract_terminations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_document_id_fkey" FOREIGN KEY ("document_id") REFERENCES "public"."documents"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "contracts_proposal_id_fkey" FOREIGN KEY ("proposal_id") REFERENCES "public"."proposals"("id");



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "cost_center_accounts_chart_account_id_fkey" FOREIGN KEY ("chart_account_id") REFERENCES "public"."chart_of_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "cost_center_accounts_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "cost_center_accounts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "cost_centers_default_chart_account_id_fkey" FOREIGN KEY ("default_chart_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "cost_centers_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."dashboard_widgets"
    ADD CONSTRAINT "dashboard_widgets_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."debt_confession_installments"
    ADD CONSTRAINT "debt_confession_installments_confession_id_fkey" FOREIGN KEY ("confession_id") REFERENCES "public"."debt_confessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."debt_confessions"
    ADD CONSTRAINT "debt_confessions_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."debt_confessions"
    ADD CONSTRAINT "debt_confessions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "debt_negotiations_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "debt_negotiations_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "debt_negotiations_negotiated_by_fkey" FOREIGN KEY ("negotiated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."document_templates"
    ADD CONSTRAINT "document_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_expense_id_fkey" FOREIGN KEY ("expense_id") REFERENCES "public"."expenses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."domain_events"
    ADD CONSTRAINT "domain_events_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."domain_events"
    ADD CONSTRAINT "domain_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."economic_group_members"
    ADD CONSTRAINT "economic_group_members_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."economic_group_members"
    ADD CONSTRAINT "economic_group_members_economic_group_id_fkey" FOREIGN KEY ("economic_group_id") REFERENCES "public"."economic_groups"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."economic_groups"
    ADD CONSTRAINT "economic_groups_main_payer_client_id_fkey" FOREIGN KEY ("main_payer_client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."employee_sales"
    ADD CONSTRAINT "employee_sales_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id");



ALTER TABLE ONLY "public"."employee_sales"
    ADD CONSTRAINT "employee_sales_policy_id_fkey" FOREIGN KEY ("policy_id") REFERENCES "public"."employee_incentive_policies"("id");



ALTER TABLE ONLY "public"."employee_terminations"
    ADD CONSTRAINT "employee_terminations_accounting_entry_id_fkey" FOREIGN KEY ("accounting_entry_id") REFERENCES "public"."accounting_entries"("id");



ALTER TABLE ONLY "public"."employee_terminations"
    ADD CONSTRAINT "employee_terminations_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id");



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "employees_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."company_profile"("id");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "esocial_rubricas_account_credit_id_fkey" FOREIGN KEY ("account_credit_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "esocial_rubricas_account_debit_id_fkey" FOREIGN KEY ("account_debit_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "esocial_rubricas_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."expense_categories"
    ADD CONSTRAINT "expense_categories_chart_account_id_fkey" FOREIGN KEY ("chart_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."expense_categories"
    ADD CONSTRAINT "expense_categories_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."expense_categories"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_chart_account_id_fkey" FOREIGN KEY ("chart_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_parent_expense_id_fkey" FOREIGN KEY ("parent_expense_id") REFERENCES "public"."expenses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id");



ALTER TABLE ONLY "public"."feature_analysis_history"
    ADD CONSTRAINT "feature_analysis_history_feature_id_fkey" FOREIGN KEY ("feature_id") REFERENCES "public"."feature_requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."fee_adjustment_history"
    ADD CONSTRAINT "fee_adjustment_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."fee_adjustment_history"
    ADD CONSTRAINT "fee_adjustment_history_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_closing_journal_entry_id_fkey" FOREIGN KEY ("closing_journal_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_result_account_id_fkey" FOREIGN KEY ("result_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fiscal_year_closings_result_transfer_entry_id_fkey" FOREIGN KEY ("result_transfer_entry_id") REFERENCES "public"."journal_entries"("id");



ALTER TABLE ONLY "public"."account_balances"
    ADD CONSTRAINT "fk_account_balances_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_contracts"
    ADD CONSTRAINT "fk_accounting_contracts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_entries"
    ADD CONSTRAINT "fk_accounting_entries_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_entry_items"
    ADD CONSTRAINT "fk_accounting_entry_items_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_entry_lines"
    ADD CONSTRAINT "fk_accounting_entry_lines_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_entry_tracking"
    ADD CONSTRAINT "fk_accounting_entry_tracking_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_office"
    ADD CONSTRAINT "fk_accounting_office_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "fk_accounting_periods_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounting_provisions"
    ADD CONSTRAINT "fk_accounting_provisions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."accounts_payable"
    ADD CONSTRAINT "fk_accounts_payable_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."agent_commissions"
    ADD CONSTRAINT "fk_agent_commissions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_agents"
    ADD CONSTRAINT "fk_ai_agents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_automation_logs"
    ADD CONSTRAINT "fk_ai_automation_logs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_classification_history"
    ADD CONSTRAINT "fk_ai_classification_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_classification_patterns"
    ADD CONSTRAINT "fk_ai_classification_patterns_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_executions"
    ADD CONSTRAINT "fk_ai_executions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_known_entities"
    ADD CONSTRAINT "fk_ai_known_entities_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_labor_consultations"
    ADD CONSTRAINT "fk_ai_labor_consultations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_learned_patterns"
    ADD CONSTRAINT "fk_ai_learned_patterns_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_meetings"
    ADD CONSTRAINT "fk_ai_meetings_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_page_agents"
    ADD CONSTRAINT "fk_ai_page_agents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_pending_questions"
    ADD CONSTRAINT "fk_ai_pending_questions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_presentations"
    ADD CONSTRAINT "fk_ai_presentations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."ai_validation_queue"
    ADD CONSTRAINT "fk_ai_validation_queue_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "fk_audit_logs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."auditoria_achados"
    ADD CONSTRAINT "fk_auditoria_achados_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."auditoria_execucoes"
    ADD CONSTRAINT "fk_auditoria_execucoes_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."automation_logs"
    ADD CONSTRAINT "fk_automation_logs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."balance_sheet_lines"
    ADD CONSTRAINT "fk_balance_sheet_lines_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."balance_sheets"
    ADD CONSTRAINT "fk_balance_sheets_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_accounts"
    ADD CONSTRAINT "fk_bank_accounts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_balance"
    ADD CONSTRAINT "fk_bank_balance_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_imports"
    ADD CONSTRAINT "fk_bank_imports_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_opening_balances"
    ADD CONSTRAINT "fk_bank_opening_balances_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_reconciliation"
    ADD CONSTRAINT "fk_bank_reconciliation_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_statement_imports"
    ADD CONSTRAINT "fk_bank_statement_imports_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_transaction_matches"
    ADD CONSTRAINT "fk_bank_transaction_matches_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."bank_transactions"
    ADD CONSTRAINT "fk_bank_transactions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."banking_credentials"
    ADD CONSTRAINT "fk_banking_credentials_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."barter_credits"
    ADD CONSTRAINT "fk_barter_credits_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."boleto_payments"
    ADD CONSTRAINT "fk_boleto_payments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."boleto_report_items"
    ADD CONSTRAINT "fk_boleto_report_items_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."boleto_reports"
    ADD CONSTRAINT "fk_boleto_reports_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."business_maturity_analysis"
    ADD CONSTRAINT "fk_business_maturity_analysis_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."cash_entries"
    ADD CONSTRAINT "fk_cash_entries_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."cash_flow_transactions"
    ADD CONSTRAINT "fk_cash_flow_transactions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "fk_chart_of_accounts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."classification_learning"
    ADD CONSTRAINT "fk_classification_learning_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_commission_agents"
    ADD CONSTRAINT "fk_client_commission_agents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "fk_client_contacts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_contracts"
    ADD CONSTRAINT "fk_client_contracts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_distracts"
    ADD CONSTRAINT "fk_client_distracts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_enrichment"
    ADD CONSTRAINT "fk_client_enrichment_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_ledger"
    ADD CONSTRAINT "fk_client_ledger_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_monthly_revenue"
    ADD CONSTRAINT "fk_client_monthly_revenue_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_opening_balance_history"
    ADD CONSTRAINT "fk_client_opening_balance_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_opening_balance"
    ADD CONSTRAINT "fk_client_opening_balance_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_partners_prospects"
    ADD CONSTRAINT "fk_client_partners_prospects_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_partners"
    ADD CONSTRAINT "fk_client_partners_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_payers"
    ADD CONSTRAINT "fk_client_payers_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_referrals"
    ADD CONSTRAINT "fk_client_referrals_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."client_variable_fees"
    ADD CONSTRAINT "fk_client_variable_fees_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "fk_clients_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."collection_rules"
    ADD CONSTRAINT "fk_collection_rules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."collection_work_order_logs"
    ADD CONSTRAINT "fk_collection_work_order_logs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."collection_work_orders"
    ADD CONSTRAINT "fk_collection_work_orders_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."commission_agents"
    ADD CONSTRAINT "fk_commission_agents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."company_partners"
    ADD CONSTRAINT "fk_company_partners_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."company_profile"
    ADD CONSTRAINT "fk_company_profile_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."company_service_costs"
    ADD CONSTRAINT "fk_company_service_costs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."company_services"
    ADD CONSTRAINT "fk_company_services_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."content_publish_queue"
    ADD CONSTRAINT "fk_content_publish_queue_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."content_templates"
    ADD CONSTRAINT "fk_content_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."contract_addendums"
    ADD CONSTRAINT "fk_contract_addendums_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."contract_templates"
    ADD CONSTRAINT "fk_contract_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."contract_terminations"
    ADD CONSTRAINT "fk_contract_terminations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."contracts"
    ADD CONSTRAINT "fk_contracts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."cost_center_accounts"
    ADD CONSTRAINT "fk_cost_center_accounts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "fk_cost_centers_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."crm_clientes"
    ADD CONSTRAINT "fk_crm_clientes_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."crm_interacoes"
    ADD CONSTRAINT "fk_crm_interacoes_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."crm_oportunidades"
    ADD CONSTRAINT "fk_crm_oportunidades_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."crm_prospects"
    ADD CONSTRAINT "fk_crm_prospects_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."crm_tarefas"
    ADD CONSTRAINT "fk_crm_tarefas_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."dashboard_widgets"
    ADD CONSTRAINT "fk_dashboard_widgets_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."debt_confession_installments"
    ADD CONSTRAINT "fk_debt_confession_installments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."debt_confessions"
    ADD CONSTRAINT "fk_debt_confessions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."debt_negotiations"
    ADD CONSTRAINT "fk_debt_negotiations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."discount_approval_rules"
    ADD CONSTRAINT "fk_discount_approval_rules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."document_templates"
    ADD CONSTRAINT "fk_document_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "fk_documents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."domain_events"
    ADD CONSTRAINT "fk_domain_events_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."dr_cicero_knowledge"
    ADD CONSTRAINT "fk_dr_cicero_knowledge_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."economic_group_members"
    ADD CONSTRAINT "fk_economic_group_members_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."economic_groups"
    ADD CONSTRAINT "fk_economic_groups_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."employee_incentive_policies"
    ADD CONSTRAINT "fk_employee_incentive_policies_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."employee_sales"
    ADD CONSTRAINT "fk_employee_sales_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."employee_terminations"
    ADD CONSTRAINT "fk_employee_terminations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."employees"
    ADD CONSTRAINT "fk_employees_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."empresas"
    ADD CONSTRAINT "fk_empresas_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."enrichment_logs"
    ADD CONSTRAINT "fk_enrichment_logs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."esocial_rubricas"
    ADD CONSTRAINT "fk_esocial_rubricas_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."expense_categories"
    ADD CONSTRAINT "fk_expense_categories_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "fk_expenses_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."feature_analysis_history"
    ADD CONSTRAINT "fk_feature_analysis_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."feature_requests"
    ADD CONSTRAINT "fk_feature_requests_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."feature_templates"
    ADD CONSTRAINT "fk_feature_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."fee_adjustment_history"
    ADD CONSTRAINT "fk_fee_adjustment_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."file_processing_queue"
    ADD CONSTRAINT "fk_file_processing_queue_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."financial_analysis"
    ADD CONSTRAINT "fk_financial_analysis_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."financial_gap_solutions"
    ADD CONSTRAINT "fk_financial_gap_solutions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."fiscal_year_closings"
    ADD CONSTRAINT "fk_fiscal_year_closings_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."generated_content"
    ADD CONSTRAINT "fk_generated_content_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."grupos_economicos"
    ADD CONSTRAINT "fk_grupos_economicos_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."import_files"
    ADD CONSTRAINT "fk_import_files_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."initial_load_control"
    ADD CONSTRAINT "fk_initial_load_control_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."intelligence_rules"
    ADD CONSTRAINT "fk_intelligence_rules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "fk_inventory_movements_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."invoice_generation_rules"
    ADD CONSTRAINT "fk_invoice_generation_rules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."invoice_status_audit"
    ADD CONSTRAINT "fk_invoice_status_audit_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "fk_invoices_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "fk_irpf_declarations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "fk_journal_entries_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."journal_entry_lines"
    ADD CONSTRAINT "fk_journal_entry_lines_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."labor_alerts"
    ADD CONSTRAINT "fk_labor_alerts_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."labor_jurisprudence"
    ADD CONSTRAINT "fk_labor_jurisprudence_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."labor_legislation"
    ADD CONSTRAINT "fk_labor_legislation_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."labor_solution_strategies"
    ADD CONSTRAINT "fk_labor_solution_strategies_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."logs_erros"
    ADD CONSTRAINT "fk_logs_erros_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."logs_sincronizacao"
    ADD CONSTRAINT "fk_logs_sincronizacao_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."marketing_videos"
    ADD CONSTRAINT "fk_marketing_videos_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."materialized_view_refresh_log"
    ADD CONSTRAINT "fk_materialized_view_refresh_log_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."meeting_default_participants"
    ADD CONSTRAINT "fk_meeting_default_participants_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."message_templates"
    ADD CONSTRAINT "fk_message_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."metrics_snapshots"
    ADD CONSTRAINT "fk_metrics_snapshots_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."minimum_wage_history"
    ADD CONSTRAINT "fk_minimum_wage_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."monthly_closings"
    ADD CONSTRAINT "fk_monthly_closings_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "fk_negotiation_contact_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."negotiation_installments"
    ADD CONSTRAINT "fk_negotiation_installments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."nfse_config"
    ADD CONSTRAINT "fk_nfse_config_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."nfse_log"
    ADD CONSTRAINT "fk_nfse_log_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "fk_nfse_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "fk_nfse_tomadas_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."notifications_log"
    ADD CONSTRAINT "fk_notifications_log_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."office_products"
    ADD CONSTRAINT "fk_office_products_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."office_recurring_expenses"
    ADD CONSTRAINT "fk_office_recurring_expenses_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."office_settings"
    ADD CONSTRAINT "fk_office_settings_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "fk_organization_users_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "fk_organizations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."parametros_folha"
    ADD CONSTRAINT "fk_parametros_folha_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."partner_family"
    ADD CONSTRAINT "fk_partner_family_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."partner_properties"
    ADD CONSTRAINT "fk_partner_properties_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."partner_vehicles"
    ADD CONSTRAINT "fk_partner_vehicles_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."partners"
    ADD CONSTRAINT "fk_partners_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payroll_details"
    ADD CONSTRAINT "fk_payroll_details_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payroll_events"
    ADD CONSTRAINT "fk_payroll_events_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payroll_journal_entries"
    ADD CONSTRAINT "fk_payroll_journal_entries_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payroll_payments"
    ADD CONSTRAINT "fk_payroll_payments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payroll"
    ADD CONSTRAINT "fk_payroll_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."payrolls"
    ADD CONSTRAINT "fk_payrolls_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "fk_pending_reconciliations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."perdcomp_pedidos"
    ADD CONSTRAINT "fk_perdcomp_pedidos_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."period_close_history"
    ADD CONSTRAINT "fk_period_close_history_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."period_reopen_requests"
    ADD CONSTRAINT "fk_period_reopen_requests_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."plr_criteria"
    ADD CONSTRAINT "fk_plr_criteria_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."plr_employee_share"
    ADD CONSTRAINT "fk_plr_employee_share_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."plr_programs"
    ADD CONSTRAINT "fk_plr_programs_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."product_consumption"
    ADD CONSTRAINT "fk_product_consumption_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."product_purchases"
    ADD CONSTRAINT "fk_product_purchases_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "fk_profiles_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."program_prerequisites"
    ADD CONSTRAINT "fk_program_prerequisites_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "fk_proposals_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."provider_invoices"
    ADD CONSTRAINT "fk_provider_invoices_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."purchase_list_items"
    ADD CONSTRAINT "fk_purchase_list_items_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."purchase_lists"
    ADD CONSTRAINT "fk_purchase_lists_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."reconciliation_rules"
    ADD CONSTRAINT "fk_reconciliation_rules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."recurring_expense_templates"
    ADD CONSTRAINT "fk_recurring_expense_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."recurring_expenses"
    ADD CONSTRAINT "fk_recurring_expenses_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."recurring_payments"
    ADD CONSTRAINT "fk_recurring_payments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."referral_commission_payments"
    ADD CONSTRAINT "fk_referral_commission_payments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."referral_partners"
    ADD CONSTRAINT "fk_referral_partners_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."referral_policy"
    ADD CONSTRAINT "fk_referral_policy_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."referral_program"
    ADD CONSTRAINT "fk_referral_program_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "fk_responsibility_letters_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."retencoes_tributarias"
    ADD CONSTRAINT "fk_retencoes_tributarias_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."revenue_categories"
    ADD CONSTRAINT "fk_revenue_categories_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."risk_solution_mapping"
    ADD CONSTRAINT "fk_risk_solution_mapping_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."sales_training_modules"
    ADD CONSTRAINT "fk_sales_training_modules_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."sales_training_records"
    ADD CONSTRAINT "fk_sales_training_records_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."serpro_caixa_postal"
    ADD CONSTRAINT "fk_serpro_caixa_postal_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."service_proposals"
    ADD CONSTRAINT "fk_service_proposals_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."service_providers"
    ADD CONSTRAINT "fk_service_providers_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."solution_templates"
    ADD CONSTRAINT "fk_solution_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."sora_generation_queue"
    ADD CONSTRAINT "fk_sora_generation_queue_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."sora_video_projects"
    ADD CONSTRAINT "fk_sora_video_projects_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."sora_video_templates"
    ADD CONSTRAINT "fk_sora_video_templates_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."stored_documents"
    ADD CONSTRAINT "fk_stored_documents_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "fk_suppliers_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."system_users"
    ADD CONSTRAINT "fk_system_users_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tax_configurations"
    ADD CONSTRAINT "fk_tax_configurations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tax_installments"
    ADD CONSTRAINT "fk_tax_installments_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tax_obligations"
    ADD CONSTRAINT "fk_tax_obligations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tenant_features"
    ADD CONSTRAINT "fk_tenant_features_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."trial_balance_lines"
    ADD CONSTRAINT "fk_trial_balance_lines_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."trial_balances"
    ADD CONSTRAINT "fk_trial_balances_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tv_playlist"
    ADD CONSTRAINT "fk_tv_playlist_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."tv_video_playlist"
    ADD CONSTRAINT "fk_tv_video_playlist_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."user_office_access"
    ADD CONSTRAINT "fk_user_office_access_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "fk_user_roles_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "fk_variable_fee_calculations_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."video_branding_config"
    ADD CONSTRAINT "fk_video_branding_config_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."workflow_executions"
    ADD CONSTRAINT "fk_workflow_executions_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."workflows"
    ADD CONSTRAINT "fk_workflows_tenant" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id");



ALTER TABLE ONLY "public"."generated_content"
    ADD CONSTRAINT "generated_content_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."content_templates"("id");



ALTER TABLE ONLY "public"."holidays"
    ADD CONSTRAINT "holidays_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."import_files"
    ADD CONSTRAINT "import_files_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."initial_load_control"
    ADD CONSTRAINT "initial_load_control_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."office_products"("id");



ALTER TABLE ONLY "public"."invoice_generation_rules"
    ADD CONSTRAINT "invoice_generation_rules_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoice_generation_rules"
    ADD CONSTRAINT "invoice_generation_rules_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."invoice_status_audit"
    ADD CONSTRAINT "invoice_status_audit_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."invoice_status_audit"
    ADD CONSTRAINT "invoice_status_audit_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_revenue_type_id_fkey" FOREIGN KEY ("revenue_type_id") REFERENCES "public"."revenue_types"("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "irpf_declarations_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "irpf_declarations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."irpf_declarations"
    ADD CONSTRAINT "irpf_declarations_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."journal_entry_lines"
    ADD CONSTRAINT "journal_entry_lines_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."journal_entry_lines"
    ADD CONSTRAINT "journal_entry_lines_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."journal_entry_lines"
    ADD CONSTRAINT "journal_entry_lines_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."labor_alerts"
    ADD CONSTRAINT "labor_alerts_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."message_templates"
    ADD CONSTRAINT "message_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."minimum_wage_history"
    ADD CONSTRAINT "minimum_wage_history_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."monthly_closings"
    ADD CONSTRAINT "monthly_closings_closed_by_fkey" FOREIGN KEY ("closed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."monthly_closings"
    ADD CONSTRAINT "monthly_closings_reopened_by_fkey" FOREIGN KEY ("reopened_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "negotiation_contact_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "negotiation_contact_history_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."client_contacts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "negotiation_contact_history_contacted_by_fkey" FOREIGN KEY ("contacted_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."negotiation_contact_history"
    ADD CONSTRAINT "negotiation_contact_history_negotiation_id_fkey" FOREIGN KEY ("negotiation_id") REFERENCES "public"."debt_negotiations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."negotiation_installments"
    ADD CONSTRAINT "negotiation_installments_negotiation_id_fkey" FOREIGN KEY ("negotiation_id") REFERENCES "public"."debt_negotiations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "nfse_cancelled_by_fkey" FOREIGN KEY ("cancelled_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "nfse_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "nfse_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."nfse"
    ADD CONSTRAINT "nfse_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."nfse_log"
    ADD CONSTRAINT "nfse_log_nfse_id_fkey" FOREIGN KEY ("nfse_id") REFERENCES "public"."nfse"("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "nfse_tomadas_conta_pagar_id_fkey" FOREIGN KEY ("conta_pagar_id") REFERENCES "public"."accounts_payable"("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "nfse_tomadas_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."nfse_tomadas"
    ADD CONSTRAINT "nfse_tomadas_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id");



ALTER TABLE ONLY "public"."notifications_log"
    ADD CONSTRAINT "notifications_log_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications_log"
    ADD CONSTRAINT "notifications_log_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."office_recurring_expenses"
    ADD CONSTRAINT "office_recurring_expenses_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."company_profile"("id");



ALTER TABLE ONLY "public"."office_settings"
    ADD CONSTRAINT "office_settings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "organization_users_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "organization_users_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."roles"("id");



ALTER TABLE ONLY "public"."organization_users"
    ADD CONSTRAINT "organization_users_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_family"
    ADD CONSTRAINT "partner_family_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "public"."company_partners"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_properties"
    ADD CONSTRAINT "partner_properties_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "public"."company_partners"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partner_vehicles"
    ADD CONSTRAINT "partner_vehicles_partner_id_fkey" FOREIGN KEY ("partner_id") REFERENCES "public"."company_partners"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."partners"
    ADD CONSTRAINT "partners_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payroll_details"
    ADD CONSTRAINT "payroll_details_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."payroll_details"
    ADD CONSTRAINT "payroll_details_payroll_id_fkey" FOREIGN KEY ("payroll_id") REFERENCES "public"."payrolls"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payroll"
    ADD CONSTRAINT "payroll_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id");



ALTER TABLE ONLY "public"."payroll_events"
    ADD CONSTRAINT "payroll_events_payroll_id_fkey" FOREIGN KEY ("payroll_id") REFERENCES "public"."payroll"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payroll_events"
    ADD CONSTRAINT "payroll_events_rubrica_codigo_fkey" FOREIGN KEY ("rubrica_codigo") REFERENCES "public"."esocial_rubricas"("codigo");



ALTER TABLE ONLY "public"."payroll_journal_entries"
    ADD CONSTRAINT "payroll_journal_entries_payroll_id_fkey" FOREIGN KEY ("payroll_id") REFERENCES "public"."payroll"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payroll_payments"
    ADD CONSTRAINT "payroll_payments_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payroll_payments"
    ADD CONSTRAINT "payroll_payments_payroll_id_fkey" FOREIGN KEY ("payroll_id") REFERENCES "public"."payrolls"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."payroll_payments"
    ADD CONSTRAINT "payroll_payments_tracking_codigo_fkey" FOREIGN KEY ("tracking_codigo") REFERENCES "public"."accounting_entry_tracking"("codigo_rastreamento");



ALTER TABLE ONLY "public"."payrolls"
    ADD CONSTRAINT "payrolls_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_bank_account_id_fkey" FOREIGN KEY ("bank_account_id") REFERENCES "public"."bank_accounts"("id");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_chart_of_accounts_id_fkey" FOREIGN KEY ("chart_of_accounts_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."pending_reconciliations"
    ADD CONSTRAINT "pending_reconciliations_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."perdcomp_pedidos"
    ADD CONSTRAINT "perdcomp_pedidos_empresa_id_fkey" FOREIGN KEY ("empresa_id") REFERENCES "public"."empresas"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."period_close_history"
    ADD CONSTRAINT "period_close_history_performed_by_fkey" FOREIGN KEY ("performed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."period_close_history"
    ADD CONSTRAINT "period_close_history_period_id_fkey" FOREIGN KEY ("period_id") REFERENCES "public"."accounting_periods"("id");



ALTER TABLE ONLY "public"."period_reopen_requests"
    ADD CONSTRAINT "period_reopen_requests_period_id_fkey" FOREIGN KEY ("period_id") REFERENCES "public"."accounting_periods"("id");



ALTER TABLE ONLY "public"."period_reopen_requests"
    ADD CONSTRAINT "period_reopen_requests_requested_by_fkey" FOREIGN KEY ("requested_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."period_reopen_requests"
    ADD CONSTRAINT "period_reopen_requests_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."plr_criteria"
    ADD CONSTRAINT "plr_criteria_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."plr_programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."plr_employee_share"
    ADD CONSTRAINT "plr_employee_share_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id");



ALTER TABLE ONLY "public"."plr_employee_share"
    ADD CONSTRAINT "plr_employee_share_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."plr_programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_consumption"
    ADD CONSTRAINT "product_consumption_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."office_products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_purchases"
    ADD CONSTRAINT "product_purchases_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."office_products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."provider_invoices"
    ADD CONSTRAINT "provider_invoices_provider_id_fkey" FOREIGN KEY ("provider_id") REFERENCES "public"."service_providers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_list_items"
    ADD CONSTRAINT "purchase_list_items_list_id_fkey" FOREIGN KEY ("list_id") REFERENCES "public"."purchase_lists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_list_items"
    ADD CONSTRAINT "purchase_list_items_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."office_products"("id");



ALTER TABLE ONLY "public"."reconciliation_rules"
    ADD CONSTRAINT "reconciliation_rules_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."reconciliation_rules"
    ADD CONSTRAINT "reconciliation_rules_target_account_id_fkey" FOREIGN KEY ("target_account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."referral_commission_payments"
    ADD CONSTRAINT "referral_commission_payments_bank_transaction_id_fkey" FOREIGN KEY ("bank_transaction_id") REFERENCES "public"."bank_transactions"("id");



ALTER TABLE ONLY "public"."referral_commission_payments"
    ADD CONSTRAINT "referral_commission_payments_referral_id_fkey" FOREIGN KEY ("referral_id") REFERENCES "public"."client_referrals"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "responsibility_letters_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "responsibility_letters_contract_id_fkey" FOREIGN KEY ("contract_id") REFERENCES "public"."accounting_contracts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."responsibility_letters"
    ADD CONSTRAINT "responsibility_letters_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."revenue_types"
    ADD CONSTRAINT "revenue_types_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."sales_training_records"
    ADD CONSTRAINT "sales_training_records_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."sales_training_modules"("id");



ALTER TABLE ONLY "public"."serpro_caixa_postal"
    ADD CONSTRAINT "serpro_caixa_postal_empresa_id_fkey" FOREIGN KEY ("empresa_id") REFERENCES "public"."empresas"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_proposals"
    ADD CONSTRAINT "service_proposals_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."service_proposals"
    ADD CONSTRAINT "service_proposals_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."service_providers"
    ADD CONSTRAINT "service_providers_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."company_profile"("id");



ALTER TABLE ONLY "public"."sora_generation_queue"
    ADD CONSTRAINT "sora_generation_queue_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."sora_video_projects"("id");



ALTER TABLE ONLY "public"."stored_documents"
    ADD CONSTRAINT "stored_documents_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."stored_documents"
    ADD CONSTRAINT "stored_documents_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."system_users"
    ADD CONSTRAINT "system_users_employee_id_fkey" FOREIGN KEY ("employee_id") REFERENCES "public"."employees"("id");



ALTER TABLE ONLY "public"."tax_obligations"
    ADD CONSTRAINT "tax_obligations_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tax_obligations"
    ADD CONSTRAINT "tax_obligations_responsible_user_id_fkey" FOREIGN KEY ("responsible_user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."tenant_features"
    ADD CONSTRAINT "tenant_features_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tenant_users"
    ADD CONSTRAINT "tenant_users_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "public"."tenants"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tenant_users"
    ADD CONSTRAINT "tenant_users_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trial_balance_lines"
    ADD CONSTRAINT "trial_balance_lines_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."trial_balance_lines"
    ADD CONSTRAINT "trial_balance_lines_trial_balance_id_fkey" FOREIGN KEY ("trial_balance_id") REFERENCES "public"."trial_balances"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trial_balances"
    ADD CONSTRAINT "trial_balances_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."tv_video_playlist"
    ADD CONSTRAINT "tv_video_playlist_video_project_id_fkey" FOREIGN KEY ("video_project_id") REFERENCES "public"."sora_video_projects"("id");



ALTER TABLE ONLY "public"."user_office_access"
    ADD CONSTRAINT "user_office_access_office_id_fkey" FOREIGN KEY ("office_id") REFERENCES "public"."accounting_office"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_office_access"
    ADD CONSTRAINT "user_office_access_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "variable_fee_calculations_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "variable_fee_calculations_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."variable_fee_calculations"
    ADD CONSTRAINT "variable_fee_calculations_variable_fee_id_fkey" FOREIGN KEY ("variable_fee_id") REFERENCES "public"."client_variable_fees"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_executions"
    ADD CONSTRAINT "workflow_executions_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."workflows"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflows"
    ADD CONSTRAINT "workflows_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");




-- ============================================================================
-- SECAO 8: POLITICAS DE SEGURANCA (RLS POLICIES)
-- ============================================================================
-- 230 politicas RLS garantindo seguranca dos dados:
--
-- TIPOS DE POLITICAS:
--   - saas_isolation_strict: Isolamento por tenant_id
--   - public_read_only: Tabelas de lookup publicas
--   - role-based: Acesso baseado em papel do usuario
--
-- FUNCAO PRINCIPAL:
--   get_my_tenant_id() - Retorna o tenant_id do usuario logado
--   Todas as politicas usam: tenant_id = get_my_tenant_id()
-- ============================================================================

CREATE POLICY "Acesso Seguro por Tenant" ON "public"."cash_flow_projections" USING (("tenant_id" = ((("auth"."jwt"() -> 'app_metadata'::"text") ->> 'tenant_id'::"text"))::"uuid"));



CREATE POLICY "Admins and accountants can create revenue types" ON "public"."revenue_types" FOR INSERT TO "authenticated" WITH CHECK (( SELECT ("public"."has_role"("auth"."uid"(), 'admin'::"public"."app_role") OR "public"."has_role"("auth"."uid"(), 'accountant'::"public"."app_role"))));



CREATE POLICY "Admins and accountants can update revenue types" ON "public"."revenue_types" FOR UPDATE TO "authenticated" USING (( SELECT ("public"."has_role"("auth"."uid"(), 'admin'::"public"."app_role") OR "public"."has_role"("auth"."uid"(), 'accountant'::"public"."app_role")))) WITH CHECK (( SELECT ("public"."has_role"("auth"."uid"(), 'admin'::"public"."app_role") OR "public"."has_role"("auth"."uid"(), 'accountant'::"public"."app_role"))));



CREATE POLICY "Admins can delete revenue types" ON "public"."revenue_types" FOR DELETE TO "authenticated" USING (( SELECT "public"."has_role"("auth"."uid"(), 'admin'::"public"."app_role") AS "has_role"));



CREATE POLICY "Users can delete projections from their tenant" ON "public"."cash_flow_projections" FOR DELETE TO "authenticated" USING (("tenant_id" = "public"."get_current_tenant_id"()));



CREATE POLICY "Users can insert projections to their tenant" ON "public"."cash_flow_projections" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Users can update projections from their tenant" ON "public"."cash_flow_projections" FOR UPDATE TO "authenticated" USING (("tenant_id" = "public"."get_current_tenant_id"()));



CREATE POLICY "Users can view projections from their tenant" ON "public"."cash_flow_projections" FOR SELECT TO "authenticated" USING (("tenant_id" = "public"."get_current_tenant_id"()));




-- ============================================================================
-- SECAO 7: ROW LEVEL SECURITY (RLS)
-- ============================================================================
-- Ativacao de RLS em todas as tabelas para isolamento multi-tenant.
-- Cada tabela tera politicas que filtram dados por tenant_id.
-- ============================================================================

ALTER TABLE "public"."account_balances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_contracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_entry_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_entry_lines" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_entry_tracking" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_office" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_periods" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_provisions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounts_payable" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."agent_commissions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_agents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_automation_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_classification_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_classification_patterns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_executions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_known_entities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_labor_consultations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_learned_patterns" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_meetings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_page_agents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_pending_questions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_presentations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_providers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_validation_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."auditoria_achados" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."auditoria_execucoes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."automation_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."balance_sheet_lines" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."balance_sheets" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_accounts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_balance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_imports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_opening_balances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_reconciliation" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_statement_imports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_transaction_matches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bank_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."banking_credentials" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."barter_credits" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_accounting_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_accounting_entry_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_bank_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_chart_of_accounts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_clients" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bkp_20260106_suppliers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."boleto_payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."boleto_report_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."boleto_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."business_maturity_analysis" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cash_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cash_flow_projections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cash_flow_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."chart_of_accounts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."classification_learning" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_commission_agents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_contacts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_contracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_distracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_enrichment" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_ledger" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_monthly_revenue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_opening_balance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_opening_balance_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_partners_prospects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_payers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_referrals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."client_variable_fees" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."codigos_servico_lc116" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."collection_rules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."collection_work_order_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."collection_work_orders" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."commission_agents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_profile" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_service_costs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_services" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."content_publish_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."content_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contract_addendums" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contract_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contract_terminations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."contracts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cost_center_accounts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."cost_centers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."crm_clientes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."crm_interacoes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."crm_oportunidades" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."crm_prospects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."crm_tarefas" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."dashboard_widgets" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."debt_confession_installments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."debt_confessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."debt_negotiations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."discount_approval_rules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."document_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."domain_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."dr_cicero_knowledge" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."economic_group_members" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."economic_groups" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employee_incentive_policies" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employee_sales" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employee_terminations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."employees" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."empresas" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."enrichment_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."esocial_rubricas" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."expense_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."expenses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."feature_analysis_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."feature_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."feature_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."fee_adjustment_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."file_processing_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."financial_analysis" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."financial_gap_solutions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."fiscal_year_closings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."generated_content" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."grupos_economicos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."holidays" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."import_files" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."initial_load_control" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."intelligence_rules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."inventory_movements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoice_generation_rules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoice_status_audit" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."irpf_declarations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."journal_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."journal_entry_lines" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."labor_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."labor_jurisprudence" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."labor_legislation" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."labor_solution_strategies" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."logs_erros" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."logs_sincronizacao" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."marketing_videos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."materialized_view_refresh_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."meeting_default_participants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."message_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."metrics_snapshots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."minimum_wage_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."monthly_closings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."negotiation_contact_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."negotiation_installments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."nfse" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."nfse_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."nfse_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."nfse_tomadas" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."notifications_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."office_products" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."office_recurring_expenses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."office_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organization_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organizations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."parametros_folha" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_family" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_properties" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partner_vehicles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payroll" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payroll_details" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payroll_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payroll_journal_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payroll_payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payrolls" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pending_reconciliations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."perdcomp_pedidos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."period_close_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."period_reopen_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plr_criteria" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plr_employee_share" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plr_programs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_consumption" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."product_purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."program_prerequisites" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."proposals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."provider_invoices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "public_read_only" ON "public"."ai_providers" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."codigos_servico_lc116" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."holidays" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."revenue_types" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."roles" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."tabela_inss" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "public_read_only" ON "public"."tabela_irrf" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."purchase_list_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."purchase_lists" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."reconciliation_rules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recurring_expense_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recurring_expenses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recurring_payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_commission_payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_partners" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_policy" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_program" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."responsibility_letters" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."retencoes_tributarias" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."revenue_types" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."risk_solution_mapping" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."roles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "saas_isolation_strict" ON "public"."account_balances" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_contracts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_entries" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_entry_items" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_entry_lines" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_entry_tracking" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_office" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_periods" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounting_provisions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."accounts_payable" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."agent_commissions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_agents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_automation_logs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_classification_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_classification_patterns" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_executions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_known_entities" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_labor_consultations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_learned_patterns" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_meetings" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_page_agents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_pending_questions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_presentations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."ai_validation_queue" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."audit_logs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."auditoria_achados" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."auditoria_execucoes" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."automation_logs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."balance_sheet_lines" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."balance_sheets" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_accounts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_balance" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_imports" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_opening_balances" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_reconciliation" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_statement_imports" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_transaction_matches" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."bank_transactions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."banking_credentials" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."barter_credits" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."boleto_payments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."boleto_report_items" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."boleto_reports" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."business_maturity_analysis" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."cash_entries" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."cash_flow_transactions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."chart_of_accounts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."classification_learning" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_commission_agents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_contacts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_contracts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_distracts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_enrichment" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_ledger" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_monthly_revenue" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_opening_balance" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_opening_balance_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_partners" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_partners_prospects" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_payers" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_referrals" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."client_variable_fees" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."clients" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."collection_rules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."collection_work_order_logs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."collection_work_orders" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."commission_agents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."company_partners" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."company_profile" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."company_service_costs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."company_services" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."content_publish_queue" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."content_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."contract_addendums" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."contract_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."contract_terminations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."contracts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."cost_center_accounts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."cost_centers" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."crm_clientes" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."crm_interacoes" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."crm_oportunidades" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."crm_prospects" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."crm_tarefas" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."dashboard_widgets" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."debt_confession_installments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."debt_confessions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."debt_negotiations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."discount_approval_rules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."document_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."documents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."domain_events" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."dr_cicero_knowledge" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."economic_group_members" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."economic_groups" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."employee_incentive_policies" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."employee_sales" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."employee_terminations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."employees" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."empresas" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."enrichment_logs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."esocial_rubricas" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."expense_categories" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."expenses" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."feature_analysis_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."feature_requests" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."feature_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."fee_adjustment_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."file_processing_queue" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."financial_analysis" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."financial_gap_solutions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."fiscal_year_closings" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."generated_content" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."grupos_economicos" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."import_files" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."initial_load_control" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."intelligence_rules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."inventory_movements" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."invoice_generation_rules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."invoice_status_audit" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."invoices" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."irpf_declarations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."journal_entries" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."journal_entry_lines" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."labor_alerts" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."labor_jurisprudence" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."labor_legislation" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."labor_solution_strategies" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."logs_erros" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."logs_sincronizacao" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."marketing_videos" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."materialized_view_refresh_log" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."meeting_default_participants" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."message_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."metrics_snapshots" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."minimum_wage_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."monthly_closings" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."negotiation_contact_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."negotiation_installments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."nfse" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."nfse_config" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."nfse_log" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."nfse_tomadas" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."notifications_log" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."office_products" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."office_recurring_expenses" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."office_settings" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."organization_users" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."organizations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."parametros_folha" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."partner_family" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."partner_properties" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."partner_vehicles" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."partners" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payroll" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payroll_details" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payroll_events" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payroll_journal_entries" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payroll_payments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."payrolls" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."pending_reconciliations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."perdcomp_pedidos" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."period_close_history" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."period_reopen_requests" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."plr_criteria" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."plr_employee_share" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."plr_programs" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."product_consumption" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."product_purchases" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."program_prerequisites" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."proposals" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."provider_invoices" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."purchase_list_items" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."purchase_lists" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."reconciliation_rules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."recurring_expense_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."recurring_expenses" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."recurring_payments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."referral_commission_payments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."referral_partners" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."referral_policy" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."referral_program" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."responsibility_letters" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."retencoes_tributarias" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."revenue_categories" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."risk_solution_mapping" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."sales_training_modules" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."sales_training_records" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."serpro_caixa_postal" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."service_proposals" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."service_providers" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."solution_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."sora_generation_queue" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."sora_video_projects" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."sora_video_templates" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."stored_documents" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."suppliers" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."system_users" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tax_configurations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tax_installments" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tax_obligations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tenant_features" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."trial_balance_lines" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."trial_balances" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tv_playlist" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."tv_video_playlist" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."user_office_access" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."user_roles" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."variable_fee_calculations" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."video_branding_config" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."workflow_executions" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



CREATE POLICY "saas_isolation_strict" ON "public"."workflows" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



ALTER TABLE "public"."sales_training_modules" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sales_training_records" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."serpro_caixa_postal" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."service_proposals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."service_providers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."solution_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sora_generation_queue" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sora_video_projects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."sora_video_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."stored_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."suppliers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tabela_inss" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tabela_irrf" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tax_configurations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tax_installments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tax_obligations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tenant_features" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tenant_isolation_policy" ON "public"."profiles" TO "authenticated" USING (("tenant_id" = "public"."get_my_tenant_id"())) WITH CHECK (("tenant_id" = "public"."get_my_tenant_id"()));



ALTER TABLE "public"."tenant_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tenants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trial_balance_lines" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."trial_balances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tv_playlist" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tv_video_playlist" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_office_access" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_view_own_entry" ON "public"."tenant_users" FOR SELECT TO "authenticated" USING (("user_id" = ( SELECT "auth"."uid"() AS "uid")));



CREATE POLICY "user_view_own_tenant" ON "public"."tenants" FOR SELECT TO "authenticated" USING (("id" IN ( SELECT "tenant_users"."tenant_id"
   FROM "public"."tenant_users"
  WHERE ("tenant_users"."user_id" = ( SELECT "auth"."uid"() AS "uid")))));



ALTER TABLE "public"."variable_fee_calculations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."video_branding_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."workflow_executions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."workflows" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";













-- ============================================================================
-- SECAO 9: PERMISSOES (GRANTS)
-- ============================================================================
-- Permissoes para os roles do Supabase:
--
-- ROLES:
--   - anon: Usuarios nao autenticados (acesso restrito)
--   - authenticated: Usuarios logados (acesso via RLS)
--   - service_role: Backend/APIs (acesso total, bypassa RLS)
--
-- OBJETOS:
--   - SCHEMA public: Acesso ao schema principal
--   - TABLES: Acesso a todas as tabelas
--   - FUNCTIONS: Acesso a todas as funcoes
--   - SEQUENCES: Acesso a sequences (auto-increment)
-- ============================================================================

GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

















































































































































































GRANT ALL ON FUNCTION "public"."activate_negotiation"("p_negotiation_id" "uuid", "p_contract_url" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."activate_negotiation"("p_negotiation_id" "uuid", "p_contract_url" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."activate_negotiation"("p_negotiation_id" "uuid", "p_contract_url" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_barter_credit"("p_client_id" "uuid", "p_type" "text", "p_amount" numeric, "p_description" "text", "p_reference_date" "date", "p_competence" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text", "p_state_code" "text", "p_municipality_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text", "p_state_code" "text", "p_municipality_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."adjust_to_business_day"("p_date" "date", "p_direction" "text", "p_state_code" "text", "p_municipality_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."analyze_feature_request"("p_feature_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_fee_adjustment"("p_client_id" "uuid", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_negotiation"("p_negotiation_id" "uuid", "p_approved" boolean, "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_negotiation"("p_negotiation_id" "uuid", "p_approved" boolean, "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_negotiation"("p_negotiation_id" "uuid", "p_approved" boolean, "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_purchase_list"("p_list_id" "uuid", "p_agent_id" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_purchase_list"("p_list_id" "uuid", "p_agent_id" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_purchase_list"("p_list_id" "uuid", "p_agent_id" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."aprovar_rescisao"("p_termination_id" "uuid", "p_approved_by" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_invoice_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."audit_invoice_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_invoice_status_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_classify_pro_bono"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_classify_pro_bono"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_classify_pro_bono"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_generate_payroll"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_generate_payroll"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_generate_payroll"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_reconcile_expense_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_reconcile_expense_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_reconcile_expense_payment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_reconcile_invoice_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_reconcile_invoice_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_reconcile_invoice_payment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_reconcile_new_transaction"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_reconcile_new_transaction"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_reconcile_new_transaction"() TO "service_role";



GRANT ALL ON FUNCTION "public"."bank_imports_set_statement_key"() TO "anon";
GRANT ALL ON FUNCTION "public"."bank_imports_set_statement_key"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."bank_imports_set_statement_key"() TO "service_role";



GRANT ALL ON FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean, "p_dry_run" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean, "p_dry_run" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."batch_apply_fee_adjustments"("p_only_pending" boolean, "p_dry_run" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."batch_generate_annual_invoices"("p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_clientes_inadimplentes"("p_tenant_id" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_clientes_inadimplentes"("p_tenant_id" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_clientes_inadimplentes"("p_tenant_id" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_despesas_categoria"("p_data_inicio" "date", "p_data_fim" "date", "p_categoria" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_despesas_periodo"("p_inicio" "date", "p_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_despesas_periodo"("p_inicio" "date", "p_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_despesas_periodo"("p_inicio" "date", "p_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid", "p_cliente_nome" "text", "p_limite" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid", "p_cliente_nome" "text", "p_limite" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_historico_cliente"("p_cliente_id" "uuid", "p_cliente_nome" "text", "p_limite" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_recebimentos_pix"("p_data_inicio" "date", "p_data_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_receita_por_cliente"("p_inicio" "date", "p_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_receita_por_cliente"("p_inicio" "date", "p_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_receita_por_cliente"("p_inicio" "date", "p_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_receitas_periodo"("p_inicio" "date", "p_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_receitas_periodo"("p_inicio" "date", "p_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_receitas_periodo"("p_inicio" "date", "p_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_saldos_bancos"() TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_saldos_bancos"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_saldos_bancos"() TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_top_clientes"("p_data_inicio" "date", "p_data_fim" "date", "p_limite" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."buscar_total_despesas"("p_inicio" "date", "p_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."buscar_total_despesas"("p_inicio" "date", "p_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."buscar_total_despesas"("p_inicio" "date", "p_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calcular_inss"("p_base_calculo" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."calcular_inss"("p_base_calculo" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calcular_inss"("p_base_calculo" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."calcular_irrf"("p_base_calculo" numeric, "p_dependentes" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calcular_irrf"("p_base_calculo" numeric, "p_dependentes" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calcular_irrf"("p_base_calculo" numeric, "p_dependentes" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calcular_prescricao"() TO "anon";
GRANT ALL ON FUNCTION "public"."calcular_prescricao"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calcular_prescricao"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calcular_rescisao"("p_employee_id" "uuid", "p_termination_date" "date", "p_last_working_day" "date", "p_termination_type" "text", "p_notice_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_adjusted_fee"("p_fee_in_minimum_wages" numeric, "p_target_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_business_maturity"("p_period" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_business_maturity"("p_period" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_business_maturity"("p_period" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_client_debt"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text", "p_municipality_code" "text", "p_adjust_direction" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text", "p_municipality_code" "text", "p_adjust_direction" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_due_date"("p_year" integer, "p_month" integer, "p_payment_day" integer, "p_state_code" "text", "p_municipality_code" "text", "p_adjust_direction" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_employee_commission"("p_sale_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_employee_commission"("p_sale_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_employee_commission"("p_sale_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_employee_plr"("p_program_id" "uuid", "p_employee_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_employee_plr"("p_program_id" "uuid", "p_employee_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_employee_plr"("p_program_id" "uuid", "p_employee_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_labor_provisions"("p_employee_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_referral_end_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_referral_end_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_referral_end_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_reference_month" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_variable_fee"("p_client_id" "uuid", "p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."can_implement_program"("p_program_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."can_implement_program"("p_program_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_implement_program"("p_program_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."capture_domain_event"() TO "anon";
GRANT ALL ON FUNCTION "public"."capture_domain_event"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."capture_domain_event"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_analytical_account_only"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_analytical_account_only"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_analytical_account_only"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_employee_hire_date_for_payroll"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_employee_hire_date_for_payroll"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_employee_hire_date_for_payroll"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_entry_balance"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_entry_balance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_entry_balance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_entry_exists"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."check_entry_exists"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_entry_exists"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."check_period_before_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_period_before_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_period_before_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."classify_transaction_on_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."classify_transaction_on_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."classify_transaction_on_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."close_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."cmd_create_accounting_entry"("p_account_id" "uuid", "p_entry_date" "date", "p_entry_type" "text", "p_amount" numeric, "p_description" "text", "p_client_id" "uuid", "p_reference_type" "text", "p_reference_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."cmd_create_accounting_entry"("p_account_id" "uuid", "p_entry_date" "date", "p_entry_type" "text", "p_amount" numeric, "p_description" "text", "p_client_id" "uuid", "p_reference_type" "text", "p_reference_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cmd_create_accounting_entry"("p_account_id" "uuid", "p_entry_date" "date", "p_entry_type" "text", "p_amount" numeric, "p_description" "text", "p_client_id" "uuid", "p_reference_type" "text", "p_reference_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."comparar_meses"("p_mes_atual" "text", "p_mes_anterior" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."comparar_meses"("p_mes_atual" "text", "p_mes_anterior" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."comparar_meses"("p_mes_atual" "text", "p_mes_anterior" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric, "p_model" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric, "p_model" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_ai_validation"("p_queue_id" "uuid", "p_result" "text", "p_message" "text", "p_confidence" numeric, "p_model" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."convert_fee_to_minimum_wages"("p_client_id" "uuid", "p_reference_minimum_wage" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_accounting_entry_for_invoice"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_auto_consultation"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_auto_consultation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_auto_consultation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_client_accounting_account"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_client_accounting_account"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_client_accounting_account"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_confession_installments"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_confession_installments"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_confession_installments"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_debt_negotiation"("p_client_id" "uuid", "p_invoice_ids" "uuid"[], "p_opening_balance_ids" "uuid"[], "p_discount_percentage" numeric, "p_installments_count" integer, "p_first_due_date" "date", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_economic_group"("p_group_name" "text", "p_main_company_name" "text", "p_main_company_cnpj" "text", "p_member_companies" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_economic_group"("p_group_name" "text", "p_main_company_name" "text", "p_main_company_cnpj" "text", "p_member_companies" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_economic_group"("p_group_name" "text", "p_main_company_name" "text", "p_main_company_cnpj" "text", "p_member_companies" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_entry_from_bank_transaction"("p_transaction_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_entry_from_bank_transaction"("p_transaction_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_entry_from_bank_transaction"("p_transaction_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_entry_from_invoice"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_entry_from_invoice"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_entry_from_invoice"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_expense_payment_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_expense_payment_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_expense_payment_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_expense_provision_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_expense_provision_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_expense_provision_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry"() TO "service_role";



GRANT ALL ON TABLE "public"."invoices" TO "anon";
GRANT ALL ON TABLE "public"."invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."invoices" TO "service_role";



GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry_manual"("p_invoice" "public"."invoices") TO "anon";
GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry_manual"("p_invoice" "public"."invoices") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_invoice_accounting_entry_manual"("p_invoice" "public"."invoices") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_invoice_payment_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_invoice_payment_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_invoice_payment_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_invoice_provision_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_invoice_provision_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_invoice_provision_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_journal_entry"("p_entry_date" "date", "p_competence_date" "date", "p_entry_type" "text", "p_description" "text", "p_reference_type" "text", "p_reference_id" "uuid", "p_debit_account_id" "uuid", "p_credit_account_id" "uuid", "p_amount" numeric, "p_created_by" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text", "p_employee_id" "uuid", "p_phone" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text", "p_employee_id" "uuid", "p_phone" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_system_user"("p_name" "text", "p_email" "text", "p_role" "text", "p_employee_id" "uuid", "p_phone" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_tenant_trigger"("table_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_tenant_trigger"("table_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_tenant_trigger"("table_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date", "p_data_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date", "p_data_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."dashboard_financeiro"("p_data_inicio" "date", "p_data_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_journal_entries_by_reference"("p_reference_type" "text", "p_reference_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."distribute_plr"("p_program_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."distribute_plr"("p_program_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."distribute_plr"("p_program_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."fail_ai_validation"("p_queue_id" "uuid", "p_error" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."fail_ai_validation"("p_queue_id" "uuid", "p_error" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fail_ai_validation"("p_queue_id" "uuid", "p_error" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."find_known_pattern"("description" "text", "txn_type" "text", "amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."find_known_pattern"("description" "text", "txn_type" "text", "amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."find_known_pattern"("description" "text", "txn_type" "text", "amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fix_invoice_due_dates"("p_competence" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."fix_pro_bono_classification"() TO "anon";
GRANT ALL ON FUNCTION "public"."fix_pro_bono_classification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fix_pro_bono_classification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_accounting_expense_provision"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_expense_provision"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_expense_provision"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_accounting_invoice_provision"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_invoice_provision"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_invoice_provision"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_accounting_opening_balance"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_opening_balance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_opening_balance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_accounting_reconciliation"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_reconciliation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_accounting_reconciliation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_invoice"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_invoice"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_invoice"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_saldo_abertura"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_saldo_abertura"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_contabilizar_saldo_abertura"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_auto_set_tenant_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_auto_set_tenant_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_auto_set_tenant_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_create_client_account"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_create_client_account"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_create_client_account"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_create_supplier_account"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_create_supplier_account"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_create_supplier_account"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_learn_from_classification"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_learn_from_classification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_learn_from_classification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_predict_classification"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_predict_classification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_predict_classification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean, "p_dias_vencimento" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean, "p_dias_vencimento" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_processar_nfse_tomada"("p_nfse_tomada_id" "uuid", "p_criar_conta_pagar" boolean, "p_dias_vencimento" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_validar_honorarios_mensais"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_validar_honorarios_mensais"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_validar_honorarios_mensais"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_addendum_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_addendum_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_addendum_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_annual_invoices"("p_client_id" "uuid", "p_year" integer, "p_include_13th" boolean, "p_dry_run" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_bank_tx_code"("p_reference" "text", "p_date" "date", "p_amount" numeric, "p_description" "text", "p_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_bank_tx_code"("p_reference" "text", "p_date" "date", "p_amount" numeric, "p_description" "text", "p_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_bank_tx_code"("p_reference" "text", "p_date" "date", "p_amount" numeric, "p_description" "text", "p_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_confession_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_confession_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_confession_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_contract_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_contract_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_contract_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_internal_code"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_internal_code"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_internal_code"("p_source_type" character varying, "p_source_id" "uuid", "p_date" "date", "p_amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_irpf_forecast"("p_calendar_year" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_irpf_forecast"("p_calendar_year" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_irpf_forecast"("p_calendar_year" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_journal_entry_number"("p_fiscal_year" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_journal_entry_number"("p_fiscal_year" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_journal_entry_number"("p_fiscal_year" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_letter_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_letter_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_letter_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_meeting_agenda"("p_meeting_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_meeting_agenda"("p_meeting_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_meeting_agenda"("p_meeting_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_meeting_presentation"("p_meeting_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_meeting_presentation"("p_meeting_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_meeting_presentation"("p_meeting_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date", "p_due_day" integer, "p_simulate" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date", "p_due_day" integer, "p_simulate" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_monthly_fees"("p_competence_date" "date", "p_due_day" integer, "p_simulate" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_monthly_results_video"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_monthly_results_video"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_monthly_results_video"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_negotiation_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_negotiation_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_negotiation_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_payroll_journal_entries"("p_payroll_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_payroll_journal_entries"("p_payroll_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_payroll_journal_entries"("p_payroll_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_proposal_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_proposal_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_proposal_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_random_password"("length" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_random_password"("length" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_random_password"("length" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_recurring_expenses"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_recurring_expenses"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_recurring_expenses"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_shopping_list"("p_created_by" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_shopping_list"("p_created_by" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_shopping_list"("p_created_by" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_sora_video"("p_template_code" "text", "p_variables" "jsonb", "p_duration_seconds" integer, "p_aspect_ratio" "text", "p_priority" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_sora_video"("p_template_code" "text", "p_variables" "jsonb", "p_duration_seconds" integer, "p_aspect_ratio" "text", "p_priority" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_sora_video"("p_template_code" "text", "p_variables" "jsonb", "p_duration_seconds" integer, "p_aspect_ratio" "text", "p_priority" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_statement_key"("p_bank_account_id" "uuid", "p_period_start" "date", "p_period_end" "date", "p_opening_balance" numeric, "p_closing_balance" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."generate_statement_key"("p_bank_account_id" "uuid", "p_period_start" "date", "p_period_end" "date", "p_opening_balance" numeric, "p_closing_balance" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_statement_key"("p_bank_account_id" "uuid", "p_period_start" "date", "p_period_end" "date", "p_opening_balance" numeric, "p_closing_balance" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_technical_spec"("p_feature_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_technical_spec"("p_feature_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_technical_spec"("p_feature_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_termination_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_termination_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_termination_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_video_narration"("p_project_id" "uuid", "p_narration_text" "text", "p_voice" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_video_narration"("p_project_id" "uuid", "p_narration_text" "text", "p_voice" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_video_narration"("p_project_id" "uuid", "p_narration_text" "text", "p_voice" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gerar_folha_funcionario"("p_employee_id" "uuid", "p_competencia" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."gerar_folha_mensal"("p_competencia" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."gerar_lancamento_contabil_folha"() TO "anon";
GRANT ALL ON FUNCTION "public"."gerar_lancamento_contabil_folha"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."gerar_lancamento_contabil_folha"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_balances"("p_period_start" "date", "p_period_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_balances"("p_period_start" "date", "p_period_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_balances"("p_period_start" "date", "p_period_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_ledger"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_ledger_summary"("p_account_id" "uuid", "p_period_start" "date", "p_period_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_statement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON TABLE "public"."accounting_office" TO "anon";
GRANT ALL ON TABLE "public"."accounting_office" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_office" TO "service_role";



GRANT ALL ON FUNCTION "public"."get_accounting_office"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_accounting_office"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_accounting_office"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_balancete"("p_data_inicio" "date", "p_data_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_balancete"("p_data_inicio" "date", "p_data_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_balancete"("p_data_inicio" "date", "p_data_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_bank_balance_at_date"("p_bank_account_id" "uuid", "p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_barter_balance"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_chart_of_accounts_with_balances"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_chart_of_accounts_with_balances"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_chart_of_accounts_with_balances"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_cnpj_branch"("cnpj_value" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_cnpj_branch"("cnpj_value" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cnpj_branch"("cnpj_value" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_cnpj_root"("cnpj_value" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_cnpj_root"("cnpj_value" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cnpj_root"("cnpj_value" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_coa_balance"("p_account_id" "uuid", "p_as_of_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_coa_movement"("p_account_id" "uuid", "p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_coa_opening_balance"("p_account_id" "uuid", "p_period_start" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_current_minimum_wage"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_current_minimum_wage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_current_minimum_wage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_current_tenant_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_current_tenant_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_current_tenant_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_economic_group_by_client"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_economic_group_by_client"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_economic_group_by_client"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_economic_group_impact"("p_year" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_economic_group_impact"("p_year" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_economic_group_impact"("p_year" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_expense_account_id"("p_category" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_expense_account_id"("p_category" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_expense_account_id"("p_category" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_expense_or_adiantamento_account"("p_category" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_group_invoices_for_competence"("p_client_id" "uuid", "p_competence" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_group_invoices_for_competence"("p_client_id" "uuid", "p_competence" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_group_invoices_for_competence"("p_client_id" "uuid", "p_competence" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_labor_solutions_for_person"("p_person_type" "text", "p_person_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_labor_solutions_for_person"("p_person_type" "text", "p_person_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_labor_solutions_for_person"("p_person_type" "text", "p_person_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_minimum_wage_at_date"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_my_tenant_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_my_tenant_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_my_tenant_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_client_account_code"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_client_account_code"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_client_account_code"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_period"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_period"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_period"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_next_validation_item"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_next_validation_item"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_next_validation_item"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_client_account"("p_client_id" "uuid", "p_client_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_overdue_summary"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_overdue_summary"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_overdue_summary"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_partner_advance_balance"("partner_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_plano_contas_com_saldos"("p_ano" integer, "p_mes" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_plano_contas_com_saldos"("p_ano" integer, "p_mes" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_plano_contas_com_saldos"("p_ano" integer, "p_mes" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_razao_conta"("p_codigo_conta" character varying, "p_data_inicio" "date", "p_data_fim" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_razao_conta"("p_codigo_conta" character varying, "p_data_inicio" "date", "p_data_fim" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_razao_conta"("p_codigo_conta" character varying, "p_data_inicio" "date", "p_data_fim" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_resumo_manutencao_mensal"("p_ano" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_resumo_manutencao_mensal"("p_ano" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_resumo_manutencao_mensal"("p_ano" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_socio_adiantamento_account"("p_category" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_titulos_manutencao_cara"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_titulos_manutencao_cara"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_titulos_manutencao_cara"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_upcoming_payments"("p_days_ahead" integer, "p_include_personal" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."get_upcoming_payments"("p_days_ahead" integer, "p_include_personal" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_upcoming_payments"("p_days_ahead" integer, "p_include_personal" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_offices"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_offices"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_offices"() TO "service_role";



GRANT ALL ON FUNCTION "public"."guard_bank_imports_continuity"() TO "anon";
GRANT ALL ON FUNCTION "public"."guard_bank_imports_continuity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."guard_bank_imports_continuity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."guard_bank_imports_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."guard_bank_imports_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."guard_bank_imports_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_role"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_role"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_role"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_tenant"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_tenant"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_tenant"() TO "service_role";



GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "anon";
GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_role"("_user_id" "uuid", "_role" "public"."app_role") TO "service_role";



GRANT ALL ON FUNCTION "public"."identify_partner_prospects"() TO "anon";
GRANT ALL ON FUNCTION "public"."identify_partner_prospects"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."identify_partner_prospects"() TO "service_role";



GRANT ALL ON FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."import_partners_from_api_brasil"("p_client_id" "uuid", "p_partners_json" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_rule_usage"("rule_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_rule_usage"("rule_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_rule_usage"("rule_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."init_client_minimum_wage_fee"("p_client_id" "uuid", "p_reference_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_adiantamento_socio"("p_category" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_adiantamento_socio"("p_category" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_adiantamento_socio"("p_category" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text", "p_municipality_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text", "p_municipality_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_business_day"("p_date" "date", "p_state_code" "text", "p_municipality_code" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_in_economic_group"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_in_economic_group"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_in_economic_group"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_period_closed"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."is_period_open"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."is_period_open"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_period_open"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_transaction_reconciled_on_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."mark_transaction_reconciled_on_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_transaction_reconciled_on_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."normalize_for_matching"("input_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."normalize_for_matching"("input_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."normalize_for_matching"("input_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid", "p_paid_by" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid", "p_paid_by" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."pagar_rescisao"("p_termination_id" "uuid", "p_transaction_id" "uuid", "p_paid_by" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."prepare_content_generation"("p_template_code" "text", "p_variables" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."prepare_content_generation"("p_template_code" "text", "p_variables" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."prepare_content_generation"("p_template_code" "text", "p_variables" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_invoices_without_accounting"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_invoices_without_accounting"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_invoices_without_accounting"() TO "service_role";



GRANT ALL ON FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."propose_gap_solutions"("p_gap_type" "text", "p_gap_amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."protect_accounting_entry_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."protect_accounting_entry_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."protect_accounting_entry_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."protect_accounting_entry_line_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."protect_accounting_entry_line_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."protect_accounting_entry_line_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."protect_bank_transaction_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."protect_bank_transaction_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."protect_bank_transaction_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."protect_expense_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."protect_expense_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."protect_expense_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."protect_invoice_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."protect_invoice_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."protect_invoice_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."proximo_numero_rps"("p_prestador_cnpj" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."proximo_numero_rps"("p_prestador_cnpj" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."proximo_numero_rps"("p_prestador_cnpj" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."qry_client_dashboard"("p_client_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."qry_client_dashboard"("p_client_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."qry_client_dashboard"("p_client_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."qry_executive_summary"("p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."qry_executive_summary"("p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."qry_executive_summary"("p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_entry_for_ai_validation"("p_entry_id" "uuid", "p_priority" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."recalculate_bank_balance"("p_bank_account_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_account_ledger"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_account_ledger"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_account_ledger"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_all_materialized_views"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_all_materialized_views"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_all_materialized_views"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_coa_balances"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_coa_balances"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_coa_balances"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_dashboard_kpis"() TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_dashboard_kpis"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_dashboard_kpis"() TO "service_role";



GRANT ALL ON FUNCTION "public"."refresh_materialized_view"("view_name" "text", "trigger_source" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."refresh_materialized_view"("view_name" "text", "trigger_source" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."refresh_materialized_view"("view_name" "text", "trigger_source" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."register_consumption"("p_product_id" "uuid", "p_quantity" numeric, "p_consumed_by" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."register_consumption"("p_product_id" "uuid", "p_quantity" numeric, "p_consumed_by" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_consumption"("p_product_id" "uuid", "p_quantity" numeric, "p_consumed_by" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric, "p_interest_amount" numeric, "p_discount_amount" numeric, "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric, "p_interest_amount" numeric, "p_discount_amount" numeric, "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_invoice_payment"("p_invoice_id" "uuid", "p_payment_date" "date", "p_total_received" numeric, "p_fine_amount" numeric, "p_interest_amount" numeric, "p_discount_amount" numeric, "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."register_purchase_and_stock"("p_list_id" "uuid", "p_invoice_number" "text", "p_total_actual" numeric, "p_purchase_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."register_purchase_and_stock"("p_list_id" "uuid", "p_invoice_number" "text", "p_total_actual" numeric, "p_purchase_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_purchase_and_stock"("p_list_id" "uuid", "p_invoice_number" "text", "p_total_actual" numeric, "p_purchase_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reopen_month"("p_year" integer, "p_month" integer, "p_user_id" "uuid", "p_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text", "p_benefit" "text", "p_example" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text", "p_benefit" "text", "p_example" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."request_improvement"("p_requested_by" "text", "p_department" "text", "p_title" "text", "p_description" "text", "p_problem" "text", "p_benefit" "text", "p_example" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_user_password"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."reset_user_password"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_user_password"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."safe_create_entry"("p_entry_date" "date", "p_competence_date" "date", "p_description" character varying, "p_entry_type" character varying, "p_total_debit" numeric, "p_total_credit" numeric, "p_source_type" character varying, "p_source_id" "uuid", "p_reference_type" character varying, "p_reference_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."safe_create_entry"("p_entry_date" "date", "p_competence_date" "date", "p_description" character varying, "p_entry_type" character varying, "p_total_debit" numeric, "p_total_credit" numeric, "p_source_type" character varying, "p_source_id" "uuid", "p_reference_type" character varying, "p_reference_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."safe_create_entry"("p_entry_date" "date", "p_competence_date" "date", "p_description" character varying, "p_entry_type" character varying, "p_total_debit" numeric, "p_total_credit" numeric, "p_source_type" character varying, "p_source_id" "uuid", "p_reference_type" character varying, "p_reference_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."save_generated_content"("p_template_code" "text", "p_variables" "jsonb", "p_content" "text", "p_provider" "text", "p_model" "text", "p_tokens" integer, "p_time_ms" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."save_generated_content"("p_template_code" "text", "p_variables" "jsonb", "p_content" "text", "p_provider" "text", "p_model" "text", "p_tokens" integer, "p_time_ms" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."save_generated_content"("p_template_code" "text", "p_variables" "jsonb", "p_content" "text", "p_provider" "text", "p_model" "text", "p_tokens" integer, "p_time_ms" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."schedule_monthly_meeting"() TO "anon";
GRANT ALL ON FUNCTION "public"."schedule_monthly_meeting"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."schedule_monthly_meeting"() TO "service_role";



GRANT ALL ON FUNCTION "public"."search_jurisprudence"("p_keywords" "text"[], "p_outcome" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."search_jurisprudence"("p_keywords" "text"[], "p_outcome" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."search_jurisprudence"("p_keywords" "text"[], "p_outcome" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."set_addendum_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_addendum_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_addendum_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_bank_tx_internal_code"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_bank_tx_internal_code"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_bank_tx_internal_code"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_cash_flow_projection_tenant_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_cash_flow_projection_tenant_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_cash_flow_projection_tenant_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_confession_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_confession_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_confession_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_contract_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_contract_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_contract_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_internal_code"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_internal_code"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_internal_code"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_letter_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_letter_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_letter_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_proposal_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_proposal_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_proposal_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_termination_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_termination_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_termination_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_all_accounting_entries"("p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."sync_all_accounting_entries"("p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_all_accounting_entries"("p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_bank_balance_from_accounting"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_bank_balance_from_accounting"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_bank_balance_from_accounting"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_category_name_to_expenses"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_category_name_to_expenses"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_category_name_to_expenses"() TO "service_role";



GRANT ALL ON FUNCTION "public"."tr_payroll_generate_entries"() TO "anon";
GRANT ALL ON FUNCTION "public"."tr_payroll_generate_entries"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."tr_payroll_generate_entries"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_expense_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_expense_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_expense_delete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_expense_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_expense_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_expense_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_expense_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_expense_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_expense_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_invoice_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_invoice_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_invoice_delete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_invoice_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_invoice_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_invoice_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_invoice_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_invoice_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_invoice_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_bank_transaction_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_bank_transaction_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_bank_transaction_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_create_accounting_on_invoice"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_create_accounting_on_invoice"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_create_accounting_on_invoice"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_generate_contract_on_client"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_generate_contract_on_client"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_generate_contract_on_client"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_generate_distract_on_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_generate_distract_on_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_generate_distract_on_status_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_invoice_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_invoice_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_invoice_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_queue_new_entry_for_validation"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_queue_new_entry_for_validation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_queue_new_entry_for_validation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_recalc_journal_totals"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_recalc_journal_totals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_recalc_journal_totals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_update_bank_balance"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_update_bank_balance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_update_bank_balance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_update_ledger_after_journal"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_update_ledger_after_journal"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_update_ledger_after_journal"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_account_balances"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_account_balances"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_account_balances"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_ai_learned_patterns_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_ai_learned_patterns_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_ai_learned_patterns_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_bank_account_balance"("p_account_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_bank_balance_on_transaction"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_bank_balance_on_transaction"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_bank_balance_on_transaction"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_cash_entries_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_cash_entries_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_cash_entries_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_cash_flow_projections_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_cash_flow_projections_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_cash_flow_projections_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_client_opening_balance"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_client_opening_balance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_client_opening_balance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_economic_groups_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_economic_groups_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_economic_groups_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_entity_usage"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_entity_usage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_entity_usage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_nfse_tomadas_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_nfse_tomadas_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_nfse_tomadas_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_nfse_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_nfse_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_nfse_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_opening_balance_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_opening_balance_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_opening_balance_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_overdue_confession_installments"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_overdue_confession_installments"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_overdue_confession_installments"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_overdue_invoices"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_overdue_invoices"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_overdue_invoices"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_pattern_usage"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_pattern_usage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_pattern_usage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_payroll_totals"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_payroll_totals"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_payroll_totals"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_payrolls_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_payrolls_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_payrolls_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_service_total_costs"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_service_total_costs"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_service_total_costs"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_stock_after_consumption"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_stock_after_consumption"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_stock_after_consumption"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_stock_after_purchase"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_stock_after_purchase"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_stock_after_purchase"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_work_order_status_on_log"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_work_order_status_on_log"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_work_order_status_on_log"() TO "service_role";



GRANT ALL ON FUNCTION "public"."user_has_office_access"("p_office_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."user_has_office_access"("p_office_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."user_has_office_access"("p_office_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."user_has_permission"("required_permission" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."user_has_permission"("required_permission" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."user_has_permission"("required_permission" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_client_before_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_client_before_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_client_before_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_client_document"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_client_document"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_client_document"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_due_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_due_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_due_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_invoice_competence"("p_client_id" "uuid", "p_competence" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_invoice_competence"("p_client_id" "uuid", "p_competence" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_invoice_competence"("p_client_id" "uuid", "p_competence" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_payroll_details"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_payroll_details"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_payroll_details"() TO "service_role";
























GRANT ALL ON TABLE "public"."account_balances" TO "anon";
GRANT ALL ON TABLE "public"."account_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."account_balances" TO "service_role";



GRANT ALL ON TABLE "public"."chart_of_accounts" TO "anon";
GRANT ALL ON TABLE "public"."chart_of_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."chart_of_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."journal_entries" TO "anon";
GRANT ALL ON TABLE "public"."journal_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_entries" TO "service_role";



GRANT ALL ON TABLE "public"."journal_entry_lines" TO "anon";
GRANT ALL ON TABLE "public"."journal_entry_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_entry_lines" TO "service_role";



GRANT ALL ON TABLE "public"."account_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."account_ledger_detail" TO "anon";
GRANT ALL ON TABLE "public"."account_ledger_detail" TO "authenticated";
GRANT ALL ON TABLE "public"."account_ledger_detail" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_contracts" TO "anon";
GRANT ALL ON TABLE "public"."accounting_contracts" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_contracts" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_entries" TO "anon";
GRANT ALL ON TABLE "public"."accounting_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_entries" TO "service_role";



GRANT ALL ON SEQUENCE "public"."accounting_entries_entry_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."accounting_entries_entry_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."accounting_entries_entry_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_entry_items" TO "anon";
GRANT ALL ON TABLE "public"."accounting_entry_items" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_entry_items" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_entry_lines" TO "anon";
GRANT ALL ON TABLE "public"."accounting_entry_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_entry_lines" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_entry_tracking" TO "anon";
GRANT ALL ON TABLE "public"."accounting_entry_tracking" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_entry_tracking" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_periods" TO "anon";
GRANT ALL ON TABLE "public"."accounting_periods" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_periods" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_provisions" TO "anon";
GRANT ALL ON TABLE "public"."accounting_provisions" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_provisions" TO "service_role";



GRANT ALL ON TABLE "public"."accounts_payable" TO "anon";
GRANT ALL ON TABLE "public"."accounts_payable" TO "authenticated";
GRANT ALL ON TABLE "public"."accounts_payable" TO "service_role";



GRANT ALL ON TABLE "public"."agent_commissions" TO "anon";
GRANT ALL ON TABLE "public"."agent_commissions" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_commissions" TO "service_role";



GRANT ALL ON TABLE "public"."ai_agents" TO "anon";
GRANT ALL ON TABLE "public"."ai_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_agents" TO "service_role";



GRANT ALL ON TABLE "public"."ai_automation_logs" TO "anon";
GRANT ALL ON TABLE "public"."ai_automation_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_automation_logs" TO "service_role";



GRANT ALL ON TABLE "public"."ai_classification_history" TO "anon";
GRANT ALL ON TABLE "public"."ai_classification_history" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_classification_history" TO "service_role";



GRANT ALL ON TABLE "public"."ai_classification_patterns" TO "anon";
GRANT ALL ON TABLE "public"."ai_classification_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_classification_patterns" TO "service_role";



GRANT ALL ON TABLE "public"."ai_executions" TO "anon";
GRANT ALL ON TABLE "public"."ai_executions" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_executions" TO "service_role";



GRANT ALL ON TABLE "public"."ai_known_entities" TO "anon";
GRANT ALL ON TABLE "public"."ai_known_entities" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_known_entities" TO "service_role";



GRANT ALL ON TABLE "public"."ai_labor_consultations" TO "anon";
GRANT ALL ON TABLE "public"."ai_labor_consultations" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_labor_consultations" TO "service_role";



GRANT ALL ON TABLE "public"."ai_learned_patterns" TO "anon";
GRANT ALL ON TABLE "public"."ai_learned_patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_learned_patterns" TO "service_role";



GRANT ALL ON TABLE "public"."ai_meetings" TO "anon";
GRANT ALL ON TABLE "public"."ai_meetings" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_meetings" TO "service_role";



GRANT ALL ON TABLE "public"."ai_page_agents" TO "anon";
GRANT ALL ON TABLE "public"."ai_page_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_page_agents" TO "service_role";



GRANT ALL ON TABLE "public"."ai_pending_questions" TO "anon";
GRANT ALL ON TABLE "public"."ai_pending_questions" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_pending_questions" TO "service_role";



GRANT ALL ON TABLE "public"."ai_presentations" TO "anon";
GRANT ALL ON TABLE "public"."ai_presentations" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_presentations" TO "service_role";



GRANT ALL ON TABLE "public"."ai_providers" TO "anon";
GRANT ALL ON TABLE "public"."ai_providers" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_providers" TO "service_role";



GRANT ALL ON TABLE "public"."ai_validation_queue" TO "anon";
GRANT ALL ON TABLE "public"."ai_validation_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_validation_queue" TO "service_role";



GRANT ALL ON TABLE "public"."audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."auditoria_achados" TO "anon";
GRANT ALL ON TABLE "public"."auditoria_achados" TO "authenticated";
GRANT ALL ON TABLE "public"."auditoria_achados" TO "service_role";



GRANT ALL ON TABLE "public"."auditoria_execucoes" TO "anon";
GRANT ALL ON TABLE "public"."auditoria_execucoes" TO "authenticated";
GRANT ALL ON TABLE "public"."auditoria_execucoes" TO "service_role";



GRANT ALL ON TABLE "public"."automation_logs" TO "anon";
GRANT ALL ON TABLE "public"."automation_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."automation_logs" TO "service_role";



GRANT ALL ON TABLE "public"."balance_sheet_lines" TO "anon";
GRANT ALL ON TABLE "public"."balance_sheet_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."balance_sheet_lines" TO "service_role";



GRANT ALL ON TABLE "public"."balance_sheets" TO "anon";
GRANT ALL ON TABLE "public"."balance_sheets" TO "authenticated";
GRANT ALL ON TABLE "public"."balance_sheets" TO "service_role";



GRANT ALL ON TABLE "public"."bank_accounts" TO "anon";
GRANT ALL ON TABLE "public"."bank_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."bank_balance" TO "anon";
GRANT ALL ON TABLE "public"."bank_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_balance" TO "service_role";



GRANT ALL ON TABLE "public"."bank_imports" TO "anon";
GRANT ALL ON TABLE "public"."bank_imports" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_imports" TO "service_role";



GRANT ALL ON TABLE "public"."bank_opening_balances" TO "anon";
GRANT ALL ON TABLE "public"."bank_opening_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_opening_balances" TO "service_role";



GRANT ALL ON TABLE "public"."bank_reconciliation" TO "anon";
GRANT ALL ON TABLE "public"."bank_reconciliation" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_reconciliation" TO "service_role";



GRANT ALL ON TABLE "public"."bank_statement_imports" TO "anon";
GRANT ALL ON TABLE "public"."bank_statement_imports" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_statement_imports" TO "service_role";



GRANT ALL ON TABLE "public"."bank_transaction_matches" TO "anon";
GRANT ALL ON TABLE "public"."bank_transaction_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_transaction_matches" TO "service_role";



GRANT ALL ON TABLE "public"."bank_transactions" TO "anon";
GRANT ALL ON TABLE "public"."bank_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."bank_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."banking_credentials" TO "anon";
GRANT ALL ON TABLE "public"."banking_credentials" TO "authenticated";
GRANT ALL ON TABLE "public"."banking_credentials" TO "service_role";



GRANT ALL ON TABLE "public"."barter_credits" TO "anon";
GRANT ALL ON TABLE "public"."barter_credits" TO "authenticated";
GRANT ALL ON TABLE "public"."barter_credits" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entries" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entries" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entry_items" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entry_items" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_accounting_entry_items" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_bank_transactions" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_bank_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_bank_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_chart_of_accounts" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_chart_of_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_chart_of_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_clients" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_clients" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_clients" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_invoices" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."bkp_20260106_suppliers" TO "anon";
GRANT ALL ON TABLE "public"."bkp_20260106_suppliers" TO "authenticated";
GRANT ALL ON TABLE "public"."bkp_20260106_suppliers" TO "service_role";



GRANT ALL ON TABLE "public"."boleto_payments" TO "anon";
GRANT ALL ON TABLE "public"."boleto_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."boleto_payments" TO "service_role";



GRANT ALL ON TABLE "public"."boleto_report_items" TO "anon";
GRANT ALL ON TABLE "public"."boleto_report_items" TO "authenticated";
GRANT ALL ON TABLE "public"."boleto_report_items" TO "service_role";



GRANT ALL ON TABLE "public"."boleto_reports" TO "anon";
GRANT ALL ON TABLE "public"."boleto_reports" TO "authenticated";
GRANT ALL ON TABLE "public"."boleto_reports" TO "service_role";



GRANT ALL ON TABLE "public"."business_maturity_analysis" TO "anon";
GRANT ALL ON TABLE "public"."business_maturity_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."business_maturity_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."cash_entries" TO "anon";
GRANT ALL ON TABLE "public"."cash_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."cash_entries" TO "service_role";



GRANT ALL ON TABLE "public"."cash_flow_projections" TO "anon";
GRANT ALL ON TABLE "public"."cash_flow_projections" TO "authenticated";
GRANT ALL ON TABLE "public"."cash_flow_projections" TO "service_role";



GRANT ALL ON TABLE "public"."cash_flow_transactions" TO "anon";
GRANT ALL ON TABLE "public"."cash_flow_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."cash_flow_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."classification_learning" TO "anon";
GRANT ALL ON TABLE "public"."classification_learning" TO "authenticated";
GRANT ALL ON TABLE "public"."classification_learning" TO "service_role";



GRANT ALL ON TABLE "public"."client_commission_agents" TO "anon";
GRANT ALL ON TABLE "public"."client_commission_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."client_commission_agents" TO "service_role";



GRANT ALL ON TABLE "public"."client_contacts" TO "anon";
GRANT ALL ON TABLE "public"."client_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."client_contacts" TO "service_role";



GRANT ALL ON TABLE "public"."client_contracts" TO "anon";
GRANT ALL ON TABLE "public"."client_contracts" TO "authenticated";
GRANT ALL ON TABLE "public"."client_contracts" TO "service_role";



GRANT ALL ON TABLE "public"."client_distracts" TO "anon";
GRANT ALL ON TABLE "public"."client_distracts" TO "authenticated";
GRANT ALL ON TABLE "public"."client_distracts" TO "service_role";



GRANT ALL ON TABLE "public"."client_enrichment" TO "anon";
GRANT ALL ON TABLE "public"."client_enrichment" TO "authenticated";
GRANT ALL ON TABLE "public"."client_enrichment" TO "service_role";



GRANT ALL ON TABLE "public"."client_ledger" TO "anon";
GRANT ALL ON TABLE "public"."client_ledger" TO "authenticated";
GRANT ALL ON TABLE "public"."client_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."client_monthly_revenue" TO "anon";
GRANT ALL ON TABLE "public"."client_monthly_revenue" TO "authenticated";
GRANT ALL ON TABLE "public"."client_monthly_revenue" TO "service_role";



GRANT ALL ON TABLE "public"."client_opening_balance" TO "anon";
GRANT ALL ON TABLE "public"."client_opening_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."client_opening_balance" TO "service_role";



GRANT ALL ON TABLE "public"."client_opening_balance_history" TO "anon";
GRANT ALL ON TABLE "public"."client_opening_balance_history" TO "authenticated";
GRANT ALL ON TABLE "public"."client_opening_balance_history" TO "service_role";



GRANT ALL ON TABLE "public"."client_partners" TO "anon";
GRANT ALL ON TABLE "public"."client_partners" TO "authenticated";
GRANT ALL ON TABLE "public"."client_partners" TO "service_role";



GRANT ALL ON TABLE "public"."client_partners_prospects" TO "anon";
GRANT ALL ON TABLE "public"."client_partners_prospects" TO "authenticated";
GRANT ALL ON TABLE "public"."client_partners_prospects" TO "service_role";



GRANT ALL ON TABLE "public"."client_payers" TO "anon";
GRANT ALL ON TABLE "public"."client_payers" TO "authenticated";
GRANT ALL ON TABLE "public"."client_payers" TO "service_role";



GRANT ALL ON TABLE "public"."client_referrals" TO "anon";
GRANT ALL ON TABLE "public"."client_referrals" TO "authenticated";
GRANT ALL ON TABLE "public"."client_referrals" TO "service_role";



GRANT ALL ON TABLE "public"."client_variable_fees" TO "anon";
GRANT ALL ON TABLE "public"."client_variable_fees" TO "authenticated";
GRANT ALL ON TABLE "public"."client_variable_fees" TO "service_role";



GRANT ALL ON TABLE "public"."codigos_servico_lc116" TO "anon";
GRANT ALL ON TABLE "public"."codigos_servico_lc116" TO "authenticated";
GRANT ALL ON TABLE "public"."codigos_servico_lc116" TO "service_role";



GRANT ALL ON SEQUENCE "public"."codigos_servico_lc116_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."codigos_servico_lc116_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."codigos_servico_lc116_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."collection_rules" TO "anon";
GRANT ALL ON TABLE "public"."collection_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."collection_rules" TO "service_role";



GRANT ALL ON TABLE "public"."collection_work_order_logs" TO "anon";
GRANT ALL ON TABLE "public"."collection_work_order_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."collection_work_order_logs" TO "service_role";



GRANT ALL ON TABLE "public"."collection_work_orders" TO "anon";
GRANT ALL ON TABLE "public"."collection_work_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."collection_work_orders" TO "service_role";



GRANT ALL ON TABLE "public"."commission_agents" TO "anon";
GRANT ALL ON TABLE "public"."commission_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."commission_agents" TO "service_role";



GRANT ALL ON TABLE "public"."company_partners" TO "anon";
GRANT ALL ON TABLE "public"."company_partners" TO "authenticated";
GRANT ALL ON TABLE "public"."company_partners" TO "service_role";



GRANT ALL ON TABLE "public"."company_profile" TO "anon";
GRANT ALL ON TABLE "public"."company_profile" TO "authenticated";
GRANT ALL ON TABLE "public"."company_profile" TO "service_role";



GRANT ALL ON TABLE "public"."company_service_costs" TO "anon";
GRANT ALL ON TABLE "public"."company_service_costs" TO "authenticated";
GRANT ALL ON TABLE "public"."company_service_costs" TO "service_role";



GRANT ALL ON TABLE "public"."company_services" TO "anon";
GRANT ALL ON TABLE "public"."company_services" TO "authenticated";
GRANT ALL ON TABLE "public"."company_services" TO "service_role";



GRANT ALL ON TABLE "public"."content_publish_queue" TO "anon";
GRANT ALL ON TABLE "public"."content_publish_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."content_publish_queue" TO "service_role";



GRANT ALL ON TABLE "public"."content_templates" TO "anon";
GRANT ALL ON TABLE "public"."content_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."content_templates" TO "service_role";



GRANT ALL ON TABLE "public"."contract_addendums" TO "anon";
GRANT ALL ON TABLE "public"."contract_addendums" TO "authenticated";
GRANT ALL ON TABLE "public"."contract_addendums" TO "service_role";



GRANT ALL ON SEQUENCE "public"."contract_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."contract_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."contract_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."contract_templates" TO "anon";
GRANT ALL ON TABLE "public"."contract_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."contract_templates" TO "service_role";



GRANT ALL ON TABLE "public"."contract_terminations" TO "anon";
GRANT ALL ON TABLE "public"."contract_terminations" TO "authenticated";
GRANT ALL ON TABLE "public"."contract_terminations" TO "service_role";



GRANT ALL ON TABLE "public"."contracts" TO "anon";
GRANT ALL ON TABLE "public"."contracts" TO "authenticated";
GRANT ALL ON TABLE "public"."contracts" TO "service_role";



GRANT ALL ON TABLE "public"."cost_center_accounts" TO "anon";
GRANT ALL ON TABLE "public"."cost_center_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."cost_center_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."cost_centers" TO "anon";
GRANT ALL ON TABLE "public"."cost_centers" TO "authenticated";
GRANT ALL ON TABLE "public"."cost_centers" TO "service_role";



GRANT ALL ON TABLE "public"."crm_clientes" TO "anon";
GRANT ALL ON TABLE "public"."crm_clientes" TO "authenticated";
GRANT ALL ON TABLE "public"."crm_clientes" TO "service_role";



GRANT ALL ON TABLE "public"."crm_interacoes" TO "anon";
GRANT ALL ON TABLE "public"."crm_interacoes" TO "authenticated";
GRANT ALL ON TABLE "public"."crm_interacoes" TO "service_role";



GRANT ALL ON TABLE "public"."crm_oportunidades" TO "anon";
GRANT ALL ON TABLE "public"."crm_oportunidades" TO "authenticated";
GRANT ALL ON TABLE "public"."crm_oportunidades" TO "service_role";



GRANT ALL ON TABLE "public"."crm_prospects" TO "anon";
GRANT ALL ON TABLE "public"."crm_prospects" TO "authenticated";
GRANT ALL ON TABLE "public"."crm_prospects" TO "service_role";



GRANT ALL ON TABLE "public"."crm_tarefas" TO "anon";
GRANT ALL ON TABLE "public"."crm_tarefas" TO "authenticated";
GRANT ALL ON TABLE "public"."crm_tarefas" TO "service_role";



GRANT ALL ON TABLE "public"."dashboard_widgets" TO "anon";
GRANT ALL ON TABLE "public"."dashboard_widgets" TO "authenticated";
GRANT ALL ON TABLE "public"."dashboard_widgets" TO "service_role";



GRANT ALL ON TABLE "public"."debt_confession_installments" TO "anon";
GRANT ALL ON TABLE "public"."debt_confession_installments" TO "authenticated";
GRANT ALL ON TABLE "public"."debt_confession_installments" TO "service_role";



GRANT ALL ON TABLE "public"."debt_confessions" TO "anon";
GRANT ALL ON TABLE "public"."debt_confessions" TO "authenticated";
GRANT ALL ON TABLE "public"."debt_confessions" TO "service_role";



GRANT ALL ON TABLE "public"."debt_negotiations" TO "anon";
GRANT ALL ON TABLE "public"."debt_negotiations" TO "authenticated";
GRANT ALL ON TABLE "public"."debt_negotiations" TO "service_role";



GRANT ALL ON TABLE "public"."discount_approval_rules" TO "anon";
GRANT ALL ON TABLE "public"."discount_approval_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."discount_approval_rules" TO "service_role";



GRANT ALL ON SEQUENCE "public"."distract_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."distract_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."distract_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."document_templates" TO "anon";
GRANT ALL ON TABLE "public"."document_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."document_templates" TO "service_role";



GRANT ALL ON TABLE "public"."documents" TO "anon";
GRANT ALL ON TABLE "public"."documents" TO "authenticated";
GRANT ALL ON TABLE "public"."documents" TO "service_role";



GRANT ALL ON TABLE "public"."domain_events" TO "anon";
GRANT ALL ON TABLE "public"."domain_events" TO "authenticated";
GRANT ALL ON TABLE "public"."domain_events" TO "service_role";



GRANT ALL ON TABLE "public"."dr_cicero_knowledge" TO "anon";
GRANT ALL ON TABLE "public"."dr_cicero_knowledge" TO "authenticated";
GRANT ALL ON TABLE "public"."dr_cicero_knowledge" TO "service_role";



GRANT ALL ON TABLE "public"."economic_group_members" TO "anon";
GRANT ALL ON TABLE "public"."economic_group_members" TO "authenticated";
GRANT ALL ON TABLE "public"."economic_group_members" TO "service_role";



GRANT ALL ON SEQUENCE "public"."economic_group_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."economic_group_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."economic_group_seq" TO "service_role";



GRANT ALL ON TABLE "public"."economic_groups" TO "anon";
GRANT ALL ON TABLE "public"."economic_groups" TO "authenticated";
GRANT ALL ON TABLE "public"."economic_groups" TO "service_role";



GRANT ALL ON TABLE "public"."employee_incentive_policies" TO "anon";
GRANT ALL ON TABLE "public"."employee_incentive_policies" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_incentive_policies" TO "service_role";



GRANT ALL ON TABLE "public"."employee_sales" TO "anon";
GRANT ALL ON TABLE "public"."employee_sales" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_sales" TO "service_role";



GRANT ALL ON TABLE "public"."employee_terminations" TO "anon";
GRANT ALL ON TABLE "public"."employee_terminations" TO "authenticated";
GRANT ALL ON TABLE "public"."employee_terminations" TO "service_role";



GRANT ALL ON TABLE "public"."employees" TO "anon";
GRANT ALL ON TABLE "public"."employees" TO "authenticated";
GRANT ALL ON TABLE "public"."employees" TO "service_role";



GRANT ALL ON TABLE "public"."empresas" TO "anon";
GRANT ALL ON TABLE "public"."empresas" TO "authenticated";
GRANT ALL ON TABLE "public"."empresas" TO "service_role";



GRANT ALL ON TABLE "public"."enrichment_logs" TO "anon";
GRANT ALL ON TABLE "public"."enrichment_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."enrichment_logs" TO "service_role";



GRANT ALL ON TABLE "public"."esocial_rubricas" TO "anon";
GRANT ALL ON TABLE "public"."esocial_rubricas" TO "authenticated";
GRANT ALL ON TABLE "public"."esocial_rubricas" TO "service_role";



GRANT ALL ON TABLE "public"."expense_categories" TO "anon";
GRANT ALL ON TABLE "public"."expense_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."expense_categories" TO "service_role";



GRANT ALL ON TABLE "public"."expenses" TO "anon";
GRANT ALL ON TABLE "public"."expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."expenses" TO "service_role";



GRANT ALL ON TABLE "public"."feature_analysis_history" TO "anon";
GRANT ALL ON TABLE "public"."feature_analysis_history" TO "authenticated";
GRANT ALL ON TABLE "public"."feature_analysis_history" TO "service_role";



GRANT ALL ON TABLE "public"."feature_requests" TO "anon";
GRANT ALL ON TABLE "public"."feature_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."feature_requests" TO "service_role";



GRANT ALL ON TABLE "public"."feature_templates" TO "anon";
GRANT ALL ON TABLE "public"."feature_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."feature_templates" TO "service_role";



GRANT ALL ON TABLE "public"."fee_adjustment_history" TO "anon";
GRANT ALL ON TABLE "public"."fee_adjustment_history" TO "authenticated";
GRANT ALL ON TABLE "public"."fee_adjustment_history" TO "service_role";



GRANT ALL ON TABLE "public"."file_processing_queue" TO "anon";
GRANT ALL ON TABLE "public"."file_processing_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."file_processing_queue" TO "service_role";



GRANT ALL ON TABLE "public"."financial_analysis" TO "anon";
GRANT ALL ON TABLE "public"."financial_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."financial_gap_solutions" TO "anon";
GRANT ALL ON TABLE "public"."financial_gap_solutions" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_gap_solutions" TO "service_role";



GRANT ALL ON TABLE "public"."fiscal_year_closings" TO "anon";
GRANT ALL ON TABLE "public"."fiscal_year_closings" TO "authenticated";
GRANT ALL ON TABLE "public"."fiscal_year_closings" TO "service_role";



GRANT ALL ON TABLE "public"."generated_content" TO "anon";
GRANT ALL ON TABLE "public"."generated_content" TO "authenticated";
GRANT ALL ON TABLE "public"."generated_content" TO "service_role";



GRANT ALL ON TABLE "public"."grupos_economicos" TO "anon";
GRANT ALL ON TABLE "public"."grupos_economicos" TO "authenticated";
GRANT ALL ON TABLE "public"."grupos_economicos" TO "service_role";



GRANT ALL ON TABLE "public"."holidays" TO "anon";
GRANT ALL ON TABLE "public"."holidays" TO "authenticated";
GRANT ALL ON TABLE "public"."holidays" TO "service_role";



GRANT ALL ON TABLE "public"."import_files" TO "anon";
GRANT ALL ON TABLE "public"."import_files" TO "authenticated";
GRANT ALL ON TABLE "public"."import_files" TO "service_role";



GRANT ALL ON TABLE "public"."initial_load_control" TO "anon";
GRANT ALL ON TABLE "public"."initial_load_control" TO "authenticated";
GRANT ALL ON TABLE "public"."initial_load_control" TO "service_role";



GRANT ALL ON TABLE "public"."intelligence_rules" TO "anon";
GRANT ALL ON TABLE "public"."intelligence_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."intelligence_rules" TO "service_role";



GRANT ALL ON TABLE "public"."inventory_movements" TO "anon";
GRANT ALL ON TABLE "public"."inventory_movements" TO "authenticated";
GRANT ALL ON TABLE "public"."inventory_movements" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_generation_rules" TO "anon";
GRANT ALL ON TABLE "public"."invoice_generation_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_generation_rules" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_status_audit" TO "anon";
GRANT ALL ON TABLE "public"."invoice_status_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_status_audit" TO "service_role";



GRANT ALL ON TABLE "public"."irpf_declarations" TO "anon";
GRANT ALL ON TABLE "public"."irpf_declarations" TO "authenticated";
GRANT ALL ON TABLE "public"."irpf_declarations" TO "service_role";



GRANT ALL ON SEQUENCE "public"."journal_entries_entry_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."journal_entries_entry_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."journal_entries_entry_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."labor_alerts" TO "anon";
GRANT ALL ON TABLE "public"."labor_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."labor_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."labor_jurisprudence" TO "anon";
GRANT ALL ON TABLE "public"."labor_jurisprudence" TO "authenticated";
GRANT ALL ON TABLE "public"."labor_jurisprudence" TO "service_role";



GRANT ALL ON TABLE "public"."labor_legislation" TO "anon";
GRANT ALL ON TABLE "public"."labor_legislation" TO "authenticated";
GRANT ALL ON TABLE "public"."labor_legislation" TO "service_role";



GRANT ALL ON TABLE "public"."labor_solution_strategies" TO "anon";
GRANT ALL ON TABLE "public"."labor_solution_strategies" TO "authenticated";
GRANT ALL ON TABLE "public"."labor_solution_strategies" TO "service_role";



GRANT ALL ON TABLE "public"."logs_erros" TO "anon";
GRANT ALL ON TABLE "public"."logs_erros" TO "authenticated";
GRANT ALL ON TABLE "public"."logs_erros" TO "service_role";



GRANT ALL ON TABLE "public"."logs_sincronizacao" TO "anon";
GRANT ALL ON TABLE "public"."logs_sincronizacao" TO "authenticated";
GRANT ALL ON TABLE "public"."logs_sincronizacao" TO "service_role";



GRANT ALL ON TABLE "public"."marketing_videos" TO "anon";
GRANT ALL ON TABLE "public"."marketing_videos" TO "authenticated";
GRANT ALL ON TABLE "public"."marketing_videos" TO "service_role";



GRANT ALL ON TABLE "public"."materialized_view_refresh_log" TO "anon";
GRANT ALL ON TABLE "public"."materialized_view_refresh_log" TO "authenticated";
GRANT ALL ON TABLE "public"."materialized_view_refresh_log" TO "service_role";



GRANT ALL ON TABLE "public"."meeting_default_participants" TO "anon";
GRANT ALL ON TABLE "public"."meeting_default_participants" TO "authenticated";
GRANT ALL ON TABLE "public"."meeting_default_participants" TO "service_role";



GRANT ALL ON TABLE "public"."message_templates" TO "anon";
GRANT ALL ON TABLE "public"."message_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."message_templates" TO "service_role";



GRANT ALL ON TABLE "public"."metrics_snapshots" TO "anon";
GRANT ALL ON TABLE "public"."metrics_snapshots" TO "authenticated";
GRANT ALL ON TABLE "public"."metrics_snapshots" TO "service_role";



GRANT ALL ON TABLE "public"."minimum_wage_history" TO "anon";
GRANT ALL ON TABLE "public"."minimum_wage_history" TO "authenticated";
GRANT ALL ON TABLE "public"."minimum_wage_history" TO "service_role";



GRANT ALL ON TABLE "public"."monthly_closings" TO "anon";
GRANT ALL ON TABLE "public"."monthly_closings" TO "authenticated";
GRANT ALL ON TABLE "public"."monthly_closings" TO "service_role";



GRANT ALL ON TABLE "public"."mv_cash_flow" TO "service_role";



GRANT ALL ON TABLE "public"."mv_client_balances" TO "anon";
GRANT ALL ON TABLE "public"."mv_client_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."mv_client_balances" TO "service_role";



GRANT ALL ON TABLE "public"."mv_coa_balances" TO "service_role";



GRANT ALL ON TABLE "public"."mv_dashboard_kpis" TO "service_role";



GRANT ALL ON TABLE "public"."mv_default_summary" TO "anon";
GRANT ALL ON TABLE "public"."mv_default_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."mv_default_summary" TO "service_role";



GRANT ALL ON TABLE "public"."mv_dre_monthly" TO "service_role";



GRANT ALL ON TABLE "public"."mv_trial_balance" TO "service_role";



GRANT ALL ON TABLE "public"."negotiation_contact_history" TO "anon";
GRANT ALL ON TABLE "public"."negotiation_contact_history" TO "authenticated";
GRANT ALL ON TABLE "public"."negotiation_contact_history" TO "service_role";



GRANT ALL ON TABLE "public"."negotiation_installments" TO "anon";
GRANT ALL ON TABLE "public"."negotiation_installments" TO "authenticated";
GRANT ALL ON TABLE "public"."negotiation_installments" TO "service_role";



GRANT ALL ON SEQUENCE "public"."negotiation_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."negotiation_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."negotiation_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."nfse" TO "anon";
GRANT ALL ON TABLE "public"."nfse" TO "authenticated";
GRANT ALL ON TABLE "public"."nfse" TO "service_role";



GRANT ALL ON TABLE "public"."nfse_config" TO "anon";
GRANT ALL ON TABLE "public"."nfse_config" TO "authenticated";
GRANT ALL ON TABLE "public"."nfse_config" TO "service_role";



GRANT ALL ON TABLE "public"."nfse_log" TO "anon";
GRANT ALL ON TABLE "public"."nfse_log" TO "authenticated";
GRANT ALL ON TABLE "public"."nfse_log" TO "service_role";



GRANT ALL ON TABLE "public"."nfse_tomadas" TO "anon";
GRANT ALL ON TABLE "public"."nfse_tomadas" TO "authenticated";
GRANT ALL ON TABLE "public"."nfse_tomadas" TO "service_role";



GRANT ALL ON TABLE "public"."notifications_log" TO "anon";
GRANT ALL ON TABLE "public"."notifications_log" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications_log" TO "service_role";



GRANT ALL ON TABLE "public"."office_products" TO "anon";
GRANT ALL ON TABLE "public"."office_products" TO "authenticated";
GRANT ALL ON TABLE "public"."office_products" TO "service_role";



GRANT ALL ON TABLE "public"."office_recurring_expenses" TO "anon";
GRANT ALL ON TABLE "public"."office_recurring_expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."office_recurring_expenses" TO "service_role";



GRANT ALL ON TABLE "public"."office_settings" TO "anon";
GRANT ALL ON TABLE "public"."office_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."office_settings" TO "service_role";



GRANT ALL ON TABLE "public"."organization_users" TO "anon";
GRANT ALL ON TABLE "public"."organization_users" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_users" TO "service_role";



GRANT ALL ON TABLE "public"."organizations" TO "anon";
GRANT ALL ON TABLE "public"."organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."organizations" TO "service_role";



GRANT ALL ON TABLE "public"."parametros_folha" TO "anon";
GRANT ALL ON TABLE "public"."parametros_folha" TO "authenticated";
GRANT ALL ON TABLE "public"."parametros_folha" TO "service_role";



GRANT ALL ON TABLE "public"."partner_family" TO "anon";
GRANT ALL ON TABLE "public"."partner_family" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_family" TO "service_role";



GRANT ALL ON TABLE "public"."partner_properties" TO "anon";
GRANT ALL ON TABLE "public"."partner_properties" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_properties" TO "service_role";



GRANT ALL ON TABLE "public"."partner_vehicles" TO "anon";
GRANT ALL ON TABLE "public"."partner_vehicles" TO "authenticated";
GRANT ALL ON TABLE "public"."partner_vehicles" TO "service_role";



GRANT ALL ON TABLE "public"."partners" TO "anon";
GRANT ALL ON TABLE "public"."partners" TO "authenticated";
GRANT ALL ON TABLE "public"."partners" TO "service_role";



GRANT ALL ON TABLE "public"."payroll" TO "anon";
GRANT ALL ON TABLE "public"."payroll" TO "authenticated";
GRANT ALL ON TABLE "public"."payroll" TO "service_role";



GRANT ALL ON TABLE "public"."payroll_details" TO "anon";
GRANT ALL ON TABLE "public"."payroll_details" TO "authenticated";
GRANT ALL ON TABLE "public"."payroll_details" TO "service_role";



GRANT ALL ON TABLE "public"."payroll_events" TO "anon";
GRANT ALL ON TABLE "public"."payroll_events" TO "authenticated";
GRANT ALL ON TABLE "public"."payroll_events" TO "service_role";



GRANT ALL ON TABLE "public"."payroll_journal_entries" TO "anon";
GRANT ALL ON TABLE "public"."payroll_journal_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."payroll_journal_entries" TO "service_role";



GRANT ALL ON TABLE "public"."payroll_payments" TO "anon";
GRANT ALL ON TABLE "public"."payroll_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."payroll_payments" TO "service_role";



GRANT ALL ON TABLE "public"."payrolls" TO "anon";
GRANT ALL ON TABLE "public"."payrolls" TO "authenticated";
GRANT ALL ON TABLE "public"."payrolls" TO "service_role";



GRANT ALL ON TABLE "public"."pending_reconciliations" TO "anon";
GRANT ALL ON TABLE "public"."pending_reconciliations" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_reconciliations" TO "service_role";



GRANT ALL ON TABLE "public"."perdcomp_pedidos" TO "anon";
GRANT ALL ON TABLE "public"."perdcomp_pedidos" TO "authenticated";
GRANT ALL ON TABLE "public"."perdcomp_pedidos" TO "service_role";



GRANT ALL ON TABLE "public"."period_close_history" TO "anon";
GRANT ALL ON TABLE "public"."period_close_history" TO "authenticated";
GRANT ALL ON TABLE "public"."period_close_history" TO "service_role";



GRANT ALL ON TABLE "public"."period_reopen_requests" TO "anon";
GRANT ALL ON TABLE "public"."period_reopen_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."period_reopen_requests" TO "service_role";



GRANT ALL ON TABLE "public"."plr_criteria" TO "anon";
GRANT ALL ON TABLE "public"."plr_criteria" TO "authenticated";
GRANT ALL ON TABLE "public"."plr_criteria" TO "service_role";



GRANT ALL ON TABLE "public"."plr_employee_share" TO "anon";
GRANT ALL ON TABLE "public"."plr_employee_share" TO "authenticated";
GRANT ALL ON TABLE "public"."plr_employee_share" TO "service_role";



GRANT ALL ON TABLE "public"."plr_programs" TO "anon";
GRANT ALL ON TABLE "public"."plr_programs" TO "authenticated";
GRANT ALL ON TABLE "public"."plr_programs" TO "service_role";



GRANT ALL ON TABLE "public"."product_consumption" TO "anon";
GRANT ALL ON TABLE "public"."product_consumption" TO "authenticated";
GRANT ALL ON TABLE "public"."product_consumption" TO "service_role";



GRANT ALL ON TABLE "public"."product_purchases" TO "anon";
GRANT ALL ON TABLE "public"."product_purchases" TO "authenticated";
GRANT ALL ON TABLE "public"."product_purchases" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."program_prerequisites" TO "anon";
GRANT ALL ON TABLE "public"."program_prerequisites" TO "authenticated";
GRANT ALL ON TABLE "public"."program_prerequisites" TO "service_role";



GRANT ALL ON TABLE "public"."proposals" TO "anon";
GRANT ALL ON TABLE "public"."proposals" TO "authenticated";
GRANT ALL ON TABLE "public"."proposals" TO "service_role";



GRANT ALL ON TABLE "public"."provider_invoices" TO "anon";
GRANT ALL ON TABLE "public"."provider_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."provider_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_list_items" TO "anon";
GRANT ALL ON TABLE "public"."purchase_list_items" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_list_items" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_lists" TO "anon";
GRANT ALL ON TABLE "public"."purchase_lists" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_lists" TO "service_role";



GRANT ALL ON SEQUENCE "public"."purchase_lists_list_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."purchase_lists_list_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."purchase_lists_list_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."reconciliation_rules" TO "anon";
GRANT ALL ON TABLE "public"."reconciliation_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."reconciliation_rules" TO "service_role";



GRANT ALL ON TABLE "public"."recurring_expense_templates" TO "anon";
GRANT ALL ON TABLE "public"."recurring_expense_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."recurring_expense_templates" TO "service_role";



GRANT ALL ON TABLE "public"."recurring_expenses" TO "anon";
GRANT ALL ON TABLE "public"."recurring_expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."recurring_expenses" TO "service_role";



GRANT ALL ON TABLE "public"."recurring_payments" TO "anon";
GRANT ALL ON TABLE "public"."recurring_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."recurring_payments" TO "service_role";



GRANT ALL ON TABLE "public"."referral_commission_payments" TO "anon";
GRANT ALL ON TABLE "public"."referral_commission_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_commission_payments" TO "service_role";



GRANT ALL ON TABLE "public"."referral_partners" TO "anon";
GRANT ALL ON TABLE "public"."referral_partners" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_partners" TO "service_role";



GRANT ALL ON TABLE "public"."referral_policy" TO "anon";
GRANT ALL ON TABLE "public"."referral_policy" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_policy" TO "service_role";



GRANT ALL ON TABLE "public"."referral_program" TO "anon";
GRANT ALL ON TABLE "public"."referral_program" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_program" TO "service_role";



GRANT ALL ON TABLE "public"."responsibility_letters" TO "anon";
GRANT ALL ON TABLE "public"."responsibility_letters" TO "authenticated";
GRANT ALL ON TABLE "public"."responsibility_letters" TO "service_role";



GRANT ALL ON TABLE "public"."retencoes_tributarias" TO "anon";
GRANT ALL ON TABLE "public"."retencoes_tributarias" TO "authenticated";
GRANT ALL ON TABLE "public"."retencoes_tributarias" TO "service_role";



GRANT ALL ON TABLE "public"."revenue_categories" TO "anon";
GRANT ALL ON TABLE "public"."revenue_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."revenue_categories" TO "service_role";



GRANT ALL ON TABLE "public"."revenue_types" TO "anon";
GRANT ALL ON TABLE "public"."revenue_types" TO "authenticated";
GRANT ALL ON TABLE "public"."revenue_types" TO "service_role";



GRANT ALL ON TABLE "public"."risk_solution_mapping" TO "anon";
GRANT ALL ON TABLE "public"."risk_solution_mapping" TO "authenticated";
GRANT ALL ON TABLE "public"."risk_solution_mapping" TO "service_role";



GRANT ALL ON TABLE "public"."roles" TO "anon";
GRANT ALL ON TABLE "public"."roles" TO "authenticated";
GRANT ALL ON TABLE "public"."roles" TO "service_role";



GRANT ALL ON TABLE "public"."sales_training_modules" TO "anon";
GRANT ALL ON TABLE "public"."sales_training_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."sales_training_modules" TO "service_role";



GRANT ALL ON TABLE "public"."sales_training_records" TO "anon";
GRANT ALL ON TABLE "public"."sales_training_records" TO "authenticated";
GRANT ALL ON TABLE "public"."sales_training_records" TO "service_role";



GRANT ALL ON TABLE "public"."serpro_caixa_postal" TO "anon";
GRANT ALL ON TABLE "public"."serpro_caixa_postal" TO "authenticated";
GRANT ALL ON TABLE "public"."serpro_caixa_postal" TO "service_role";



GRANT ALL ON TABLE "public"."service_proposals" TO "anon";
GRANT ALL ON TABLE "public"."service_proposals" TO "authenticated";
GRANT ALL ON TABLE "public"."service_proposals" TO "service_role";



GRANT ALL ON TABLE "public"."service_providers" TO "anon";
GRANT ALL ON TABLE "public"."service_providers" TO "authenticated";
GRANT ALL ON TABLE "public"."service_providers" TO "service_role";



GRANT ALL ON TABLE "public"."solution_templates" TO "anon";
GRANT ALL ON TABLE "public"."solution_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."solution_templates" TO "service_role";



GRANT ALL ON TABLE "public"."sora_generation_queue" TO "anon";
GRANT ALL ON TABLE "public"."sora_generation_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."sora_generation_queue" TO "service_role";



GRANT ALL ON TABLE "public"."sora_video_projects" TO "anon";
GRANT ALL ON TABLE "public"."sora_video_projects" TO "authenticated";
GRANT ALL ON TABLE "public"."sora_video_projects" TO "service_role";



GRANT ALL ON TABLE "public"."sora_video_templates" TO "anon";
GRANT ALL ON TABLE "public"."sora_video_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."sora_video_templates" TO "service_role";



GRANT ALL ON TABLE "public"."stored_documents" TO "anon";
GRANT ALL ON TABLE "public"."stored_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."stored_documents" TO "service_role";



GRANT ALL ON TABLE "public"."suppliers" TO "anon";
GRANT ALL ON TABLE "public"."suppliers" TO "authenticated";
GRANT ALL ON TABLE "public"."suppliers" TO "service_role";



GRANT ALL ON TABLE "public"."system_users" TO "anon";
GRANT ALL ON TABLE "public"."system_users" TO "authenticated";
GRANT ALL ON TABLE "public"."system_users" TO "service_role";



GRANT ALL ON TABLE "public"."tabela_inss" TO "anon";
GRANT ALL ON TABLE "public"."tabela_inss" TO "authenticated";
GRANT ALL ON TABLE "public"."tabela_inss" TO "service_role";



GRANT ALL ON TABLE "public"."tabela_irrf" TO "anon";
GRANT ALL ON TABLE "public"."tabela_irrf" TO "authenticated";
GRANT ALL ON TABLE "public"."tabela_irrf" TO "service_role";



GRANT ALL ON TABLE "public"."tax_configurations" TO "anon";
GRANT ALL ON TABLE "public"."tax_configurations" TO "authenticated";
GRANT ALL ON TABLE "public"."tax_configurations" TO "service_role";



GRANT ALL ON TABLE "public"."tax_installments" TO "anon";
GRANT ALL ON TABLE "public"."tax_installments" TO "authenticated";
GRANT ALL ON TABLE "public"."tax_installments" TO "service_role";



GRANT ALL ON TABLE "public"."tax_obligations" TO "anon";
GRANT ALL ON TABLE "public"."tax_obligations" TO "authenticated";
GRANT ALL ON TABLE "public"."tax_obligations" TO "service_role";



GRANT ALL ON TABLE "public"."tenant_features" TO "anon";
GRANT ALL ON TABLE "public"."tenant_features" TO "authenticated";
GRANT ALL ON TABLE "public"."tenant_features" TO "service_role";



GRANT ALL ON TABLE "public"."tenant_users" TO "anon";
GRANT ALL ON TABLE "public"."tenant_users" TO "authenticated";
GRANT ALL ON TABLE "public"."tenant_users" TO "service_role";



GRANT ALL ON TABLE "public"."tenants" TO "anon";
GRANT ALL ON TABLE "public"."tenants" TO "authenticated";
GRANT ALL ON TABLE "public"."tenants" TO "service_role";



GRANT ALL ON TABLE "public"."trial_balance_lines" TO "anon";
GRANT ALL ON TABLE "public"."trial_balance_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."trial_balance_lines" TO "service_role";



GRANT ALL ON TABLE "public"."trial_balances" TO "anon";
GRANT ALL ON TABLE "public"."trial_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."trial_balances" TO "service_role";



GRANT ALL ON TABLE "public"."tv_playlist" TO "anon";
GRANT ALL ON TABLE "public"."tv_playlist" TO "authenticated";
GRANT ALL ON TABLE "public"."tv_playlist" TO "service_role";



GRANT ALL ON TABLE "public"."tv_video_playlist" TO "anon";
GRANT ALL ON TABLE "public"."tv_video_playlist" TO "authenticated";
GRANT ALL ON TABLE "public"."tv_video_playlist" TO "service_role";



GRANT ALL ON TABLE "public"."user_office_access" TO "anon";
GRANT ALL ON TABLE "public"."user_office_access" TO "authenticated";
GRANT ALL ON TABLE "public"."user_office_access" TO "service_role";



GRANT ALL ON TABLE "public"."user_roles" TO "anon";
GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_roles" TO "service_role";



GRANT ALL ON TABLE "public"."v_account_ledger" TO "anon";
GRANT ALL ON TABLE "public"."v_account_ledger" TO "authenticated";
GRANT ALL ON TABLE "public"."v_account_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."v_accounting_entries_with_source" TO "anon";
GRANT ALL ON TABLE "public"."v_accounting_entries_with_source" TO "authenticated";
GRANT ALL ON TABLE "public"."v_accounting_entries_with_source" TO "service_role";



GRANT ALL ON TABLE "public"."v_accounts_receivable" TO "anon";
GRANT ALL ON TABLE "public"."v_accounts_receivable" TO "authenticated";
GRANT ALL ON TABLE "public"."v_accounts_receivable" TO "service_role";



GRANT ALL ON TABLE "public"."v_balancete" TO "anon";
GRANT ALL ON TABLE "public"."v_balancete" TO "authenticated";
GRANT ALL ON TABLE "public"."v_balancete" TO "service_role";



GRANT ALL ON TABLE "public"."v_adiantamentos_socios" TO "anon";
GRANT ALL ON TABLE "public"."v_adiantamentos_socios" TO "authenticated";
GRANT ALL ON TABLE "public"."v_adiantamentos_socios" TO "service_role";



GRANT ALL ON TABLE "public"."v_ai_validation_stats" TO "anon";
GRANT ALL ON TABLE "public"."v_ai_validation_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."v_ai_validation_stats" TO "service_role";



GRANT ALL ON TABLE "public"."v_analise_cobranca" TO "anon";
GRANT ALL ON TABLE "public"."v_analise_cobranca" TO "authenticated";
GRANT ALL ON TABLE "public"."v_analise_cobranca" TO "service_role";



GRANT ALL ON TABLE "public"."v_balanco_patrimonial" TO "anon";
GRANT ALL ON TABLE "public"."v_balanco_patrimonial" TO "authenticated";
GRANT ALL ON TABLE "public"."v_balanco_patrimonial" TO "service_role";



GRANT ALL ON TABLE "public"."v_bank_balance_by_period" TO "anon";
GRANT ALL ON TABLE "public"."v_bank_balance_by_period" TO "authenticated";
GRANT ALL ON TABLE "public"."v_bank_balance_by_period" TO "service_role";



GRANT ALL ON TABLE "public"."v_bank_balance_from_entries" TO "anon";
GRANT ALL ON TABLE "public"."v_bank_balance_from_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."v_bank_balance_from_entries" TO "service_role";



GRANT ALL ON TABLE "public"."v_projections_contractors" TO "anon";
GRANT ALL ON TABLE "public"."v_projections_contractors" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projections_contractors" TO "service_role";



GRANT ALL ON TABLE "public"."v_projections_custom" TO "anon";
GRANT ALL ON TABLE "public"."v_projections_custom" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projections_custom" TO "service_role";



GRANT ALL ON TABLE "public"."v_projections_payroll" TO "anon";
GRANT ALL ON TABLE "public"."v_projections_payroll" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projections_payroll" TO "service_role";



GRANT ALL ON TABLE "public"."v_projections_recurring" TO "anon";
GRANT ALL ON TABLE "public"."v_projections_recurring" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projections_recurring" TO "service_role";



GRANT ALL ON TABLE "public"."v_projections_taxes" TO "anon";
GRANT ALL ON TABLE "public"."v_projections_taxes" TO "authenticated";
GRANT ALL ON TABLE "public"."v_projections_taxes" TO "service_role";



GRANT ALL ON TABLE "public"."v_cash_flow_daily" TO "anon";
GRANT ALL ON TABLE "public"."v_cash_flow_daily" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cash_flow_daily" TO "service_role";



GRANT ALL ON TABLE "public"."v_cash_flow_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_cash_flow_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cash_flow_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_client_classification_check" TO "anon";
GRANT ALL ON TABLE "public"."v_client_classification_check" TO "authenticated";
GRANT ALL ON TABLE "public"."v_client_classification_check" TO "service_role";



GRANT ALL ON TABLE "public"."v_client_opening_balance_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_client_opening_balance_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_client_opening_balance_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_clients_for_negotiation" TO "anon";
GRANT ALL ON TABLE "public"."v_clients_for_negotiation" TO "authenticated";
GRANT ALL ON TABLE "public"."v_clients_for_negotiation" TO "service_role";



GRANT ALL ON TABLE "public"."v_clients_pending_adjustment" TO "anon";
GRANT ALL ON TABLE "public"."v_clients_pending_adjustment" TO "authenticated";
GRANT ALL ON TABLE "public"."v_clients_pending_adjustment" TO "service_role";



GRANT ALL ON TABLE "public"."v_contas_a_receber" TO "anon";
GRANT ALL ON TABLE "public"."v_contas_a_receber" TO "authenticated";
GRANT ALL ON TABLE "public"."v_contas_a_receber" TO "service_role";



GRANT ALL ON TABLE "public"."v_contracts_complete" TO "anon";
GRANT ALL ON TABLE "public"."v_contracts_complete" TO "authenticated";
GRANT ALL ON TABLE "public"."v_contracts_complete" TO "service_role";



GRANT ALL ON TABLE "public"."v_debt_confessions_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_debt_confessions_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_debt_confessions_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_despesas" TO "anon";
GRANT ALL ON TABLE "public"."v_despesas" TO "authenticated";
GRANT ALL ON TABLE "public"."v_despesas" TO "service_role";



GRANT ALL ON TABLE "public"."v_dre_mensal" TO "anon";
GRANT ALL ON TABLE "public"."v_dre_mensal" TO "authenticated";
GRANT ALL ON TABLE "public"."v_dre_mensal" TO "service_role";



GRANT ALL ON TABLE "public"."v_dre_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_dre_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_dre_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_honorarios_por_cliente_ano" TO "anon";
GRANT ALL ON TABLE "public"."v_honorarios_por_cliente_ano" TO "authenticated";
GRANT ALL ON TABLE "public"."v_honorarios_por_cliente_ano" TO "service_role";



GRANT ALL ON TABLE "public"."v_invoices_with_13th" TO "anon";
GRANT ALL ON TABLE "public"."v_invoices_with_13th" TO "authenticated";
GRANT ALL ON TABLE "public"."v_invoices_with_13th" TO "service_role";



GRANT ALL ON TABLE "public"."v_minimum_wage_history" TO "anon";
GRANT ALL ON TABLE "public"."v_minimum_wage_history" TO "authenticated";
GRANT ALL ON TABLE "public"."v_minimum_wage_history" TO "service_role";



GRANT ALL ON TABLE "public"."v_payroll_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_payroll_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_payroll_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_pending_responsibility_letters" TO "anon";
GRANT ALL ON TABLE "public"."v_pending_responsibility_letters" TO "authenticated";
GRANT ALL ON TABLE "public"."v_pending_responsibility_letters" TO "service_role";



GRANT ALL ON TABLE "public"."v_receitas" TO "anon";
GRANT ALL ON TABLE "public"."v_receitas" TO "authenticated";
GRANT ALL ON TABLE "public"."v_receitas" TO "service_role";



GRANT ALL ON TABLE "public"."v_rentabilidade_cliente" TO "anon";
GRANT ALL ON TABLE "public"."v_rentabilidade_cliente" TO "authenticated";
GRANT ALL ON TABLE "public"."v_rentabilidade_cliente" TO "service_role";



GRANT ALL ON TABLE "public"."v_saldo_banco" TO "anon";
GRANT ALL ON TABLE "public"."v_saldo_banco" TO "authenticated";
GRANT ALL ON TABLE "public"."v_saldo_banco" TO "service_role";



GRANT ALL ON TABLE "public"."v_tracking_summary" TO "anon";
GRANT ALL ON TABLE "public"."v_tracking_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."v_tracking_summary" TO "service_role";



GRANT ALL ON TABLE "public"."v_trial_balance" TO "anon";
GRANT ALL ON TABLE "public"."v_trial_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."v_trial_balance" TO "service_role";



GRANT ALL ON TABLE "public"."variable_fee_calculations" TO "anon";
GRANT ALL ON TABLE "public"."variable_fee_calculations" TO "authenticated";
GRANT ALL ON TABLE "public"."variable_fee_calculations" TO "service_role";



GRANT ALL ON TABLE "public"."video_branding_config" TO "anon";
GRANT ALL ON TABLE "public"."video_branding_config" TO "authenticated";
GRANT ALL ON TABLE "public"."video_branding_config" TO "service_role";



GRANT ALL ON TABLE "public"."vw_all_labor_alerts" TO "anon";
GRANT ALL ON TABLE "public"."vw_all_labor_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_all_labor_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."vw_agent_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."vw_agent_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_agent_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."vw_ai_company_context" TO "anon";
GRANT ALL ON TABLE "public"."vw_ai_company_context" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_ai_company_context" TO "service_role";



GRANT ALL ON TABLE "public"."vw_labor_risks_with_solutions" TO "anon";
GRANT ALL ON TABLE "public"."vw_labor_risks_with_solutions" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_labor_risks_with_solutions" TO "service_role";



GRANT ALL ON TABLE "public"."vw_person_labor_analysis" TO "anon";
GRANT ALL ON TABLE "public"."vw_person_labor_analysis" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_person_labor_analysis" TO "service_role";



GRANT ALL ON TABLE "public"."vw_ai_labor_context" TO "anon";
GRANT ALL ON TABLE "public"."vw_ai_labor_context" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_ai_labor_context" TO "service_role";



GRANT ALL ON TABLE "public"."vw_balancete" TO "anon";
GRANT ALL ON TABLE "public"."vw_balancete" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_balancete" TO "service_role";



GRANT ALL ON TABLE "public"."vw_business_maturity_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_business_maturity_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_business_maturity_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_clients_variable_fees" TO "anon";
GRANT ALL ON TABLE "public"."vw_clients_variable_fees" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_clients_variable_fees" TO "service_role";



GRANT ALL ON TABLE "public"."vw_content_metrics" TO "anon";
GRANT ALL ON TABLE "public"."vw_content_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_content_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."vw_content_to_publish" TO "anon";
GRANT ALL ON TABLE "public"."vw_content_to_publish" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_content_to_publish" TO "service_role";



GRANT ALL ON TABLE "public"."vw_cost_center_with_accounts" TO "anon";
GRANT ALL ON TABLE "public"."vw_cost_center_with_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_cost_center_with_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."vw_costs_by_department" TO "anon";
GRANT ALL ON TABLE "public"."vw_costs_by_department" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_costs_by_department" TO "service_role";



GRANT ALL ON TABLE "public"."vw_economic_group_members" TO "anon";
GRANT ALL ON TABLE "public"."vw_economic_group_members" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_economic_group_members" TO "service_role";



GRANT ALL ON TABLE "public"."vw_economic_groups_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_economic_groups_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_economic_groups_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_employee_sales_ranking" TO "anon";
GRANT ALL ON TABLE "public"."vw_employee_sales_ranking" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_employee_sales_ranking" TO "service_role";



GRANT ALL ON TABLE "public"."vw_evolution_metrics" TO "anon";
GRANT ALL ON TABLE "public"."vw_evolution_metrics" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_evolution_metrics" TO "service_role";



GRANT ALL ON TABLE "public"."vw_expenses_by_cost_center" TO "anon";
GRANT ALL ON TABLE "public"."vw_expenses_by_cost_center" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_expenses_by_cost_center" TO "service_role";



GRANT ALL ON TABLE "public"."vw_expenses_with_accounts" TO "anon";
GRANT ALL ON TABLE "public"."vw_expenses_with_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_expenses_with_accounts" TO "service_role";



GRANT ALL ON TABLE "public"."vw_growth_opportunities" TO "anon";
GRANT ALL ON TABLE "public"."vw_growth_opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_growth_opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."vw_irpf_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_irpf_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_irpf_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_jurisprudence_by_risk" TO "anon";
GRANT ALL ON TABLE "public"."vw_jurisprudence_by_risk" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_jurisprudence_by_risk" TO "service_role";



GRANT ALL ON TABLE "public"."vw_labor_risk_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_labor_risk_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_labor_risk_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_livro_diario" TO "anon";
GRANT ALL ON TABLE "public"."vw_livro_diario" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_livro_diario" TO "service_role";



GRANT ALL ON TABLE "public"."vw_livro_razao" TO "anon";
GRANT ALL ON TABLE "public"."vw_livro_razao" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_livro_razao" TO "service_role";



GRANT ALL ON TABLE "public"."vw_low_stock_products" TO "anon";
GRANT ALL ON TABLE "public"."vw_low_stock_products" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_low_stock_products" TO "service_role";



GRANT ALL ON TABLE "public"."vw_nfse_tomadas_detalhada" TO "anon";
GRANT ALL ON TABLE "public"."vw_nfse_tomadas_detalhada" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_nfse_tomadas_detalhada" TO "service_role";



GRANT ALL ON TABLE "public"."vw_partner_advances_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_partner_advances_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_partner_advances_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_partner_groups" TO "anon";
GRANT ALL ON TABLE "public"."vw_partner_groups" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_partner_groups" TO "service_role";



GRANT ALL ON TABLE "public"."vw_payroll_events_detailed" TO "anon";
GRANT ALL ON TABLE "public"."vw_payroll_events_detailed" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_payroll_events_detailed" TO "service_role";



GRANT ALL ON TABLE "public"."vw_payroll_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_payroll_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_payroll_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_pending_classification" TO "anon";
GRANT ALL ON TABLE "public"."vw_pending_classification" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_pending_classification" TO "service_role";



GRANT ALL ON TABLE "public"."vw_pending_commissions" TO "anon";
GRANT ALL ON TABLE "public"."vw_pending_commissions" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_pending_commissions" TO "service_role";



GRANT ALL ON TABLE "public"."vw_pending_feature_requests" TO "anon";
GRANT ALL ON TABLE "public"."vw_pending_feature_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_pending_feature_requests" TO "service_role";



GRANT ALL ON TABLE "public"."vw_plr_by_employee" TO "anon";
GRANT ALL ON TABLE "public"."vw_plr_by_employee" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_plr_by_employee" TO "service_role";



GRANT ALL ON TABLE "public"."vw_plr_summary" TO "anon";
GRANT ALL ON TABLE "public"."vw_plr_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_plr_summary" TO "service_role";



GRANT ALL ON TABLE "public"."vw_product_price_history" TO "anon";
GRANT ALL ON TABLE "public"."vw_product_price_history" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_product_price_history" TO "service_role";



GRANT ALL ON TABLE "public"."vw_program_readiness" TO "anon";
GRANT ALL ON TABLE "public"."vw_program_readiness" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_program_readiness" TO "service_role";



GRANT ALL ON TABLE "public"."vw_provider_compliance" TO "anon";
GRANT ALL ON TABLE "public"."vw_provider_compliance" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_provider_compliance" TO "service_role";



GRANT ALL ON TABLE "public"."vw_salary_comparison" TO "anon";
GRANT ALL ON TABLE "public"."vw_salary_comparison" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_salary_comparison" TO "service_role";



GRANT ALL ON TABLE "public"."vw_sergio_advances_balance" TO "anon";
GRANT ALL ON TABLE "public"."vw_sergio_advances_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_sergio_advances_balance" TO "service_role";



GRANT ALL ON TABLE "public"."vw_sora_queue_status" TO "anon";
GRANT ALL ON TABLE "public"."vw_sora_queue_status" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_sora_queue_status" TO "service_role";



GRANT ALL ON TABLE "public"."vw_sora_videos_ready" TO "anon";
GRANT ALL ON TABLE "public"."vw_sora_videos_ready" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_sora_videos_ready" TO "service_role";



GRANT ALL ON TABLE "public"."vw_terminations_detailed" TO "anon";
GRANT ALL ON TABLE "public"."vw_terminations_detailed" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_terminations_detailed" TO "service_role";



GRANT ALL ON TABLE "public"."vw_videos_to_show" TO "anon";
GRANT ALL ON TABLE "public"."vw_videos_to_show" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_videos_to_show" TO "service_role";



GRANT ALL ON TABLE "public"."vw_work_orders_with_details" TO "anon";
GRANT ALL ON TABLE "public"."vw_work_orders_with_details" TO "authenticated";
GRANT ALL ON TABLE "public"."vw_work_orders_with_details" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_executions" TO "anon";
GRANT ALL ON TABLE "public"."workflow_executions" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_executions" TO "service_role";



GRANT ALL ON TABLE "public"."workflows" TO "anon";
GRANT ALL ON TABLE "public"."workflows" TO "authenticated";
GRANT ALL ON TABLE "public"."workflows" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































